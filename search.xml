<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LTE MAC token bucket algorithm</title>
    <url>/2021/11/27/LTE-MAC-token-bucket-algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="abbreviation">Abbreviation</h1>
<p>Below are the abbreviation of some jargons that will be used in the
essay.</p>
<p>NW: network UL: uplink WFQ: weighted fair queueing</p>
<h1 id="preface">Preface</h1>
<p>In LTE protocol stack, MAC lies in the so-called layer2. One of its
main functionalities is managing the UL grant we receive from layer1. In
other words, it allocates the UL grant to different logic channels. In
this essay, I will briefly talk about how MAC layer allocates the UL
grant to different logic channel. It does so by implementing the toket
bucket algorithm, which is the official MAC UL sheduling algorithm used
by LTE MAC layer, specified in 3GPP specification 36.321. <span id="more"></span>
# Token bucket algorithm Suppose we have below 3 active logic channels.
For each logic channel, there will be a bucket which holds the tokens.
The size of token bucket for each logic channel are not neccessarily the
same. They may vary, depending on NW's configuration.</p>
<p>Each TTI, a certain amount of token will be injected to seperate
logic channel's token bucket. The amount of token injected each TTI is
equal to PBR, which is actually the data rate that we want to ensure
that the logic channel can achieve at the very least, to avoid that some
logic channel of higher priority might hog over the UL grant and hunger
those less prioritized logic channels to death. We want to make sure
that as long as there is UL grant, each logic channel might relish a
share of it, even for those of low priority. <img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-09-22-56-19.png" alt="2022-02-09-22-56-19"></p>
<p>In actual implementation, the token bucket algorithm is essentially a
combination of WFQ algorithm and round-robin queueing algorivthm. When
we get an UL grant, how should we allocate them to different logic
channels? For the sake of discussion, let's take the below graph as an
example. In below graph, each logic channel's token bucket has 500bytes
of token. And each logic channel's buffer has 3000bytes of data pending
in it. Now, if we get an UL grant of 3000bytes at some point, how should
we allocate it? If we allocate all of them to one logic channel, that
would be unfair to the other 2 logic channels because they don't get the
chance to send out any bit of data. Then how about sharing it fairly
among the logic channels? Well, that doesn't seem a wise choice as well,
because in the real-life scenario, some traffic, such as video or audio
data, are obviously more important than other application's traffic,
such as FTP. We can tolerate a slowly downloaded file but we have zero
tolerance for a jittering video call or voice call! <img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-09-23-24-07.png" alt="2022-02-09-23-24-07"></p>
<p>Alright, enough for those non-sense, then what should we do here?
Well, after the trade-off of fairness and effectiveness, someone came up
with an ingenuous idea that balances both pretty well. In the actual MAC
token bucket algorithm, there are 2 rounds of UL grant allocation. The
first round is actually somewhat like the WFQ algorithm. In this round,
we will start from the highest prioritized logic channel, we allocate a
part of the UL grant to it. How many? Depends on the available token
bytes and the data pending in the buffer. If there are too much data
pending the buffer that the number of token cannot match it, then sorry,
we can only allocate the size of the UL grant upto the amount of
available token to that particular logic channel at this round. The
number of token is the budget. We can't exceed the budget. If there are
not much pending data and the token is enough, then congratulation, we
don't have to consume all the token. Instead, we only need to allocate
the size of UL grant that is equal to the number pending data to that
logic channel. So, the grant allotment to a logic channel can be
summarized with one simple equation as follows. MIN stands for taking
the minimum value.</p>
<p><span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="57.317ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 25334.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(529,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(827,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1125,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1610,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(1971,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2849,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(3315,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(3915,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(4553.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(5609.6,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mi" transform="translate(6660.6,0)"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"/></g><g data-mml-node="mi" transform="translate(7164.6,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(8052.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(8441.6,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></g><g data-mml-node="mi" transform="translate(8944.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(9410.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(10010.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(10530.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(10875.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(11475.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(11952.6,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"/></g><g data-mml-node="mi" transform="translate(12452.6,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(12972.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(13501.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(13862.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(14391.6,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"/></g><g data-mml-node="mi" transform="translate(14891.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(15360.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(15705.6,0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mi" transform="translate(16170.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mo" transform="translate(16636.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(17081.2,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(17681.2,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(18253.2,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(19131.2,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(19560.2,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(20026.2,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(20477.2,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"/></g><g data-mml-node="mi" transform="translate(20977.2,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(21462.2,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(22012.2,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"/></g><g data-mml-node="mi" transform="translate(22512.2,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(22873.2,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(23358.2,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(23879.2,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/></g><g data-mml-node="mi" transform="translate(24345.2,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(24945.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></span></p>
<p>After allocating the UL grant to the highest logic channel, we will
apply the same logic to allocate the leftover grant to the rest logic
channel, one by one, from secondary highest prioritized logic channel
all the way down to the least significant logic channel, as long as
there is still UL grant left. This is how the first round works. The
main purpose of this round is fairness. Regardless it is good or bad, we
want to make sure every logic channel can enjoy a piece of the UL grant.
The quality of service each logic channel can get depends on the PBR and
token bucket size. They work together as the weight in the WFQ
algorithm. They defines the weight of each logic channel. Now, let's
take the above graph as an example. How will the situation looks like
after the first round of grant allocation? Well, apparently, each logic
channel has enough pending data(3000bytes), so all of their available
token(500bytes) will be consumed. So the situation will be as follows.
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-10-00-02-20.png" alt="2022-02-10-00-02-20"></p>
<p>All the logic channels' token bucket are empty. Each one's buffer
will have 500 bytes less(i.e. the amount the token consumed), so there
are now only 2500 bytes pending in each logic channels' buffer. The
leftover grant will be only 1500 bytes now. Now, after this round, seems
every body is happy with the result right? Everyone can enjoy a bit of
it. Fair enough. Well, is it? Suppose LICD1 is the highest prioritized
logic channel here, I'm afraid LCID1 will say no! Because sometimes some
traffic are much more important than the others(e.g. video or voice call
traffic versus downloaded file traffic), they should be preferred when
we allocate the UL grant. Fairness might backfire here if we only
consider it. So,in order to achieve effectiveness, we will adopt a
round-robin strategy in the second round of grant allocation.</p>
<p>Let's continue the analysis of the scenario above. Now we still have
1500 bytes of UL grant left. Each logic channel's token bucket is
already empty. And each logic channel still has 2500 bytes of pending
data. What should we do now? You might think that since the token bucket
is already empty, we cannot allocate the grant to any of the logic
channel and cannot send out any data anymore. But that's not the case,
because in this round token bucket is not involved at all. Remember, the
existence of token bucket is to ensure that each logic channel can get a
certain amount of UL grant and hence get some service, regardless of
good or bad. Since they have all be served in the first round, we have
acheived our goal, so there is no need to adhere to such principle in
this round anymore. Instead, we should forget it and try a best-effort
strategy in order that the most important logic channel can get the best
service. Therefore, starting from the highest prioritized logic channel,
we will allocate all the leftover UL grant to it as long as there is
enough data in its buffer to consume the UL grant. If after its pending
data is all consumed, there is still UL grant left, then we will
continue to apply the same logic to the secondary highest prioritized
logic channel, until the UL grant has all been consumed or all logic
channels' data has been consumed. So, in this round, all the leftover UL
grant(1500 bytes) will be allocated to logic channel 1, and logic
channel 1 will have 1000 bytes left. LCID3 and LCID5 channels don't get
the chance to be served in this round, but that's ok since they have
been served in the first round. The scenario will be as below after the
second round. <img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-10-23-37-24.png" alt="2022-02-10-23-37-24"></p>
<p>There are also might be some minor details skipped here, but that's
the general idea of the token bucket algorithm used in actual
implementation.</p>
<h1 id="reference">Reference</h1>
<p>[1] Computer Networks: A Top-Down Approach. By Behrouz A. Forouzan,
Firouz Mosharraf [2] Computer Networks. By ANDREW S. TANENBAUM, DAVID J.
WETHERALL [3] 36.321. By 3GPP specialist panel.</p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title>LTE网络RLC层的polling机制</title>
    <url>/2022/06/16/LTE%E7%BD%91%E7%BB%9CRLC%E5%B1%82%E7%9A%84polling%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>本文将从UE角度对LTE网络RLC层的polling机制进行详细阐述。 # 前言
在LTE网络中，RLC层提供了两种服务模式，一种是保证数据无损传输(lossless)的<code>AM模式</code>(acknowledged
mode)，另一种是不保证数据可靠传输的<code>UM模式</code>(unacknowledged
mode)。在<code>AM模式</code>下，RLC层要保证数据可靠传输，因此，此时的RLC协议是一种<code>可靠性数据传输协议</code>(reliable
data transmission protocol, RDP)。</p>
</blockquote>
<p>RDP是网络协议中常用的一种协议，TCP协议就是其中之一。与TCP协议相比，RLC位于无线通信协议栈的更底层，对时延的要求更高。因此，为了更快地实现数据的无损传输，RLC层引入了<code>polling</code>(问询)机制。
<span id="more"></span> --- # Polling的目的
UE<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="User equipment，在蜂窝网络中指终端设备，大部分场景下是手机，也可能是智能手表，智能仪表等其它无线终端设备。
">[1]</span></a></sup>
在向网络发送数据的过程中，由于物理层存在一定的误码率(BLER)，有一些包(packet,
即RLC
PDU)有时候可能会在传输过程中发送失败或者丢失。但是，哪一些包发送失败了，从UE侧是无法知道的。因此，为了实现数据的可靠传输，UE需要网络侧的反馈，告诉UE在网络侧哪一些包已经收到，哪一些还没有收到，从而让UE能够重传那些网络还没收到的包，这个反馈就是<code>状态报告</code>(status
report)。</p>
<p>但是网络侧怎么能够知道什么时候给UE发送<code>状态报告</code>呢？如果网络侧频繁不停地给UE发送<code>状态报告</code>，那么虽然UE能够很及时地知道网络侧接收情况，但是这样就浪费了很多下行资源；而如果网络侧周期性地给UE发送<code>状态报告</code>，那么UE侧又无法及时得知网络侧的接收情况。引入<code>Polling</code>就是为了这个目的。UE需要向网络询问，哪一些包收到了，哪一些还没收到，这样网络就会回复<code>状态报告</code>，UE就能及时地重传那些没被网络收到(acknowledged)的包。</p>
<table style="width:6%;">
<colgroup>
<col style="width: 5%">
</colgroup>
<thead>
<tr>
<th># Polling的触发条件 在每个RLC data
PDU的header部分，有一个P位的标志位，这个标志位就代表<code>polling</code>。当P位为1时，表示UE向网络侧发送<code>polling</code>，期望对方回复<code>状态报告</code>，反之亦然。在以下任一条件满足的情况下，UE都会触发<code>polling</code>：</th>
</tr>
</thead>
<tbody>
<tr>
<td># 总结
本文从UE侧角度介绍了LTE网络RLC层的一个基本功能——<code>polling</code>机制。<code>polling</code>机制只在<code>AM模式</code>下才会生效，其目的是为了能及时得知网络侧的接收情况，从而及时地向网络重传丢失的数据包，保证数据的低时延可靠传输。最后介绍了<code>polling</code>的触发条件。</td>
</tr>
</tbody>
</table>
<h1 id="参考文献">参考文献</h1>
<p>[1] 3GPP协议 36322 section 5.2.2 [2] <font color="DodgerBlue">Radio
Protocols for LTE and LTE-Advanced (2012)</font> by SeungJune Yi,
SungDuck Chun, etl. section 5.4.4 [3] 深入理解LTE-A. 温金辉著. section
36.3.3.2</p>
<div id="footnotes">
<hr>
<div id="footnotelist">
<ol style="list-style: none; padding-left: 0; margin-left: 40px">
<li id="fn:1">
<span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">User
equipment，在蜂窝网络中指终端设备，大部分场景下是手机，也可能是智能手表，智能仪表等其它无线终端设备。<a href="#fnref:1" rev="footnote">
↩︎</a></span>
</li>
<li id="fn:2">
<span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Sequence
number，每一包RLC data PDU都有一个sequence
number，在一段时间内可以唯一标识这包RLC data
PDU。<a href="#fnref:2" rev="footnote"> ↩︎</a></span>
</li>
</ol>
</div>
</div>

]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>RLC</tag>
      </tags>
  </entry>
  <entry>
    <title>Telnet使用SMTP服务登录邮箱并发送邮件</title>
    <url>/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>本文介绍SMTP协议的一个简单的网络实验。 # SMTP协议简介 SMTP（定义于RFC
5321）是互联网电子邮件的核心。SMTP将邮件从发件人的邮件服务器传输到收件人的邮件服务器。SMTP的出现比HTTP早得多。（最初的SMTP
RFC文档可以追溯到1982年，而SMTP协议的出现时间还要早得多。）
<span id="more"></span></p>
</blockquote>
<p>尽管SMTP拥有许多优秀的特性，其在互联网上的普及程度也证明了这一点，但它毕竟是一项具有某些过时特征的遗留技术。例如，它限制所有邮件的正文（而不仅仅是邮件头）只能使用简单的7比特ASCII编码。这种限制在20世纪80年代初期是合理的，当时传输容量有限，而且没有人会通过电子邮件发送大型附件或大型图像、音频或视频文件。但如今，在多媒体时代，7比特ASCII的限制就显得有些不便了——它要求二进制多媒体数据在通过SMTP发送之前必须编码为ASCII编码；它要求在SMTP传输后将相应的ASCII消息解码回二进制。而HTTP协议并不要求多媒体数据在传输前进行ASCII编码。</p>
<p>这里介绍一下SMTP的一个简单的实验过程，有关STMP协议的更多介绍可以参考文献[1]<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Computer Networking_ A Top-Down Approach-Pearson (2021) 第2.3.1节 SMTP. By James W. Kurose, Keith W. Ross
">[1]</span></a></sup>。本实验过程参考了文献[2]<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Telnet 使用 SMTP 服务登录邮箱并发送邮件](https://cloud.tencent.com/developer/article/1927198)">[2]</span></a></sup>。</p>
<hr>
<h1 id="实验准备">实验准备</h1>
<p>准备两个163邮箱，并开启SMTP服务。如下图所示。 <img src="/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/2025-11-27-20-44-24.png" alt="2025-11-27-20-44-24"></p>
<p>开启IMAP/SMTP服务以及POP3/SMTP服务。 <img src="/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/2025-11-27-20-44-54.png" alt="2025-11-27-20-44-54"></p>
<hr>
<h1 id="实验步骤">实验步骤</h1>
<ol type="1">
<li><p>使用telnet连接smtp服务器 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet smtp.163.com  25   //直接进入回显模式</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看连接是否建立 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helo localhost</span><br></pre></td></tr></table></figure></p></li>
<li><p>登录 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auth login</span><br></pre></td></tr></table></figure>
输入账号和授权密码，账号和授权密码要以base64编码的形式输入，授权密码不是邮箱密码，要在163邮箱主页开启邮箱的SMTP服务后再获取。</p></li>
</ol>
<figure>
<img src="/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/2025-11-27-20-45-48.png" alt="2025-11-27-20-45-48">
<figcaption aria-hidden="true">2025-11-27-20-45-48</figcaption>
</figure>
<p>邮箱： 18*******32@163.com</p>
<p>授权密码(在打开IMAP/SMTP服务时会弹出，记下此授权密码，在登录时需要用到该密码)：
<img src="/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/2025-11-27-20-46-30.png" alt="2025-11-27-20-46-30"></p>
<p>若已有授权密码，也可以新增授权密码。 <img src="/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/2025-11-27-20-46-38.png" alt="2025-11-27-20-46-38"></p>
<p>接下来输入邮件信息，其中mail from必须是发送邮箱的账号，rcpt
to必须是接收邮箱的账号，否则会被认为是无效邮件而无法发送。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#邮件头，必须是正确的</span></span><br><span class="line">mail from: &lt;aa27975599672021@163.com&gt;</span><br><span class="line">rcpt to:  &lt;aa27975599672022@163.com&gt;</span><br><span class="line"><span class="comment">#开始输入邮件正文</span></span><br><span class="line">data</span><br><span class="line">from: &lt;aa27975599672021@163.com&gt;</span><br><span class="line">to:  &lt;aa27975599672022@163.com&gt;</span><br><span class="line">subject:hello,aa27975599672022@163.com</span><br><span class="line"><span class="comment">#空一行</span></span><br><span class="line">hello</span><br><span class="line"><span class="comment">#空一行，后面输入一个点后回车表示结束</span></span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<p>发送过程 <img src="/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/2025-11-27-20-46-49.png" alt="2025-11-27-20-46-49"></p>
<p>在接收邮箱中查看，可以看到接收到了所发送的邮件 <img src="/2025/11/27/Telnet%E4%BD%BF%E7%94%A8SMTP%E6%9C%8D%E5%8A%A1%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%B9%B6%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/2025-11-27-20-46-58.png" alt="2025-11-27-20-46-58"></p>
<hr>
<h1 id="参考">参考</h1>
<div id="footnotes">
<hr>
<div id="footnotelist">
<ol style="list-style: none; padding-left: 0; margin-left: 40px">
<li id="fn:1">
<span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Computer
Networking_ A Top-Down Approach-Pearson (2021) 第2.3.1节 SMTP. By James
W. Kurose, Keith W. Ross<a href="#fnref:1" rev="footnote"> ↩︎</a></span>
</li>
<li id="fn:2">
<span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://cloud.tencent.com/developer/article/1927198">Telnet
使用 SMTP 服务登录邮箱并发送邮件</a><a href="#fnref:2" rev="footnote">
↩︎</a></span>
</li>
</ol>
</div>
</div>

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>computer networking</tag>
        <tag>SMTP</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04编译及安装LLDB</title>
    <url>/2021/12/16/compile-and-install-lldb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言">前言</h1>
<p>在<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#%E7%AE%80%E4%BB%8B">在ubuntu20.04安装LLVM</a>已经介绍了如何在本地编译及安装llvm，但是当时只是编译和安装了<code>llvm;clang;libcxx;libcxxabi</code>这四个库，本文将介绍如何编译及安装lldb。
<span id="more"></span> # 配置及安装LLDB
在进行下面的步骤时，假设你已经下载了llvm整个工程，并且安装了所需的依赖工具。如果你还没进行这些操作，可以参考<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#%E7%AE%80%E4%BB%8B">在ubuntu20.04安装LLVM</a>一文的<code>本地编译安装LLVM</code>一节的<code>前提条件</code>和<code>下载LLVM源文件</code>这两部分内容，先完成这两步。</p>
<p>完成上述步骤后，输入以下命令。首先cd进入llvm-project工程，然后生成cmake文件。<code>-S llvm</code>表示源文件所在文件夹为当前路径下的llvm文件夹；<code>-B build</code>表示生成的cmake文件将放到当前路径下的build文件夹；<code>-G Ninja</code>表示生成的cmake文件将给Ninja在编译时使用。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build #若已经创建build目录此步可以省略</span><br><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; #1,这条命令与下面这条命令2选1</span><br><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; ./llvm #2,这条命令与上面的命令2选1</span><br><span class="line">cd build</span><br><span class="line">ninja lldb</span><br></pre></td></tr></table></figure> 在编译到第[4169/4171]个文件时，会出现以下错误。 <img src="/2021/12/16/compile-and-install-lldb/2021-12-18-17-22-28.png" alt="2021-12-18-17-22-28"> 参考<a href="https://blog.csdn.net/Vin_tt/article/details/110421022">这篇文章</a>解决这个问题，输入以下命令:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project/build</span><br><span class="line">sudo mkdir swapfile</span><br><span class="line">cd /swapfile</span><br><span class="line">sudo dd if=/dev/zero of=swap bs=1024 count=20000000</span><br><span class="line">sudo mkswap -f swap</span><br><span class="line">sudo swapon swap</span><br></pre></td></tr></table></figure> <img src="/2021/12/16/compile-and-install-lldb/2021-12-18-17-56-57.png" alt="2021-12-18-17-56-57">
可以看到，剩下的三个文件都被成功地编译了。编译出来生成的应用程序位于llvm-project/build/bin路径下，将其拷贝到/usr/local/bin/文件夹下即可。
<img src="/2021/12/16/compile-and-install-lldb/2021-12-18-18-17-50.png" alt="2021-12-18-18-17-50"> # 后记
这部分讲的是后续的失败经历，以及没有解决的问题。</p>
<p>上述编译命令在编译lldb过程中会有debug信息，其体积会很大，而且编译出来的文件在llvm-project/build文件夹下面，还需要<code>ninja install</code>命令将其安装至默认路径下，但是由于体积过大，在安装时容易出问题。最好是编译release版本，并且在生成cmake文件的时候指明安装路径，命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build #若已经创建build目录此步可以省略</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;lldb&quot;</span> <span class="comment">#1,这条命令与下面这条命令2选1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;lldb&quot;</span> ./llvm <span class="comment">#2,这条命令与上面的命令2选1</span></span></span><br><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLDB_INCLUDE_TESTS=OFF -DCMAKE_INSTALL_PREFIX=&quot;/usr/local/llvm&quot; #1,这条命令与下面这条命令2选1</span><br><span class="line">cmake -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLDB_INCLUDE_TESTS=OFF -DCMAKE_INSTALL_PREFIX=&quot;/usr/local/llvm&quot; ./llvm #2,这条命令与上面的命令2选1</span><br><span class="line">cd build</span><br><span class="line">ninja lldb</span><br></pre></td></tr></table></figure>
编译完成后，生成的文件位于llvm-project/build文件夹内，我们要把它们安装到/usr/local/路径下，因此，需要输入以下命令
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ninja install</span><br></pre></td></tr></table></figure>
然后就会开始将lldb安装到/usr/local/路径下,在安装到第[203/1128]个文件时，出现了<code>fatal error: ld terminated with signal 9 [Killed]</code>错误，参照上面的方法，在build文件夹创建swapfile尝试解决。
<img src="/2021/12/16/compile-and-install-lldb/2021-12-21-23-18-01.png" alt="2021-12-21-23-18-01">
在安装剩下的文件时，安装到[375/927]个文件时仍然出现了以上错误。 <img src="/2021/12/16/compile-and-install-lldb/2021-12-22-08-27-51.png" alt="2021-12-22-08-27-51"> 再次尝试用上述方法安装剩下的文件。 <img src="/2021/12/16/compile-and-install-lldb/2021-12-22-08-39-08.png" alt="2021-12-22-08-39-08"> 依旧出现以上问题，最终只得作罢。 <img src="/2021/12/16/compile-and-install-lldb/2021-12-22-09-05-29.png" alt="2021-12-22-09-05-29"></p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><a href="https://lldb.llvm.org/resources/build.html#building-lldb-with-cmake">Building
LLDB with CMake</a></li>
<li><a href="https://blog.csdn.net/Vin_tt/article/details/110421022">LLVM编译collect2:
fatal error: ld terminated with signal 9</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>LTE网络MAC层令牌桶算法</title>
    <url>/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引言">引言</h1>
<p>LTE MAC层的一个重要的功能是从各个逻辑信道读取数据(MAC
SDU)，然后将它们封装成一个数据块(MAC transport
block)，再交给物理层从空口发生出去，这个过程叫packet build。每一次packet
build能发送的数据块的大小由网络决定，网络会通过PDCCH指示UE在哪个子帧上可以发送多少字节的数据，可以发送的字节数就是最终能发送的数据块的大小，也叫UL
grant(Uplink grant)。 <span id="more"></span> 那么UE的MAC层在接收到UL
grant后，应该如何将这些UL grant分配到不同的逻辑信道上呢？是要将这些UL
grant平均分配给当前所有的逻辑信道，每个逻辑信道都能发送同样的数据量吗？这个方法虽然很公平，但是却并不高效，主要有两个原因，其一，不同逻辑信道之间要发送的数据量可能差异非常大，这就导致了对有的逻辑信道来说所分得的UL
grant不足以发送buffer里所有的数据，而对另一些逻辑信道来说所分得的UL
grant可能又太多了，超出了buffer里的数据量，从而造成了浪费。那么按照先来后到的原则行不行，先发送最早激活的逻辑信道的数据，假如在清空该逻辑信道的buffer后，如果还有剩余的UL
grant，再发送次早激活的逻辑信道的数据，依次类推。按照这种方法，能够保证所有的UL
grant都被用来发送有效数据，不会造成资源浪费，但是这时又出现了另外一个问题，假如先激活的逻辑信道数据量一直很大，而后激活的逻辑信道数据量虽然没那么大，但是却很重要，这就会导致所有的UL
grant都被用来发送先激活的逻辑信道数据了，而后激活的逻辑信道却始终得不到服务，重要的数据发不出去，这样会导致某些上层应用完全停滞，严重影响用户体验。那么按照逻辑信道优先级来服务呢？先发送优先级最高的逻辑信道的数据，再依次发送低优先级逻辑信道的数据，这样就能保证重要的数据先发送出去。但是这样也会有类似的问题，假如高优先级逻辑信道的数据量一直很大，就会导致低优先级逻辑信道一直得不到服务，通俗来说就是一直处于饥饿状态。</p>
<p>为了能既保证一定程度的公平(即所有的逻辑信道都能得到不同程度的服务)又兼顾效率(即UL
grant不会被浪费)，LTE的MAC层的packet build过程采用了令牌桶算法(token
bucket algorithm)。 # 令牌桶算法概述
令牌桶算法被广泛用于有线网络和无线网络的数据调度中。令牌桶算法工作过程大致如下图(a)和<span class="math inline">\((c)\)</span>所示。主机维护了一个令牌桶，以速率R往令牌桶中注入令牌。主机往网络发送数据的时候，会先判断令牌桶里面是否还有令牌，如果有，才能发送数据，并且发送多少数据就从令牌桶中取出多少令牌。如果令牌桶为空，那么主机就不能向网络发送数据了，所有的packet只能缓存在主机的队列里。</p>
<figure>
<img src="/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/2022-06-17-00-38-27.png#pic_center" alt="2022-06-17-00-38-27">
<figcaption aria-hidden="true">2022-06-17-00-38-27</figcaption>
</figure>
<p>在传统的有线网络中，令牌桶算法可被应用于路由器(网络层, network
layer)，用于对网络流量进行平滑整形，以减少网络拥塞。令牌桶限制了数据流的长期速率，但是却允许短期的数据洪流(burst)。主机在短时间内可以以极高的速率发送数据，而不必缓存任何的数据，因此在这段时间内数据不会有任何的时延。从长期来看，数据速率会被限定为令牌增加的速率R，一旦令牌桶被清空，后续的数据发送速率就只能受限于令牌注入的速度了。</p>
<p>在无线通信网络中，令牌桶算法可以用于保证不同的上层业务的服务质量(QoS,
quality of service)。在LTE网络里，MAC层就采用了令牌桶算法。 #
MAC令牌桶算法实现
MAC实体在每一次要进行HARQ新传的时候，都会按照令牌桶(token
bucket)算法对UL grant进行分配，这个过程叫<strong>Logical Channel
Prioritization</strong>过程。</p>
<p>对每个逻辑信道，RRC都为其分配一个逻辑信道优先级(<strong>priority</strong>)，以此控制上行数据的调度。优先级的数字越小，其优先级越高。比如，SRB1(逻辑信道ID为1)的优先级通常为1，表示其优先级最高。除了逻辑信道优先级，RRC还会分配<strong>prioritisedBitRate</strong>，<strong>bucketSizeDuration</strong>
这两个参数。<strong>prioritisedBitRate</strong>(PBR, Prioritized Bit
Rate)表示对每个逻辑信道的缓存数据需要以多大的速率进行优先处理，保证了各个逻辑信道的最低服务质量。<strong>bucketSizeDuration</strong>
(BSD, Bucket Size
Duration)表示令牌桶的深度，通过限制令牌桶的深度对突发数据流(data
burst)进行一定程度的流控，从而保证数据的平滑传输。</p>
<p>对每个逻辑信道(用变量<span class="math inline">\(j\)</span>表示)，MAC实体都为其维护一个变量<span class="math inline">\(B_{j}\)</span>，<span class="math inline">\(B_{j}\)</span>表示令牌桶当前令牌数目
。在该逻辑信道新添加时，需要将<span class="math inline">\(B_{j}\)</span>初始化为0，其后每个TTI(对LTE来说是1ms)，<span class="math inline">\(B_{j}\)</span> 都应增加PBR ×
TTI(即PRB)，表示往令牌桶中新增加令牌数为PBR，其中PBR就是该逻辑信道需要优先处理的数据比特率(Prioritized
Bit Rate of logical channel <span class="math inline">\(j\)</span>)。<span class="math inline">\(B_{j}\)</span>不会无限增大，当令牌桶的令牌溢出时，<span class="math inline">\(B_{j}\)</span>的值就会被限定为令牌桶的大小，其大小为<span class="math inline">\(B_{j}=\)</span> PBR ×
BSD。PBR和BSD都是由RRC层配置，RRC层在配置MAC实体时会设置这两个参数。</p>
<p>当MAC实体收到UL grant，需要进行新传时，UL
grant的分配过程如下图所示，这个过程叫Logical Channel Prioritization
procedure。 <img src="/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/2022-06-17-00-44-53.png#pic_center" alt="2022-06-17-00-44-53"></p>
<p>根据上图，MAC实体按以下过程对UL grant进行分配。</p>
<ol type="1">
<li>按逻辑信道优先级从高到低的顺序对UL
grant进行分配，对每个逻辑信道进行组包(MAC UL transport
block)。注意，这里是按逻辑信道优先级排序。因为数字越小表示优先级越高，所以会从priority数字最小的逻辑信道开始进行组包。在分配UL
grant给逻辑信道<span class="math inline">\(j\)</span>的时候，会先看看令牌桶还有多少令牌(即<span class="math inline">\(B_{j}\)</span>有多大)，如果令牌数大于等于buffer的数据量(即<span class="math inline">\(B_{j}\geqslant\)</span>
buffer的数据量)，那么给逻辑信道<span class="math inline">\(j\)</span>的buffer有多少数据，就给它分配多少UL
grant，当然如果UL grant不足以发送逻辑信道<span class="math inline">\(j\)</span>的buffer里所有的数据，那么有多少UL
grant就给它分配多少UL grant。如果令牌数小于buffer的数据量(即<span class="math inline">\(B_{j}&lt;\)</span>
buffer的数据量)，那么有多少令牌就分配多少UL grant，当然如果UL
grant比令牌数还小，那就把所有的UL grant都分配给逻辑信道<span class="math inline">\(j\)</span>。当逻辑信道<span class="math inline">\(j\)</span>的PBR设为"infinity"时，则在为其分配UL
grant时不会考虑其<span class="math inline">\(B_{j}\)</span>的大小，所有的UL
grant都会先分配给该逻辑信道，假如在发送完其buffer的数据后，还有剩余的UL
grant，这时才会再将剩余的UL grant分配给其它的逻辑信道。</li>
<li>从逻辑信道<span class="math inline">\(j\)</span>的<span class="math inline">\(B_{j}\)</span>中减去步骤1所build的所有MAC
SDUs的大小之和。(参考实现：对于逻辑信道<span class="math inline">\(j\)</span>，每传输一个RLC SDU，先比较<span class="math inline">\(B_{j}\)</span>是否大于0。如果<span class="math inline">\(B_{j}&gt;0\)</span>，则往MAC
PDU中添加该SDU，然后<span class="math inline">\(B_{j}-=\)</span>sizeof(RLC
SDU)，并判断是否满足<span class="math inline">\(B_{j}\leqslant
0\)</span>，如此反复，直到满足<span class="math inline">\(B_{j}\leqslant
0\)</span>，再处理下一逻辑信道)。</li>
<li>如果前两步执行完还剩有UL grant的话，则不管<span class="math inline">\(B_{j}\)</span>的大小，把剩余的UL
grant按照逻辑信道优先级从高到低分配给各个逻辑信道。只有当高优先级的逻辑信道服务完(即所有的数据都发送完毕)，且还有剩余的UL
grant可用于服务剩余的逻辑信道时，才会继续服务优先级较低的逻辑信道。对剩余的逻辑信道也是执行同样的逻辑。在这一步，因为所有的逻辑信道都已经得到了最低保障，因此不会再考虑公平的原则。MAC实体会尽全力服务高优先级的逻辑信道，尽可能地把高优先级的逻辑信道的数据尽快发送出去。</li>
</ol>
<p>在上述UL grant分配过程中，MAC层遵循以下原则：</p>
<ul>
<li>如果剩余的UL grant足够发送整个RLC SDU，则不应对该SDU分段。</li>
<li>如果受限于剩余UL grant的大小，不得不对RLC SDU分段，则应根据剩余UL
grant的大小，尽可能地填入最大的分段。即尽可能地有效利用剩余的UL
grant。</li>
<li>应最大化数据的传输。</li>
<li>如果某个无线承载(RB, radio
bearer)被挂起(suspend)，那么不应该build该RB所对应逻辑信道的数据。</li>
<li>如果UL grant<span class="math inline">\(\geqslant\)</span>
4bytes，而buffer里还有数据要发送时，则MAC实体不应该把这些UL
grant都用来发送padding
BSR或者padding，换言之MAC实体应该尽可能发送有效数据，除非UL grant <span class="math inline">\(&lt;\)</span> 7bytes且要发送的数据是RLC PDU
segment，此时因为UL grant不足以发送任何的RLC PDU
payload，因此只能发送padding BSR或者padding。</li>
</ul>
<p>如果所有的逻辑信道的PBR都设为0
kBps，就不再保证各个逻辑信道的服务质量都能得到最低保障，此时就会退化为只考虑优先级的调度算法，等价于上面的算法只剩下第三步。在这种情况下，MAC实体会尽力服务优先级更高的逻辑信道，然后依次往下服务低优先级的逻辑信道。当然，对每个逻辑信道的服务都是建立在UL
grant还有剩余的前提下，如果UL
grant已经用完，那么剩余的逻辑信道在本次packet
build就不能得到服务了。</p>
<p>在上述算法的第二步可以看到，<span class="math inline">\(B_{j}\)</span>的值可能为负，这是因为，在算法的第一步，会遵循尽量不对RLC
SDU分段的原则。在UL grant足够的情况下，宁可让<span class="math inline">\(B_{j}\)</span>的使用超出预算，也要争取把RLC
SDU给完整地build完。因此，当<span class="math inline">\(B_{j}&gt;0\)</span>，但<span class="math inline">\(B_{j}-\)</span>sizeof(RLC SDU)<span class="math inline">\(&lt;0\)</span>时，假如剩余的UL
grant足够的话，MAC实体依然会在本次build完这个RLC
SDU，而不是对其分段。在build完这个RLC SDU后，<span class="math inline">\(B_{j}\)</span>将为负数，令牌桶的令牌已经用完，逻辑信道<span class="math inline">\(j\)</span>就不能再build任何RLC SDU了。其后，<span class="math inline">\(B_{j}\)</span>将逐渐恢复，在每个子帧，<span class="math inline">\(B_{j}\)</span>都会增加PBR，只有当<span class="math inline">\(B_{j}&gt;0\)</span>，即令牌桶又有令牌了，才能继续对逻辑信道<span class="math inline">\(j\)</span>进行packet build。</p>
<p>以上的算法可以用以下的伪代码表示(仅供参考，真正的实现有所出入)：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sort the logic channel by priority</span><br><span class="line"></span><br><span class="line">iterate each active logic channel from highest priority to lowest</span><br><span class="line">  <span class="keyword">if</span> Bj &gt;= available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">    <span class="keyword">if</span> UL grant is sufficient to send all the available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      UL grant -= available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      build all the packet in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allocate all the UL grant to the current logic channel</span><br><span class="line">      build all UL grant bytes <span class="keyword">for</span> the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> UL grant is sufficient to use up all the Bj</span><br><span class="line">      UL grant -= Bj</span><br><span class="line">      build Bj bytes RLC PDUs</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allocate all the UL grant to the current logic channel</span><br><span class="line">      build all UL grant bytes <span class="keyword">for</span> the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> there is still any UL grant left</span><br><span class="line">  iterate each active logic channel from highest priority to lowest</span><br><span class="line">    leftover UL grant is used to serve the leftover data in the buffer</span><br><span class="line">    <span class="keyword">if</span> there is no leftover UL grant</span><br><span class="line">      <span class="keyword">break</span>;        </span><br></pre></td></tr></table></figure></p>
<h1 id="参考文献">参考文献</h1>
<p>[1] 深入理解LTE-A. 温金辉著. 第17章17.1节 [2] 3GPP协议36.321.
第5.4.3.1节 [3] Computer networks(fifth edition). By Andrew S. Tanenbaum
etl. Section 5.4.2</p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04编译lldb-mi</title>
    <url>/2021/12/28/compile-lldb-mi/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言">前言</h1>
<p>lldb-mi(lldb machine
interface)是一个C/C++调试器，原来是LLVM项目中lldb的一部分，但是由于长时间没有人维护和更新，于是是从LLVM项目的lldb中分了出去，成为单独的一个工程。在linux环境下，使用vscode对C/C++代码进行调试时，常用的调试器是GDB，除此之外，还有个选择就是lldb-mi。本文将介绍如何在本地对lldb-mi工程源码进行编译，从而生成可执行文件。编译lldb-mi，需要一个C++14编译器以及LLDB，而LLDB又依赖于Clang和LLVM，因此，在编译lldb-mi之前，需要先安装Clang，LLVM和LLDB，可以参考<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/">这篇博客</a>进行安装。
<span id="more"></span> # 编译 输入以下命令， <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ #进入home目录</span><br><span class="line">mkdir buildspace #在home目录下建立buildspace目录</span><br><span class="line">cd ~/buildspace #进入buildspace目录</span><br><span class="line">mkdir llvm-inst #创建llvm-inst目录</span><br><span class="line">git clone https://github.com/lldb-tools/lldb-mi #将lldb-mi工程下载到当前目录（即buildspace目录）</span><br><span class="line">cd lldb-mi #进入lldb-mi工程目录里</span><br><span class="line">mkdir build #在当前目录（即lldb-mi目录）建立build目录，用来存放编译后生成的文件</span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=~/buildspace/llvm-inst/ -GNinja .. #在当前目录（即build目录）的上一级目录（即lldb-mi目录）下生成cmake文件</span><br><span class="line">ninja #编译</span><br></pre></td></tr></table></figure>
执行完以上命令后，可以看到，所生成的lldb-mi可执行文件将位于lldb-mi/build/src目录下，这个就是lldb-mi调试器。然后，我们就可以开始在vscode中使用这个调试器对程序进行调试了。
<img src="/2021/12/28/compile-lldb-mi/2021-12-29-00-49-15.png" alt="2021-12-29-00-49-15"> # 参考文献 1. <a href="https://github.com/lldb-tools/lldb-mi">Building against custom
LLDB</a> 2. <a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/">在ubuntu20.04安装LLVM</a></p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
        <tag>lldb-mi</tag>
        <tag>调试器</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/27/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>. <span id="more"></span> ##
Quick Start</p>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>在ubuntu20.04安装最新版GCC</title>
    <url>/2021/12/10/install-latest-gcc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言">前言</h1>
<p>在<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#more">编译LLVM</a>过程中，出现了很多头文件无法解析的错误，根据<a href="https://reviews.llvm.org/rGac7031b2b2fa">网上的说法</a>，原因是因为GCC版本过低，将GCC升级至最新版11.2.0就可以解决这个问题了。本文将介绍如何升级GCC到最新版(当前为11.2.0)。
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-33-08.png" alt="2021-12-10-23-33-08"> <span id="more"></span> # 下载gcc最新源码包
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.gz</span><br></pre></td></tr></table></figure> <img src="/2021/12/10/install-latest-gcc/2021-12-10-19-24-58.png" alt="2021-12-10-19-24-58"> # 解压缩 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf gcc-11.2.0.tar.gz</span><br></pre></td></tr></table></figure> <img src="/2021/12/10/install-latest-gcc/2021-12-10-19-27-42.png" alt="2021-12-10-19-27-42"> # 进入解压缩目录 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gcc-11.2.0</span><br></pre></td></tr></table></figure> #
运行预备库下载脚本
运行download_prerequisites脚本,这个脚本会自动帮你下载所需要的依赖文件和库：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
在运行该脚本时，出现以下错误，无法下载依赖文件库<code>gmp-6.1.0.tar.bz2</code>。
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-37-55.png" alt="2021-12-10-19-37-55"> 解决办法为改从清华镜像源下载，
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gmp/gmp-6.1.0.tar.bz2 #从清华镜像源下载gmp-6.1.0.tar.bz2文件</span><br><span class="line">tar xvfj gmp-6.1.0.tar.bz2 #解压缩文件</span><br><span class="line">ln -s gmp-6.1.0 gmp #在当前目录下创建名为gmp的快捷方式，链接到gmp-6.1.0文件夹</span><br></pre></td></tr></table></figure> 改从清华镜像源下载后速度真的很快。 <img src="/2021/12/10/install-latest-gcc/2021-12-10-19-44-43.png" alt="2021-12-10-19-44-43"> <img src="/2021/12/10/install-latest-gcc/2021-12-10-19-45-18.png" alt="2021-12-10-19-45-18">
继续执行脚本下载依赖文件，出现以下错误，无法下载依赖文件库<code>mpfr-3.1.6.tar.bz2</code>。
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-50-42.png" alt="2021-12-10-19-50-42"> 解决办法为改从清华镜像源下载，
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpfr/mpfr-3.1.6.tar.bz2 #从清华镜像源下载mpfr-3.1.6.tar.bz2文件</span><br><span class="line">tar xvfj mpfr-3.1.6.tar.bz2 #解压缩文件</span><br><span class="line">ln -s mpfr-3.1.6 mpfr #在当前目录下创建名为mpfr的快捷方式，链接到mpfr-3.1.6文件夹</span><br></pre></td></tr></table></figure> <img src="/2021/12/10/install-latest-gcc/2021-12-10-19-54-01.png" alt="2021-12-10-19-54-01"> <img src="/2021/12/10/install-latest-gcc/2021-12-10-19-54-59.png" alt="2021-12-10-19-54-59"> 继续执行脚本下载， <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
出现以下错误，无法下载<code>mpc-1.0.3.tar.gz</code>文件， <img src="/2021/12/10/install-latest-gcc/2021-12-10-20-04-14.png" alt="2021-12-10-20-04-14"> 解决办法为改从清华镜像源下载，
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpc/mpc-1.0.3.tar.gz</span><br><span class="line">tar xvfz mpc-1.0.3.tar.gz</span><br><span class="line">ln -s mpc-1.0.3 mpc #在当前目录下创建名为mpc的快捷方式，链接到mpc-1.0.3文件夹</span><br></pre></td></tr></table></figure> <img src="/2021/12/10/install-latest-gcc/2021-12-10-20-07-46.png" alt="2021-12-10-20-07-46"> 继续执行下载脚本， <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
出现以下错误，无法下载<code>isl-0.18.tar.bz2</code>文件， <img src="/2021/12/10/install-latest-gcc/2021-12-10-20-23-02.png" alt="2021-12-10-20-23-02">
因为这个文件在清华镜像源上没有，因此解决办法为从GNU官网通过http下载：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2</span><br><span class="line">tar xvfj isl-0.18.tar.bz2</span><br><span class="line">ln -s isl-0.18 isl</span><br></pre></td></tr></table></figure> # 创建编译目录 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir gcc-build</span><br><span class="line">cd $_</span><br></pre></td></tr></table></figure> <img src="/2021/12/10/install-latest-gcc/2021-12-10-20-30-04.png" alt="2021-12-10-20-30-04"> # 生成Makefile文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib #../configure表示返回上级目录执行configure命令</span><br></pre></td></tr></table></figure>
<code>–enable-languages</code>表示你要让你的gcc支持那些语言，<code>–disable-multilib</code>表示不生成编译为其他平台可执行代码的交叉编译器。<code>–disable-checking</code>表示生成的编译器在编译过程中不做额外检查，也可以使用<code>–enable-checking=xxx</code>来增加一些检查。
# 编译 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
这里-j8表示的是使用8核进行编译，因为我的电脑CPU为8核。因为make默认是serial
build的，如果不加-j选项，就不会开启多核parallel
build，这样的话速度会慢很多，所以这里我开启了8核编译。即便如此，这一步花费时间也非常长，我在虚拟机里用了将近两个小时完成这一步，而且虚拟机一定要留出至少20GB的空间，不然可能会出现磁盘不足的问题。
<img src="/2021/12/10/install-latest-gcc/2021-12-10-20-38-17.png" alt="2021-12-10-20-38-17"> # 安装 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su root #安装GCC需要root权限，这里先切换为root用户</span><br><span class="line">make install #安装</span><br><span class="line">source /etc/profile #安装完成后手动刷新一下profile</span><br><span class="line">gcc -v #检查当前gcc版本</span><br></pre></td></tr></table></figure>
可以看到，当前的gcc版本更新到了11.2.0，至此安装成功。 <img src="/2021/12/10/install-latest-gcc/2021-12-10-22-35-17.png" alt="2021-12-10-22-35-17"> # 环境变量设置
在安装GCC完成后，可以将其永久地加入到系统路径中，输入以下命令：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su yukeyang #这里yukeyang替换成你的用户名，先从root用户切换回超级用户</span><br><span class="line">cd ~/ #cd进入当前用户(我的是yukeyang)的home目录</span><br><span class="line">code .bashrc #用vscode打开.bashrc文件</span><br></pre></td></tr></table></figure> <img src="/2021/12/10/install-latest-gcc/2021-12-10-22-46-15.png" alt="2021-12-10-22-46-15"> GCC可执行程序所在路径为： <img src="/2021/12/10/install-latest-gcc/2021-12-10-23-24-28.png" alt="2021-12-10-23-24-28"> 因此，将以下两行加入到.bashrc文件中。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/bin:$PATH #设置GCC可执行程序路径</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib64:$LD_LIBRARY_PATH #设置动态链接库路径</span><br></pre></td></tr></table></figure> 至此就完成了所有步骤了，更多的环境变量设置，可以参考<a href="https://www.cnblogs.com/jessepeng/p/11674780.html">这篇博客</a>。
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-26-40.png" alt="2021-12-10-23-26-40"> # 参考文献 1. <a href="https://cloud.tencent.com/developer/article/1532384">centos
编译安装gcc8.1</a> 2. <a href="https://solarianprogrammer.com/2016/10/07/building-gcc-ubuntu-linux/">Building
GCC 10 on Ubuntu Linux</a> 3. <a href="https://blog.csdn.net/21aspnet/article/details/105708122">安装最新的GCC</a>
4. <a href="https://www.cnblogs.com/jessepeng/p/11674780.html">[Linux]
非root安装GCC9.1.0</a></p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>shell if statement</title>
    <url>/2024/01/08/shell-if-statement/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="foreword">Foreword</h1>
<p>This blog article is about the practice in this <a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php">tutorial
blog</a> on bash if statement. <span id="more"></span> # Practice 1 <strong>Issue
description</strong>: Create a Bash script which will take 2 numbers as
command line arguments. It will print to the screen the larger of the
two numbers.</p>
<p>The solution shell script <code>if_test1.sh</code> is as follows.
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -gt $2 ]</span><br><span class="line">then</span><br><span class="line">        echo $1</span><br><span class="line">else</span><br><span class="line">        echo $2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure> # Practice 2 <strong>Issue description</strong>: Create a
Bash script which will accept a file as a command line argument and
analyse it in certain ways. eg. you could check if the file is
executable or writable. You should print a certain message if true and
another if false.</p>
<p>The solution shell script <code>if_test2.sh</code> is as follows.
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ -w $1 ] || [ -x $1 ]</span><br><span class="line">then</span><br><span class="line">        echo the file is writable or executable</span><br><span class="line">else</span><br><span class="line">        echo the file is neither writable nor executable</span><br><span class="line">fi</span><br></pre></td></tr></table></figure> # Practice 3 <strong>Issue description</strong>: Create a
Bash script which will print a message based upon which day of the week
it is (eg. 'Happy hump day' for Wedensday, 'TGIF' for Friday etc).</p>
<p>The solution shell script <code>if_test3.sh</code> is as follows.
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DATE=$( date +%A )</span><br><span class="line"></span><br><span class="line">case $DATE in</span><br><span class="line">        Monday)</span><br><span class="line">                echo first day to work</span><br><span class="line">                ;;</span><br><span class="line">        Tuesday)</span><br><span class="line">                echo still a long way to weekend</span><br><span class="line">                ;;</span><br><span class="line">        Wednesday)</span><br><span class="line">                echo Happy hump day</span><br><span class="line">                ;;</span><br><span class="line">        Thursday)</span><br><span class="line">                echo look forward to weekend</span><br><span class="line">                ;;</span><br><span class="line">        Friday)</span><br><span class="line">                echo TGIF</span><br><span class="line">                ;;</span><br><span class="line">        Saturday)</span><br><span class="line">                echo happy weekend</span><br><span class="line">                ;;</span><br><span class="line">        Sunday)</span><br><span class="line">                echo sunny day</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo unknown day</span><br><span class="line">                ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure> # Reference 1. <a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php">bash
if statement</a></p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04安装LLVM</title>
    <url>/2021/12/04/ubuntu-install-llvm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简介">简介</h1>
<p>在ubuntu20.04上安装LLVM，主要有四种方法。 *
方法一：运行官方的自动安装脚本进行安装 * 方法二：通过包管理器进行安装 *
方法三：使用官方预编译二进制文件进行安装 * 方法四：从源码编译安装
<span id="more"></span>
第一种方法最为简单，只需要一条命令，执行一下脚本，就不要进行任何操作了。第二种方法较第一种要麻烦一点点，但是也比较简单。第三种办法要麻烦点，但是会比较快，简单来说就是直接到网上下载预编译好的binary文件，将其下载到ubuntu20.04系统中，然后解压，再把解压后的所有文件全部拷贝到系统的/usr/local文件夹下，然后就可以使用了。第四种方法最为麻烦，而且很慢，简单来说就是从网上下载LLVM工程的源代码到ubuntu系统，然后在本机上编译，编译完成再安装。</p>
<p>如果只是为了使用LLVM的工具链，个人建议采用方法一或者二和三(我安装的时候使用的是方法三)，简单快捷。如果为了体验一下在本地编译LLVM工程那种更原汁原味的感觉，可以采用方法四，但是这种方法比较麻烦，因为需要安装一些依赖工具，并且在本地编译LLVM耗时严重，整个过程将会相当漫长，所以如果时间预算不是很充足，又或者电脑配置不太好的情况下，我不建议采用方法四。当然，这里四种方法的过程我都会介绍。
# 使用官方安装脚本安装
首先介绍第一种方法，这种方法又有两个选择，第一个是可以选择安装最新版本的，另外一个就是安装某个特定版本。参考下图，来自<a href="https://apt.llvm.org/">官网</a>的介绍。 <img src="/2021/12/04/ubuntu-install-llvm/2021-12-08-23-55-45.png" alt="2021-12-08-23-55-45"> &gt;For convenience there is an automatic
installation script available that installs LLVM for you. To install the
latest stable version: bash -c "$(wget -O -
https://apt.llvm.org/llvm.sh)" &gt; &gt;To install a specific version of
LLVM: wget https://apt.llvm.org/llvm.sh chmod +x llvm.sh sudo ./llvm.sh
<version number> ## 安装最新稳定版LLVM
在ubuntu命令终端执行以下命令，将会运行官网上的llvm.sh这个shell脚本，自动给你安装最新的稳定版本的llvm了。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(wget -O - https://apt.llvm.org/llvm.sh)&quot;</span><br></pre></td></tr></table></figure> ## 安装特定版LLVM
假如我们想用老的版本的话，我们也可以指明某个特定的版本进行安装，在ubuntu命令终端执行以下命令：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh &lt;version number&gt;</span><br></pre></td></tr></table></figure> 其中，&lt;version
number&gt;需要替换成你想安装的那个版本的版本号。例如，假如我们想安装13版本的LLVM时，执行以下命令：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh 13</span><br></pre></td></tr></table></figure> # 使用包管理器安装
使用包管理器安装，我们需要先修改<code>/etc/apt/source.list</code>，参考以下<a href="https://apt.llvm.org/">官方内容</a>，我们需要先在<code>/etc/apt/source.list</code>加入以下内容，
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-15-09.png" alt="2021-12-09-00-15-09"> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">12</span></span><br><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal-12 main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-12 main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">13</span></span><br><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal-13 main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-13 main</span><br></pre></td></tr></table></figure>
加上以上内容后，我们有三种方法可以安装LLVM。 ## 方法一
执行以下shell命令，执行后将会安装LLVM release 13。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LLVM</span></span><br><span class="line">apt install libllvm-13-ocaml-dev libllvm13 llvm-13 llvm-13-dev llvm-13-doc llvm-13-examples llvm-13-runtime</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clang and co</span></span><br><span class="line">apt install clang-13 clang-tools-13 clang-13-doc libclang-common-13-dev libclang-13-dev libclang1-13 clang-format-13 python-clang-13 clangd-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libfuzzer</span></span><br><span class="line">apt install libfuzzer-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lldb</span></span><br><span class="line">apt install lldb-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lld (linker)</span></span><br><span class="line">apt install lld-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libc++</span></span><br><span class="line">apt install libc++-13-dev libc++abi-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenMP</span></span><br><span class="line">apt install libomp-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libclc</span></span><br><span class="line">apt install libclc-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libunwind</span></span><br><span class="line">apt install libunwind-13-dev</span><br></pre></td></tr></table></figure> ##
方法二
参考官网，执行以下shell命令，执行后将会为我们安装最新版本的LLVM（当前版本为version
14） <img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-40-49.png" alt="2021-12-09-00-40-49"> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install clang-format clang-tidy clang-tools clang clangd libc++-dev libc++1 libc++abi-dev libc++abi1 libclang-dev libclang1 liblldb-dev libllvm-ocaml-dev libomp-dev libomp5 lld lldb llvm-dev llvm-runtime llvm python-clang</span><br></pre></td></tr></table></figure> ## 方法三
这种方法是用来安装特定稳定版本的LLVM的，参考官网。 <img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-42-26.png" alt="2021-12-09-00-42-26">
以安装13版本为例，首先我们需要获取文档签名，执行以下shell命令，
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421</span></span><br></pre></td></tr></table></figure>
获取签名后，我们就可以安装LLVM了。假如我们只想安装其中的clang，lld和lldb库(13
release)，我们可以执行以下shell命令， <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install clang-13 lldb-13 lld-13</span><br></pre></td></tr></table></figure>
假如我们想安装所有的关键的库，那就不要执行上述命令，而是执行以下shell命令，
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LLVM</span></span><br><span class="line">apt-get install libllvm-13-ocaml-dev libllvm13 llvm-13 llvm-13-dev llvm-13-doc llvm-13-examples llvm-13-runtime</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clang and co</span></span><br><span class="line">apt-get install clang-13 clang-tools-13 clang-13-doc libclang-common-13-dev libclang-13-dev libclang1-13 clang-format-13 python-clang-13 clangd-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libfuzzer</span></span><br><span class="line">apt-get install libfuzzer-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lldb</span></span><br><span class="line">apt-get install lldb-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lld (linker)</span></span><br><span class="line">apt-get install lld-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libc++</span></span><br><span class="line">apt-get install libc++-13-dev libc++abi-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenMP</span></span><br><span class="line">apt-get install libomp-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libclc</span></span><br><span class="line">apt-get install libclc-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libunwind</span></span><br><span class="line">apt-get install libunwind-13-dev</span><br></pre></td></tr></table></figure> # 使用预编译二进制文件安装 ## 下载文件
接下来介绍方法三，使用预编译二进制文件安装。顾名思义，预编译二进制文件就是说别人已经帮你编译好LLVM工程，生成了二进制文件，你所需的只是将其下载下来，然后放到合适的位置，就可以使用了。从哪里下载LLVM预编译二进制文件呢？这里我提供两个可选的地址。一个是<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-13.0.0">官方Github仓库</a>，LLVM项目组已经将他们的工程放到了这个Github仓库里了，我们只要从里面下载<code>clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</code>(假如你的操作系统是ubuntu20.04版本的话)或者<code>clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-16.04.tar.xz</code>(假如你的操作系统是ubuntu16.04版本的话)，将其下载到ubuntu系统本地即可。由于国内访问Github网速较慢，而我们所下载的压缩文件大小为500MB左右，为了节省时间起见，我个人建议从另一个地址下载，那就是国内的<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/llvm/llvm-project/LatestRelease/">清华镜像源</a>。
## 安装文件
下载好二进制文件到ubuntu系统本地后，我们需要先将文件解压，然后再安装。先解压文件，解压的命令如下。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xz -d clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz #此处你下载的包是clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz，这里是第一步解压</span><br><span class="line">tar -xvf clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz #此处已经是上一步解压完了，文件夹里剩下的是.tar文件</span><br></pre></td></tr></table></figure>
然后再将解压后文件夹下的5个文件夹（bin,include,share,lib,libexec）及里面的所有文件全部复制到/usr/local目录下即可，复制命令如下。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/* /usr/local/ #此处的*代表这个目录下的五个文件都要被复制</span><br></pre></td></tr></table></figure>
也可以一个一个文件夹地复制，命令如下。注意，如果/usr/local/没有对应的文件夹(e.g.
libexec)时，需要先创建该文件夹，然后再复制解压到对应文件夹里面。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/bin/* /usr/local/bin/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/include/* /usr/local/include/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/share/* /usr/local/share/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/lib/* /usr/local/lib/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/libexec/* /usr/local/libexec/ #此处的*代表这个目录下的五个文件都要被复制</span><br></pre></td></tr></table></figure> 完成以上步骤后，我们就可以使用clang了，先测试一下。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang --version</span><br></pre></td></tr></table></figure> <img src="/2021/12/04/ubuntu-install-llvm/2021-12-04-17-16-26.png" alt="2021-12-04-17-16-26">
可以看到，我们已经成功安装clang，版本为13.0.0，接下来就可以愉快地使用了。
## 小结 总结来说，就是执行以下命令, <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不从Github下载，而是从清华镜像源下载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo wget https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span></span><br><span class="line">sudo wget https://mirrors.tuna.tsinghua.edu.cn/github-release/llvm/llvm-project/LatestRelease/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span><br><span class="line">sudo tar xvf clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span><br><span class="line">sudo mv clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04 llvm</span><br><span class="line">export PATH=&quot;$PATH:/usr/local/llvm/bin&quot;</span><br></pre></td></tr></table></figure> # 本地编译安装LLVM ##
前提条件
下面介绍方法四，在安装前，需要先安装以下工具，这些工具会在编译LLVM工程过程中使用到，参考<a href="https://llvm.org/docs/GettingStarted.html">官网</a>说明： <img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-03-12.png" alt="2021-12-10-14-03-12"> * CMake &gt;= 3.13.4 * GCC &gt;= 5.1.0 *
Python &gt;= 3.6 * zlib &gt;= 1.2.3.4 * GNU Make &gt;= 3.79 * Ninja
&gt;= 1.10.0</version></p>
<p>在ubuntu系统上<a href="https://zhuanlan.zhihu.com/p/321882707">安装Ninja</a>和<a href="https://blog.csdn.net/lj402159806/article/details/76408597">安装CMake</a>非常简单，执行以下命令即可，
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build</span><br><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure> ## 下载LLVM源文件
下载LLVM工程源文件到本地，然后在本地编译，再安装。首先我们需要下载LLVM工程源代码，这里我们可以选择从官方Github仓库下载或者是从清华镜像源下载，个人建议从清华镜像源下载，因为这样会快很多。
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/llvm/llvm-project.git #地址一，从官方Github仓库下载</span><br><span class="line">git clone https://mirrors.tuna.tsinghua.edu.cn/git/llvm-project.git #地址二，从清华镜像源下载</span><br></pre></td></tr></table></figure> 下载完成后可以看到llvm-project文件夹了。 <img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-11-04.png" alt="2021-12-10-14-11-04"> ## 配置LLVM
下载完LLVM项目源文件后，下一步就是编译这些源文件了。这里推荐使用Ninja来编译，速度会快很多，当然也可以使用其他编译系统生成工具，比如Unix
Makefiles等。在使用Ninja进行编译之前，我们还需要生成编译过程所需编译文件，这些文件会告诉Ninja如何对LLVM-project进行编译。
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-17-16.png" alt="2021-12-10-14-17-16"> 运行以下shell命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project #cd进入llvm-project文件夹</span><br><span class="line">mkdir build #在llvm-project文件夹创建build文件夹</span><br><span class="line">cd build #cd进入build文件夹</span><br><span class="line">cmake -G Ninja ../llvm #在当前目录(build)生成Ninja编译过程所需的文件，cmake的源文件目录为llvm-project下的llvm文件夹</span><br></pre></td></tr></table></figure>
上面的第四条命令，格式为<code>cmake -G &lt;generator&gt; [options] ../llvm</code>,这里的generator我选择的是Ninja。options则表示可选的选项，常用的有<code>-DLLVM_ENABLE_PROJECTS</code>，表示除了LLVM，你还想编译哪些LLVM子项目。比如，如果除了LLVM外，你还想编译Clang，libcxx和libcxxabi，那么你可以使用编译选项<code>-DLLVM_ENABLE_PROJECTS="clang" -DLLVM_ENABLE_RUNTIMES="libcxx;libcxxabi"</code>，上述的第四条命令就是：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; ../llvm </span><br></pre></td></tr></table></figure>
也可以不运行上面的shell命令，而是运行下面的shell命令（参考<a href="https://github.com/llvm/llvm-project">官网指导</a>）：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project #cd进入llvm-project文件夹</span><br><span class="line">mkdir build #在llvm-project文件夹创建build文件夹</span><br><span class="line">cmake -S llvm -B build -G Ninja #对llvm文件夹下的源文件进行cmake，生成的文件放在build目录下，生成的文件将在Ninja编译过程使用</span><br></pre></td></tr></table></figure>
上面的第三条命令，格式为<code>cmake -S llvm -B build -G &lt;generator&gt; [options]</code>,-S表示cmake的源文件所在文件夹，这里是llvm。-B表示cmake后生成的文件所在的文件夹，这里是build文件夹。-G表示将要使用这些生成的cmake文件来编译的工具，这里是Ninja。如果不清楚这些cmake短选项的含义的话，可以<code>cmake -help</code>查看一下帮助。后面的<code>[options]</code>则表示其它的cmake选项，常用的有<code>-DLLVM_ENABLE_PROJECTS='...'</code>，具体含义如前所述。假如我们除了llvm子项目以外，还想编译其它的子项目，比如Clang，libcxx，libcxxabi，那我们可以使用<code>-DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi"</code>选项，上面第三条shell命令就是:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</span><br></pre></td></tr></table></figure> <img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-45-31.png" alt="2021-12-10-14-45-31">
cmake完成后可以看到编译文件已被写到build文件夹下。 <img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-15-01-48.png" alt="2021-12-10-15-01-48"> ## 编译LLVM
生成Ninja编译LLVM所需的文件后，下一步就是编译llvm了，参考<a href="https://github.com/llvm/llvm-project">官网</a>，输入以下命令：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
上述命令的格式为<code>cmake --build build [-- [options] &lt;target&gt;]</code>，--build指明编译后文件写入的文件夹，这里是build文件夹。--target选项指明所使用的编译工具，假如安装了Ninja的话，默认的target是Ninja。也可以输入以下命令，显式地调用Ninja:
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">ninja -j 8</span><br></pre></td></tr></table></figure> <img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-12-39-32.png" alt="2021-12-11-12-39-32">
在编译到第3257个文件的时候，可能会发生如下错误： <img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-19-07-48.png" alt="2021-12-10-19-07-48">
原因是因为我的GCC版本太低了，还是9.3.0版本。根据<a href="https://reviews.llvm.org/rGac7031b2b2fa">网上的说法</a>，升级到11.2.0版（也是当前的最新版）就可以解决这个问题了，因此，需要<a href="https://yang-yuke.github.io/2021/12/10/install-latest-gcc/">升级GCC到最新版</a>。
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-19-05-59.png" alt="2021-12-10-19-05-59"> 在升级到最新版GCC后，再重复上面的编译命令：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</span><br><span class="line">cd build</span><br><span class="line">ninja -j 8</span><br></pre></td></tr></table></figure> 依然出现了大量以下错误， <img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-24-36.png" alt="2021-12-11-16-24-36">
这些错误是在编译libcxxabi库的cpp文件时出现的，说明有可能是我们在cmake配置编译的时候出了问题，回到<a href="https://llvm.org/docs/GettingStarted.html">LLVM官网Get
started页面</a>，发现与<a href="https://github.com/llvm/llvm-project">LLVM Github Get
started</a>上对<code>DLLVM_ENABLE_PROJECTS</code>编译选项的细节描述有点出入，<code>"libcxx;libcxxabi"</code>应该要放到<code>DLLVM_ENABLE_RUNTIMES</code>编译选项里，而不是<code>DLLVM_ENABLE_PROJECTS</code>里面。
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-29-07.png" alt="2021-12-11-16-29-07"> 于是，重新进行cmake配置和编译，命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot;</span><br><span class="line">cd build</span><br><span class="line">ninja -j8</span><br></pre></td></tr></table></figure>
此时，发现能够继续往下编译了，但是每编译十几个cpp文件后就会出现以下错误“fatal
error: ld terminated with signal 9 [Killed]”，然后就停止了。 <img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-32-11.png" alt="2021-12-11-16-32-11"> 查了一下，<a href="https://stackoverflow.com/questions/65633304/not-able-to-build-llvm-from-its-source-code">这里</a>提到有可能是因为内存不足所致的，于是重新配置并编译，命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; -DLLVM_PARALLEL_LINK_JOBS=1</span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure> <img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-38-00.png" alt="2021-12-11-18-38-00"> <img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-38-29.png" alt="2021-12-11-18-38-29">
上述命令中，<code>-DCMAKE_BUILD_TYPE=Release</code>表示编译的版本是release版本，release版本要小很多，如果不指明的话编译的就是debug版本。<code>-DLLVM_PARALLEL_LINK_JOBS=1</code>表示不开parallel
build。等待一段时间后，可以看到这一次可以完全编译所有的文件了。 <img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-42-53.png" alt="2021-12-11-18-42-53">
编译完成后，需要切换到root用户进行安装，命令如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build #cd进入llvm-project/build文件夹</span><br><span class="line">sudo su root #切换到root用户权限</span><br><span class="line">ninja install #安装llvm</span><br></pre></td></tr></table></figure>
安装完成后，可以看到clang已被安装到<code>/usr/local/bin</code>路径下，说明安装已经成功。
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-13-22-17-01.png" alt="2021-12-13-22-17-01"> # 参考文献 1. <a href="https://blog.csdn.net/zerolord/article/details/116891720">Ubuntu20.04安装llvm</a>
2. <a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-project.git/">LLVM
Git 源码仓库镜像使用帮助</a> 3. <a href="https://zhuanlan.zhihu.com/p/102028114">LLVM概述——介绍与安装</a>
4. <a href="https://apt.llvm.org/">LLVM Debian/Ubuntu nightly
packages</a> 5. <a href="https://zhuanlan.zhihu.com/p/321882707">Ninja安装和基本使用</a> 6.
<a href="https://blog.csdn.net/lj402159806/article/details/76408597">ubuntu安装CMake的几种方式</a>
7. <a href="https://llvm.org/docs/GettingStarted.html">Getting Started
with the LLVM System</a> 8. <a href="https://github.com/llvm/llvm-project">Getting Started with the
LLVM System(github)</a> 9. <a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch01.html">第1章
编译和安装LLVM</a></p>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>Attach date to filename</title>
    <url>/2024/01/06/shell_attach_date_to_filename/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="foreword">Foreword</h1>
<p>Recently I was reading a <a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php">tutorial
blog</a> on bash variables, in which there are some challenging
questions at the end. It took me some time to work it out, so I thought
it would be worthy for me to write something to take that down.
<span id="more"></span> # Practice 1 <strong>Issue description</strong>: Create a
script which will take a filename as its first argument and create a
dated copy of the file. eg. if our file was named file1.txt it would
create a copy such as 2024-01-05_file1.txt. (To achieve this you will
probably want to play with command substitution and the command
date)</p>
<p>The solution shell script <code>date_test.sh</code> is as follows.
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DATE=$( date -I )</span><br><span class="line">COPYNAME=$&#123;DATE&#125;_$&#123;1&#125;</span><br><span class="line">echo &quot; copy name is $COPYNAME&quot;</span><br><span class="line">echo &quot; copy file $1 to $COPYNAME &quot;</span><br><span class="line">cp $1 $COPYNAME</span><br></pre></td></tr></table></figure></p>
<p>Run the command <code>./date_test.sh mysampledata.txt</code> in the
terminal, the result will be as follows: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yukeyang@DESKTOP-QFK2F47:~/myfiles/bash_tutorials$ ./date_test.sh mysampledata.txt</span><br><span class="line"> copy name is 2024-01-06_mysampledata.txt</span><br><span class="line"> copy file mysampledata.txt to 2024-01-06_mysampledata.txt</span><br><span class="line">yukeyang@DESKTOP-QFK2F47:~/myfiles/bash_tutorials$</span><br></pre></td></tr></table></figure></p>
<p>We will see a new file named <code>2024-01-06_mysampledata.txt</code>
is created in the current working directory.</p>
<p>Now, let's take a look at the shell script. The -I option for date
means we output the date in YY-MM-DD format. # Practice 2 <strong>Issue
description</strong>: Based on practice 1, the date is after the name of
the file (eg. file1_2024-01-05.txt (The command basename can be useful
here.)</p>
<p>The solution shell script <code>date_test2.sh</code> is as follows.
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DATE=$(date -I)</span><br><span class="line">filename=$(echo $&#123;1&#125; | cut -d . -f1)</span><br><span class="line">extension=$(echo $&#123;1&#125; | cut -d . -f2)</span><br><span class="line">COPYNAME=$&#123;filename&#125;_$&#123;DATE&#125;.$&#123;extension&#125;</span><br><span class="line">echo &quot;filename is $filename, extension is $extension&quot;</span><br><span class="line">echo &quot;copy name is $COPYNAME&quot;</span><br><span class="line">echo &quot;copy file $1 to $COPYNAME&quot;</span><br><span class="line">cp $1 $COPYNAME</span><br></pre></td></tr></table></figure></p>
<p>Run the command <code>./date_test2.sh mysampledata.txt</code> in the
terminal, the result will be as follows: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yukeyang@DESKTOP-QFK2F47:~/myfiles/bash_tutorials$ ./date_test2.sh mysampledata.txt</span><br><span class="line">filename is mysampledata, extension is txt</span><br><span class="line">copy name is mysampledata_2024-01-06.txt</span><br><span class="line">copy file mysampledata.txt to mysampledata_2024-01-06.txt</span><br></pre></td></tr></table></figure></p>
<p>Alternatively, we can have the below script as the solution, which
uses the sed command. <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DATE=$(date -I)</span><br><span class="line">filename=$(echo $&#123;1&#125; | sed &#x27;s/\.[^.]*$//&#x27;)</span><br><span class="line">extension=$(echo $&#123;1&#125; | sed &#x27;s/^.*\.//&#x27;)</span><br><span class="line">COPYNAME=$&#123;filename&#125;_$&#123;DATE&#125;.$&#123;extension&#125;</span><br><span class="line">echo &quot;filename is $filename, extension is $extension&quot;</span><br><span class="line">echo &quot;copy name is $COPYNAME&quot;</span><br><span class="line">echo &quot;copy file $1 to $COPYNAME&quot;</span><br><span class="line">cp $1 $COPYNAME</span><br></pre></td></tr></table></figure></p>
<h1 id="practice-3">Practice 3</h1>
<p><strong>Issue description</strong>: Expand the previous question to
accept a list of files on the command line and it will create a named
copy of all of them. (The command xargs may be useful here.)</p>
<p>The solution shell script <code>xarg_date_test.sh</code> is as
follows. <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DATE=$(date -I)</span><br><span class="line">ls $* | xargs -n1 -i basename &#123;&#125; | xargs -n1 -i cp &#123;&#125; $&#123;DATE&#125;_&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run the command
<code>./xarg_date_test.sh mysampledata.txt myoutput.txt</code> in the
terminal, the result will be as follows: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yukeyang@DESKTOP-QFK2F47:~/myfiles/bash_tutorials$ ./xarg_date_test.sh mysampledata.txt myoutput.txt</span><br><span class="line">yukeyang@DESKTOP-QFK2F47:~/myfiles/bash_tutorials$ ls</span><br><span class="line">20231231                     image1.JPG  myoutput.txt                 results.data        words.txt</span><br><span class="line">2024-01-06_myoutput.txt      image2.JPG  mysampledata_2024-01-04.txt  script1.sh          xarg_date_test1.sh</span><br><span class="line">2024-01-06_mysampledata.txt  image3.JPG  mysampledata_2024-01-05.txt  script2.sh          xarg_date_test.sh</span><br><span class="line">date_test2.sh                image4.JPG  mysampledata_2024-01-06.txt  script.sh</span><br><span class="line">date_test.sh                 mycopy.sh   mysampledata.txt             shellname_test.sh</span><br><span class="line">file1.data                   myoutput    pipe_test.sh                 simplevariables.sh</span><br><span class="line">yukeyang@DESKTOP-QFK2F47:~/myfiles/bash_tutorials$</span><br></pre></td></tr></table></figure> We can the dated
copy of the argument files. Now let's take a look at the script. The
<code>$*</code> means all the command line arguments. The
<code>-n1</code> xarg option means run the command on each input once.
The <code>-i</code> indicates we are going to use a replacement string
in the next command (it defaults to {}). This means, execute the next
command, substituting every occurrence of {} with what was just read
through the pipe.</p>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php">bash
variables</a></li>
<li><a href="https://zuyunfei.com/2016/03/23/Shell-Truncate-File-Extension/">Shell
truncate file extension</a></li>
<li><a href="https://ryanstutorials.net/linuxtutorial/grep.php">grep</a></li>
<li><a href="https://www.runoob.com/linux/linux-comm-sed.html">Linux sed
command</a></li>
</ol>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>bash</tag>
        <tag>variables</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币区块结构</title>
    <url>/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言">前言</h1>
<p>比特币账本是以区块链的形式组织起来的，每个区块以<code>merkle tree</code>的形式记录着多条交易的具体信息，
而区块与区块间则通过哈希指针链接起来，从而实现了对所有历史交易的记录。本文将对比特币区块的所有相关概念进行简介。
<span id="more"></span> --- <code>以下是本篇文章正文内容</code> # 哈希指针
前面提到，比特币区块与区块间是通过哈希指针链接起来的，那么，哈希指针是什么呢？这里介绍一下这个概念。<code>哈希指针(Hash pointer)</code>，顾名思义，是一个带有哈希值的指针。其结构如下图所示，该指针不仅记录了其所指向的数据块的地址，同时也记录了该数据块的哈希值。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-09-48.png#pic_center" alt="2022-06-17-18-09-48"> # 区块链
比特币的账本(<code>ledger</code>)是以区块链(<code>block chain</code>)的形式组织起来的，其结构如下图所示。每个区块里包含了一个字段<code>previousblockhash</code>，记录着上一个区块的哈希值。每往区块链里添加一个新的区块时，需要计算上一个区块的哈希值并填入新加的区块的<code>previousblockhash</code>字段中。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-10-34.png#pic_center" alt="2022-06-17-18-10-34">
区块链的这种特殊的结构形式，使得它具有防篡改的属性。那么，区块链是如何体现出其防篡改属性的呢？以下图为例，假如有人恶意篡改了区块1的内容，那么为了保持一致，他必然要对篡改后的区块1的内容重新进行哈希运算，然后将所得到的哈希值填入区块2的<code>previousblockhash</code>字段，而因为区块2的<code>previousblockhash</code>字段改变了，他又不得不对区块2重新进行哈希运算并将得到的哈希值填入区块3的<code>previousblockhash</code>字段
。最终，他将不得不修改区块链链首的哈希指针。只要我们记录了这个指针，那么他将无法篡改这个指针的信息。结果就是，如果我们对最后一个区块(在下面的例子中是区块3)求哈希，那么结果一定和我们所保存的链首哈希指针不一致，从而就可以识别出区块链内容有被人篡改过。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-11-12.png#pic_center" alt="2022-06-17-18-11-12"> # Merkle tree
每个比特币区块中记录了多条交易信息，这些交易是以<code>merkle tree</code>的形式组织起来的，如下图所示。首先会对每条交易求哈希，然后对得到的哈希两两配对，再求哈希，然后再将所求得的哈希两两配对，最终，将会得到一个哈希值，这个哈希值就是<code>merkleroot</code>。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-11-52.png#pic_center" alt="2022-06-17-18-11-52">
以<code>merkle tree</code>的形式将区块内的所有交易组织起来，主要有两个好处。</p>
<ol type="1">
<li>防篡改(tamper evident)</li>
<li>验证身份(proof of membership)</li>
</ol>
<h2 id="防篡改">防篡改</h2>
<p>与前面区块链防篡改的机制类似，只要我们记住了<code>merkle tree</code>的根节点的哈希值<code>merkleroot</code>，我们就能防止篡改。具体过程如下，以下图为例，假如有人恶意篡改了交易1的信息，那么为了保持信息一致，他必须沿着交易1所在的分支一直往上，重新计算所有的哈希值，直到根节点。但是，因为我们在本地保存了<code>merkleroot</code>的值，所以攻击者在篡改根节点的其中一个哈希值后，他无法再进一步篡改<code>merkleroot</code>的值了，而我们验证时，只要计算一下根节点的哈希值，然后与本地保存的<code>merkleroot</code>比较一下，就能检测出这个区块的交易信息有被篡改过。所以，在区块链的基础之上，<code>merkle tree</code>进一步加强了防篡改的能力。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-12-44.png#pic_center" alt="2022-06-17-18-12-44"> ## 验证身份
<code>merkle tree</code>的另一大优点是通过它可以很轻易地验证一条交易是否属于这个区块。以下图为例，假如某人想证明交易1属于这个区块。与前面一样，我们只需要记住<code>merkleroot</code>。当某人要证明交易1属于这个区块时，他需要给出一条分支，该分支的根节点的哈希值要等于我们所保存的<code>merkleroot</code>，叶子节点则是要证明的交易，下图里是交易1。我们只要沿着这条分支，对路径上所有的哈希值验算一遍，如果得到的所有哈希值都与分支上各个节点所记录的哈希值一致，那么就证明了交易1属于该区块。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-13-16.png#pic_center" alt="2022-06-17-18-13-16">
从上面的例子可以看出，利用<code>merkle tree</code>可以很容易地验证交易1属于这个区块。反过来，要是一个交易不属于该区块，那么也很容易证明。以下图为例，假如某人想将不属于该区块的交易x伪装成属于该区块，那么他必须将这个伪交易插入到<code>merkle tree</code>的某个位置。假如他插入的是交易2的位置，那么在证明交易x属于这个区块时，我们可以要求他出示交易x在<code>merkle tree</code>上的前一个交易和后一个交易以及其所在的分支
。于是，他需要给出下图所示的几个分支，为了保持信息一致，他不得不沿着原来交易2所在的分支，对所有的哈希重新算一遍并进行篡改，而由于我们记住了<code>merkleroot</code>，他无法篡改这个值，所以只要我们对根节点的哈希进行验算，就会发现得到的哈希值与我们保存的<code>merkleroot</code>不一致，从而证明了交易x并不属于这个<code>merkle tree</code>，即不属于这个区块。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-13-48.png#pic_center" alt="2022-06-17-18-13-48"> # 比特币区块链
比特币区块链结构图如下图所示，由图可以看出各个区块之间以<code>哈希指针</code>链接起来，区块内部各个交易则以<code>merkle tree</code>的形式组织起来。每个区块都记录两个哈希指针，一个是<code>previousblockhash</code>，指向上一个区块，记录着上一个区块的哈希值，另一个是<code>merkle root</code>，指向其所在区块的<code>merkle tree</code>的根节点，记录着该节点的哈希值。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-14-33.png#pic_center" alt="2022-06-17-18-14-33"> # 比特币区块
比特币区块的结构如图所示，区块由两部分组成，一部分是<code>区块头</code>，记录着区块的一些关键的特征信息，受限于页面大小，下面图中只展示出一部分，后面会介绍不在图上的其它项。另一部分是<code>交易列表</code>，记录着该区块里每条交易的哈希值，这里的划分只是一种概念上的划分，实际上区块的数据结构中不会专门用两个不同数据结构来分别存放<code>区块头</code>和<code>交易列表</code>，而是会把它们统一记录在一个数据结构中。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-15-13.png#pic_center" alt="2022-06-17-18-15-13"> 比特币区块各字段如下表所示。</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>当前区块Hash</td>
</tr>
<tr>
<td>confirmations</td>
<td>区块链网络确认数</td>
</tr>
<tr>
<td>size</td>
<td>区块大小</td>
</tr>
<tr>
<td>height</td>
<td>区块高度</td>
</tr>
<tr>
<td>version</td>
<td>区块版本</td>
</tr>
<tr>
<td>versionHex</td>
<td>区块版本的16进制表示</td>
</tr>
<tr>
<td>merkleroot</td>
<td>区块中所有交易的merkle根Hash</td>
</tr>
<tr>
<td>tx</td>
<td>交易列表</td>
</tr>
<tr>
<td>time</td>
<td>区块的时间戳</td>
</tr>
<tr>
<td>mediantime</td>
<td>过去11个区块的中值时间</td>
</tr>
<tr>
<td>nonce</td>
<td>32位的任意随机数，挖矿时用于工作量证明算法的一个扰动输入参数</td>
</tr>
<tr>
<td>bits</td>
<td>区块的难度目标</td>
</tr>
<tr>
<td>chainwork</td>
<td>区块链上的总计工作量，它是一个32位的整数，代表了区块链上所有区块的计算工作量</td>
</tr>
<tr>
<td>previousblockhash</td>
<td>前一个区块的Hash值</td>
</tr>
<tr>
<td>nextblockhash</td>
<td>下一个区块的Hash值</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="获取区块数据">获取区块数据</h1>
<p>前面介绍了比特币区块的结构以及里面的各个字段，下面介绍在实际网络中如何获取一个真实存在的区块的数据。目前网络上有多个区块链浏览器，这些区块链浏览器不光能查询区块的内容，还能实时地监测网上正在进行的交易，一个比较常用的在线区块链查询网站是<a href="https://www.blockchain.com/explorer">https://www.blockchain.com/explorer</a>。</p>
<p>点击进入该网址，在Assets-&gt;Bitcoin页面，可以看到最新加入到区块链中的区块(Latest
Blocks)，以及最新的交易情况(Latest
Transactions)。滚动到该页面的最下方，点击进入Resources-&gt;APIs页面。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-15-51.png#pic_center" alt="2022-06-17-18-15-51"> <img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-16-12.png#pic_center" alt="2022-06-17-18-16-12">
在Resources-&gt;APIs页面，可以看到这个网站提供了很多不同的API和查询功能，点击查看Blockchain
Data
API的Documentation，这个Documentation就是关于如何查询区块数据的说明书。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-16-54.png#pic_center" alt="2022-06-17-18-16-54">
在里面可以看到，我们既可以查询某个区块的内容，也可以查询某个交易的内容，要查询区块内容，只需要在浏览器输入<code>https://blockchain.info/rawblock/$block_hash</code>格式的URL然后跳转即可，其中<code>$block_hash</code>是该区块的哈希值。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-17-11.png#pic_center" alt="2022-06-17-18-17-11"> 点击查看前面的Assets-&gt;Bitcoin-&gt;Latest
Blocks页面，查看最新的区块，作为例子，从其中选一个比较小的区块，如下图的Block
740337，查看该区块的内容，可以看到，其哈希值为==000000000000000000055092e5f54d01ea178a879cef5f331f4b974172cccefe==，则查询该区块内容的URL为<a href="https://blockchain.info/rawblock/000000000000000000055092e5f54d01ea178a879cef5f331f4b974172cccefe">https://blockchain.info/rawblock/000000000000000000055092e5f54d01ea178a879cef5f331f4b974172cccefe</a>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-17-27.png#pic_center" alt="2022-06-17-18-17-27">
转到上面的URL后，我们看到的JSON格式的网页内容是乱序的，需要进行排序以便观察。将其内容复制到<a href="https://www.bejson.com/json/format/">https://www.bejson.com/json/format/)</a>这个网址，格式化校验之后，点击保存校验数据，然后即可看到格式化后的JSON文件内容，如下图所示。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-17-45.png#pic_center" alt="2022-06-17-18-17-45"> 上面的JSON文件可以到以下<a href="https://gitee.com/yuke-yang/bitcoin">地址</a>中下载，文件名为<font color="SteelBlue">Block
740370.json</font>。 # coinbase交易
每个区块的第一条交易是<code>coinbase交易</code>。<code>coinbase交易</code>会生成新的比特币，要生成新的比特币，只能通过<code>coinbase交易</code>。与普通的交易相比，<code>coinbase交易</code>有如下的几个特点：</p>
<ul>
<li>只有一个输入和一个输出</li>
<li>因为coinbase交易只是铸造新的比特币，而不花费任何现有的比特币，因此其输入并不赎回任何的之前的输出，这样，输入的prev_out字段就会包含一个空的哈希指针</li>
<li>当前的输出值比6BTC要稍大。输出值就是矿工从这个区块所获得的回报(reward)。reward由两部分组成，一部分是固定的挖矿奖励(block
reward)，目前的值为6.25BTC，在某一段时间内，不管哪个矿工挖到一个新的区块，其所得到的block
reward基本都是固定的，这部分收益在不同的区块间不会有差别，但是值得注意的是，每挖到210000个新的区块后(大约4年)，这个值就会减半；另一部分就是矿工从区块中的所有交易所收取的交易费(fee
reward)，这部分收益在不同的区块之间就会有所不同，取决于区块中所包含的交易的数目以及每条交易所收取的交易费。</li>
</ul>
<p>以上面的JSON文件为例，摘取其交易列表的第一条交易(即<code>coinbase交易</code>)出来，从下面可以看到，这个区块的<code>coinbase交易</code>新造了6.25150003枚比特币，其中block
reward为6.25150003BTC，fee reward为0。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tx&quot;</span>: [&#123;</span><br><span class="line">    <span class="string">&quot;hash&quot;</span>: <span class="string">&quot;f58dc5d553b86f47fb901757e3be85b2b08f3f36317fc1e690fb2ca7cbe37156&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ver&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;vin_sz&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;vout_sz&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;size&quot;</span>: <span class="number">217</span>,</span><br><span class="line">    <span class="string">&quot;weight&quot;</span>: <span class="number">760</span>,</span><br><span class="line">    <span class="string">&quot;fee&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;relayed_by&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lock_time&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">    <span class="string">&quot;double_spend&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;time&quot;</span>: <span class="number">1654947331</span>,</span><br><span class="line">    <span class="string">&quot;block_index&quot;</span>: <span class="number">740337</span>,</span><br><span class="line">    <span class="string">&quot;block_height&quot;</span>: <span class="number">740337</span>,</span><br><span class="line">    <span class="string">&quot;inputs&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;sequence&quot;</span>: <span class="number">4294967295</span>,</span><br><span class="line">        <span class="string">&quot;witness&quot;</span>: <span class="string">&quot;01200000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;script&quot;</span>: <span class="string">&quot;03f14b0b04037ea4622f466f756e6472792055534120506f6f6c202364726f70676f6c642f0c027cef00003c1706000000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;prev_out&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;tx_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;n&quot;</span>: <span class="number">4294967295</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;spent&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;script&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;spending_outpoints&quot;</span>: [&#123;</span><br><span class="line">                <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">                <span class="string">&quot;n&quot;</span>: <span class="number">0</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;out&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;spent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="number">625150003</span>,</span><br><span class="line">        <span class="string">&quot;spending_outpoints&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;n&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">        <span class="string">&quot;script&quot;</span>: <span class="string">&quot;76a9145e9b23809261178723055968d134a947f47e799f88ac&quot;</span>,</span><br><span class="line">        <span class="string">&quot;addr&quot;</span>: <span class="string">&quot;19dENFt4wVwos6xtgwStA6n8bbA57WCS58&quot;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;spent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;spending_outpoints&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;n&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">        <span class="string">&quot;script&quot;</span>: <span class="string">&quot;6a24aa21a9edeb61edfb90d450a17115e960c6e6b216442b28c0ff48a9e390dfa2a767e80ec0&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, </span><br></pre></td></tr></table></figure>
该<code>coinbase交易</code>的细节可以到<a href="https://www.blockchain.com/btc/tx/f58dc5d553b86f47fb901757e3be85b2b08f3f36317fc1e690fb2ca7cbe37156">https://www.blockchain.com/btc/tx/f58dc5d553b86f47fb901757e3be85b2b08f3f36317fc1e690fb2ca7cbe37156</a>查看，如下图所示。这个URL的最后一部分是该交易的哈希，假如我们要查询其它交易的细节，将其它交易的哈希替换这个URL的最后一部分(该交易的哈希)即可。
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-18-35.png#pic_center" alt="2022-06-17-18-18-35"> 下图又是另外一个例子<a href="https://www.blockchain.com/btc/block/000000000000000000032e39bbd3a6af9b311982a256acf1dab5518b2eb79c9a">https://www.blockchain.com/btc/block/000000000000000000032e39bbd3a6af9b311982a256acf1dab5518b2eb79c9a</a>，从图中可以看出，Block
Reward是6.25000000BTC，而Fee
Reward是0.00080987，因此挖得此区块的总的收益(revenue)是6.25150003。 <img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-19-04.png#pic_center" alt="2022-06-17-18-19-04"> # 总结
本文介绍了与比特币区块链有关的数据结构以及相关概念，包括<code>哈希指针</code>，<code>merkle tree</code>，<code>比特币区块链</code>，<code>比特币区块</code>，介绍了它们所具有的一些属性，它们是比特币网络的基本部件(building
block)，要理解比特币网络，首先必须要正确理解这些概念。</p>
<h1 id="参考文献">参考文献</h1>
<p>[1] <a href="http://www.woshipm.com/blockchain/1022259.html">通俗易懂揭秘比特币区块的内部结构</a>
[2] <a href="https://segmentfault.com/a/1190000017055507">Bitcoin
区块和交易数据结构</a> [3] <a href="https://zhuanlan.zhihu.com/p/42584683">bitcoin区块结构分析</a> [4]
<a href="https://www.liaoxuefeng.com/wiki/1207298049439968/1207297665661664#:~:text=%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%8C%BA%E5%9D%97,%E5%B9%B6%E4%BA%A7%E7%94%9F%E6%96%B0%E7%9A%84UTXO%E3%80%82">区块结构</a>
[5] <a href="https://blog.csdn.net/u013137970/article/details/69891985">比特币区块结构解析</a>
[6] <font color="CornflowerBlue">Bitcoin and Cryptocurrency Technologies
</font>by Arvind Narayanan, Joseph Bonneau etl. Section 3.4</p>
]]></content>
      <categories>
        <category>比特币</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>多重签名</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币多重签名</title>
    <url>/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概述">概述</h1>
<p>在“<a href="https://blog.csdn.net/zengaliang/article/details/125133213?spm=1001.2014.3001.5501">浅析比特币脚本</a>”一文中，曾经提到过比特币脚本的一个应用是多重签名(Multi-Signature)。顾名思义，多重签名(以下简称多签)是指一笔交易需要多个私钥签名才能被执行。</p>
<p>在大多数情况下，交易都是一对一进行的，买家向卖家给出的地址(即卖家的公钥哈希)支付比特币，卖家要使用该比特币的时候提供自己的数字签名并验证自己的数字签名有效即可。但也会有这样一类场景：一个钱包被多个人共同持有。比如，某公司有5个合伙人，公司钱包相应就有5个私钥，每个合伙人持有其中1个私钥。为了防止其中某一个合伙人想中饱私囊或者肆意挥霍，必须有5个人中的3人同时签名才可以把钱包中的币取走，这类情况就需要使用“多重签名”。
<span id="more"></span>
在比特币中，多签的含义是：一个钱包如果有m个私钥，交易的时候，需要其中n(1≤n≤m)
个私钥的签名，交易才能被执行。对应到现实里，可以想象为这样一个场景：m个人共同管理一笔资金(比特币)，他们各自持有一把私钥，要花费这笔资金需要取得其中至少n个人的同意(签名)
才能进行。对应到这个场景的话，m就是5，n就是3。</p>
<p>使用多签有这些优点： - 一个钱包可以由多人共同管理 -
避免单点故障，防止某一个私钥被盗影响整个钱包 -
多个私钥可以起备份作用，防止单一私钥在丢失的情况下导致大量属于该私钥持有者的资金损失</p>
<p>多签主要有两种实现方式：</p>
<ul>
<li>CHECKMULTISIG实现多签</li>
<li>P2SH实现多签</li>
</ul>
<p>下面将对这两种实现方式进行介绍。 # CHECKMULTISIG实现多签
用CHECKMULTISIG实现多签，输出脚本(也叫锁定脚本)的形式如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_1)</span></span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_2)</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_m)</span></span><br><span class="line">m</span><br><span class="line">OP_CHECKMULTSIG</span><br></pre></td></tr></table></figure>
如果输出脚本是这种形式的话，这笔交易就是一笔<strong>付款到多重签名</strong>(P2MS，Pay
to Multi
Signature)的交易，也常用multisig表示。其中m表示一共有m个人，每个人各自有一把公钥，共有m把公钥，这笔钱将会付给这m个人，由他们共同持有；n表示需要当这m个人想要使用这笔钱的时候，需要其中n个人的数字签名(即获得n个人的同意)才能使用这笔钱。</p>
<p>解锁UTXO(可理解为输出脚本所支付的比特币的ID)时，需要提供输入脚本(也叫解锁脚本)，其形式如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br></pre></td></tr></table></figure>
可以理解为需要n个签名(即获得n个人的同意)才能使用这笔钱。在需要使用这笔钱的时候，n个人提供输入脚本，将输入脚本与输出脚本拼接到一起，得到完整的执行脚本，然后执行该脚本。拼接后的脚本形式如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br><span class="line">n</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_1)</span></span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_2)</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_m)</span></span><br><span class="line">m</span><br><span class="line">OP_CHECKMULTSIG</span><br></pre></td></tr></table></figure> 其执行过程如图： <img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/2022-06-17-18-00-06.png#pic_center" alt="2022-06-17-18-00-06">
可见，OP_CHECKMULTISIG一条语句就能完成整个多签的验证。</p>
<p>但是这种验证方式也有不足，它需要付款人（输出脚本）提供所有收款人的公钥。换句话说，要给有5个合伙人的公司打款，需要付款人先去获得每个合伙人的公钥，这样很不方便。</p>
<p>如果5个合伙人能提供单一的收款地址，不需要付款人把他们的公钥一一列出来，那样是最简便的，而这可以通过P2SH来实现。
# P2SH实现单签 P2SH(Pay to Script Hash)是除P2K(Pay to public
key)、P2KH(Pay to public key
hash)之外的另一种付款方式。在P2SH的输入脚本中需要提供一个被称为RedeemScript的脚本，在P2SH的输出脚本则需要提供RedeemScript的哈希。在讨论P2SH实现多签之前，先讨论P2SH实现单签这种简单的情况。</p>
<p>P2SH的输出脚本格式如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure> 输入脚本格式如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br></pre></td></tr></table></figure> 拼接后的脚本如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure>
使用P2SH方式付款时，收款人只需要向付款人提供一个地址，付款人往这个地址支付比特币即可，这个地址就是收款人的Redeem
Script的哈希；当收款人要花这笔钱的时候，需要提供相应的Redeem
Script，以及收款人的数字签名。如果Redeem
Script执行后，栈顶等于TRUE，那么表示整个付款的验证通过。</p>
<p>执行拼接后的脚本，执行过程如下图所示： <img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/2022-06-17-18-01-00.png#pic_center" alt="2022-06-17-18-01-00">
在上图中，如果<strong>OP_EQUALVERIFY</strong>执行结果为TRUE，那么接下来会执行redeemScript，而redeemScript是收款人自定义的，我们也可以通过它来实现多签。
# P2SH实现多签 使用P2SH的支付方式，可以通过Redeem Script来实现多签。</p>
<p>P2SH实现多签时的输出脚本格式如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure>
可以看到，P2SH的输出脚本格式在实现多签和单签时是一样的。</p>
<p>输入脚本格式如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br></pre></td></tr></table></figure>
可以看到，在实现多签时，输入脚本与单签时的格式略微有所不同，此时需要提供的数字签名不再只有一个，而是多个。</p>
<p>拼接后的脚本如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure>
执行拼接后的脚本，如果<strong>OP_EQUALVERIFY</strong>等于TRUE，将开始执行redeemScript，redeemScript的格式如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_1)</span></span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_2)</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_m)</span></span><br><span class="line">m</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
此时，执行redeemScript的过程将和前面"CHECKMULTISIG实现多签"一节的过程一样。</p>
<p>以上就是通过redeemScript来实现多签的过程，整个过程如下图所示。 <img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/2022-06-17-18-01-54.png#pic_center" alt="2022-06-17-18-01-54"> # 参考文献 [1] <a href="https://qianniu.fun/2022/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%AD%BE%E7%9A%84%EF%BC%9F/">比特币脚本是如何实现多签的？</a>
[2] <a href="https://zhuanlan.zhihu.com/p/53652207">“付款到多重签名” 和
“付款到脚本哈希”</a> [3] <a href="https://www.liaoxuefeng.com/wiki/1207298049439968/1207315329092960">多重签名</a>
[4] <a href="https://bitcoinbook.cs.princeton.edu/">Bitcoin and
Cryptocurrency Technologies</a> by Arvind Narayanan, Joseph Bonneau etl.
Section 3.2</p>
]]></content>
      <categories>
        <category>比特币</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>多重签名</tag>
      </tags>
  </entry>
  <entry>
    <title>双口RAM及其VIVADO的IP核的使用</title>
    <url>/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="双口ram概述">双口RAM概述</h1>
<p>双口RAM（dual port
RAM）在异构系统中应用广泛，通过双口RAM，不同硬件架构的芯片可以实现数据的交互，从而实现通信。例如，一般情况下，ARM与DSP之间的通信，可以利用双口RAM实现，ARM通过EBI总线连接到双口RAM的A口，DSP通过EMIF总线（也可以是uPP总线，取决于速度需求）连接到双口RAM的B口，两者对同一块存储区域进行操作，即可实现两者的数据交互。
<span id="more"></span>
但是，因为双口RAM的A口和B口都可以对相同的内存地址进行操作，这就引出了一个问题——假如通信双方在两个端口对同一地址同时读写，就会引发冲突。要解决这个问题，办法有二。一是通信双方在时序上保证不会同时读写同一地址，将ARM和DSP可写地址范围进行分区，无论任何一方写完数据后都通过IO发送中断通知对方，对方进行数据读取（乒乓RAM操作），这样是比较可靠的；另外一个办法就是在fpga里设置写busy信号，实现两端写同步<a href="http://blog.csdn.net/DanielLee_ustb/article/details/46446359">1</a>。在FPGA中，构建双口RAM可以通过两种方法，一种是利用distributed
RAM构建，另一种是利用Block
RAM构建，关于两者的具体区别，可以参考这两篇文章<a href="http://blog.csdn.net/yzy19900402/article/details/45025901">2</a><a href="http://blog.csdn.net/jbb0523/article/details/6533760">3</a>。简而言之，Block
RAM是是使用FPGA中的整块双口RAM资源，而distributed
RAM则是用FPGA中的逻辑资源拼凑形成的。一般的原则是，较大的存储应用，建议用bram；零星的小ram，一般就用dram。</p>
<p>在Vivado中，RAM IP核在Memories &amp; Strorage Elements&amp; ROMs和RAM
&amp; ROMs &amp; BRAM文件夹下，如图所示，下面简要介绍一下Vivado的双口RAM
IP核。 <img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-23-22.png#pic_center" title="图1.1" alt="图1.1"> # Vivado 双口RAM IP核 ## Block Memory
Generator概述     点击图1.1的Block Memory
Generator项，利用BRAM来构建双口RAM。Block Memory
Generator窗口如图2.1所示。图中，第1部分，在IP
symbol选项卡，点击"+"号可以展开端口具体信号，如图2.2所示。第2部分，Component
Name可以设置IP核的名字。第3部分，Basic选项卡，在Memory
Type下拉列表中，可以设置内存的类型，如图2.3所示。Block Memory
Gnerator一共可以产生5种不同类型的内存空间，其中block
RAM有三种：单口RAM、简化双口RAM和真双口RAM<a href="https://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_2/pg058-blk-mem-gen.pdf">4</a>。单口RAM只有一个端口（A端口），可以对A端口进行读写。简化双口RAM有两个端口（A和B端口），但是A端口只能进行写入操作，不能进行读出操作，而B端口则只能进行读出操作，不能进行写入操作。真双口RAM有两个端口（A和B端口），A和B端口都能进行读写操作<a href="http://blog.csdn.net/c602273091/article/details/39694145">5</a>。
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-24-16.png#pic_center" title="图2.1" alt="图2.1"> <img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-24-48.png#pic_center" title="图2.2" alt="图2.2"> <img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-25-15.png#pic_center" title="图2.3" alt="图2.3"> ## 真双口RAM的设置 ### Basic设置 <img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-25-36.png#pic_center" title="图2.4" alt="图2.4"> ### Port设置 点击Port A
Options选项卡，对A端口进行设置， 设置Write
Width为16（即RAM单元为16位），Write
Width为1024（即内存深度为1024，该端口可读写的RAM单元有1024个），Operating
Mode（操作模式）一共有三种：Write First，Read First，No Change。在Write
First模式中，在一个时钟周期里，写入内存单元的数据被同步输出到输出数据总线上；在Read
First模式中，在一个时钟周期里，写入到内存单元的数据是当前输入数据总线上的数据，而输出到输出数据总线上的数据则是上一个时钟周期存储在内存单元中的数据。细节可参考PG058的49到50页4。Enable
Port Type设置为Always
Enabled，一直使能端口A。其它设置使用默认设置。如图2.5所示。 <img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-26-04.png#pic_center" title="图2.5" alt="图2.5"> 端口B设置为与A一致。在Other
Options选项卡中，保留默认设置。Load Init
File设置是否用Coe文件对内存区域初始化，这个在初始化ROM的时候会用到，这里不勾选，保持默认。最后，在Summary选项卡会显示消耗的资源。</p>
<h1 id="双口ram例程">双口RAM例程</h1>
<p>​例程1，该例程是Altera官方例程<a href="https://www.altera.com.cn/support/support-resources/design-examples/design-software/verilog/ver-true-dual-port-ram-sclk.html">6</a>，采用寄存器构建双口RAM，代码如下：
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> true_dpram_sclk</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data_a, data_b,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>:<span class="number">0</span>] addr_a, addr_b,</span><br><span class="line">    <span class="keyword">input</span> we_a, we_b, clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] q_a, q_b</span><br><span class="line">);</span><br><span class="line">    <span class="comment">// Declare the RAM variable</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] ram[<span class="number">63</span>:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Port A</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (we_a) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            ram[addr_a] &lt;= data_a;</span><br><span class="line">            q_a &lt;= data_a;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q_a &lt;= ram[addr_a];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Port B</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (we_b)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            ram[addr_b] &lt;= data_b;</span><br><span class="line">            q_b &lt;= data_b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q_b &lt;= ram[addr_b];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure> 例程2，该例程是Xilinx官方例程<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_4/ug901-vivado-synthesis.pdf">7</a>，采用寄存器构建真双口RAM，代码如下：
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dual-Port Block RAM with Two Write Ports</span></span><br><span class="line"><span class="comment">// File: rams_16.v</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> v_rams_16 (clka,clkb,ena,enb,wea,web,addra,addrb,dia,dib,doa,dob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clka,clkb,ena,enb,wea,web;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">9</span>:<span class="number">0</span>] addra,addrb;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] dia,dib;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] doa,dob;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] ram [<span class="number">1023</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] doa,dob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clka) <span class="keyword">begin</span> <span class="keyword">if</span> (ena)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">if</span> (wea)</span><br><span class="line"> ram[addra] &lt;= dia;</span><br><span class="line"> doa &lt;= ram[addra];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clkb) <span class="keyword">begin</span> <span class="keyword">if</span> (enb)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">if</span> (web)</span><br><span class="line"> ram[addrb] &lt;= dib;</span><br><span class="line"> dob &lt;= ram[addrb];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure> ​例程3，该例程是网友博客中的例程<a href="http://blog.csdn.net/yanglong890124/article/details/32742297">8</a>，代码如下：
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP(  </span><br><span class="line"><span class="keyword">input</span> USER_CLK  </span><br><span class="line">    );  </span><br><span class="line">  </span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DLY #1  </span></span><br><span class="line"><span class="keyword">reg</span> FPGA_Enable=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] FPGA_Write_Enable=<span class="number">4&#x27;h0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Address=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Write_Data=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data_reg=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">10</span>:<span class="number">0</span>] count=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> USER_CLK)  </span><br><span class="line"><span class="keyword">begin</span>  </span><br><span class="line">    count &lt;= count + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;=<span class="number">100</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;h0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">105</span>)&amp;&amp;(count &gt;<span class="number">100</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;hf</span>;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= FPGA_Write_Data + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">110</span>)&amp;&amp;(count &gt;<span class="number">105</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;h0</span>;  </span><br><span class="line">        FPGA_Address &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">117</span>)&amp;&amp;(count &gt;<span class="number">110</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;h0</span>;  </span><br><span class="line">        FPGA_Read_Data_reg &lt;= FPGA_Read_Data;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">118</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        count &lt;= count;  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line">BBBB your_instance_name (  </span><br><span class="line">  <span class="variable">.clka</span>(USER_CLK), <span class="comment">// input clka  </span></span><br><span class="line">  <span class="variable">.ena</span>(FPGA_Enable), <span class="comment">// input ena  </span></span><br><span class="line">  <span class="variable">.wea</span>(FPGA_Write_Enable), <span class="comment">// input [3 : 0] wea  </span></span><br><span class="line">  <span class="variable">.addra</span>(FPGA_Address), <span class="comment">// input [31 : 0] addra  </span></span><br><span class="line">  <span class="variable">.dina</span>(FPGA_Write_Data), <span class="comment">// input [31 : 0] dina  </span></span><br><span class="line">  <span class="variable">.douta</span>(FPGA_Read_Data), <span class="comment">// output [31 : 0] douta  </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="variable">.clkb</span>(clkb), <span class="comment">// input clkb  </span></span><br><span class="line">  <span class="variable">.enb</span>(enb), <span class="comment">// input enb  </span></span><br><span class="line">  <span class="variable">.web</span>(web), <span class="comment">// input [3 : 0] web  </span></span><br><span class="line">  <span class="variable">.addrb</span>(addrb), <span class="comment">// input [31 : 0] addrb  </span></span><br><span class="line">  <span class="variable">.dinb</span>(dinb), <span class="comment">// input [31 : 0] dinb  </span></span><br><span class="line">  <span class="variable">.doutb</span>(doutb) <span class="comment">// output [31 : 0] doutb  </span></span><br><span class="line">);  </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
​该例程中，在count为101（&gt;100）后开始往地址4到20写入1-5，然后在count为111（&gt;110）的时候读出写入的数据。
# 仿真
下面利用Modelsim和Vivado进行联合仿真，关于vivado如何与modelsim进行联合仿真可以参考这篇文章：</p>
<p><a href="http://blog.chinaaet.com/crazybird/p/5100000539">vivado与modelsim的关联以及器件库编译</a></p>
<p>有一点要注意的是，我用的是Vivado2017.1版本，这个版本只支持Modelsim10.5及以上的版本，如果是低版本的Modelsim，在用Vivado2017.1编译Modelsim的仿真库时，会出错。Modelsim10.5版本可以在这里下载：</p>
<p><a href="http://bbs.eetop.cn/viewthread.php?tid=629292&amp;extra=&amp;page=1">modelsim
10.5 适用vivado 2017.1</a></p>
<p>用Modelsim仿真时，会在sim_1/behav文件夹下产生3个.do文件，分别是xx_compile.do，xx_simulate.do，xx
_wave.do文件。在设计的verilog文件修改之后，如果在Modelsim中直接restart，仿真的其实还是没有修改前的文件，要使修改的.v文件在Modelsim中生效，可以在Modelsim的命令窗口输入do
xx_compile.do文件，对仿真的库文件以及设计文件（.v文件）重新编译，然后在输入do
xx_simulate.do文件，才能仿真修改后的文件。输入do
xx_compile.do命令对设计文件重新编译的时候，Modelsim会强制退出，这时由最后一句force
quit命令引起的，只要把它删掉就行了。如果要保存波形文件，可以save
format，另存为xx_wave.do文件。</p>
<p>参考上面双口RAM的例程3进行功能仿真，RAM IP使用Write
First模式，设计文件代码如下： <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Company: </span></span><br><span class="line"><span class="comment">// Engineer: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Create Date: 2017/12/09 22:36:48</span></span><br><span class="line"><span class="comment">// Design Name: </span></span><br><span class="line"><span class="comment">// Module Name: dual_port_ram_demo</span></span><br><span class="line"><span class="comment">// Project Name: </span></span><br><span class="line"><span class="comment">// Target Devices: </span></span><br><span class="line"><span class="comment">// Tool Versions: </span></span><br><span class="line"><span class="comment">// Description: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Dependencies: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Revision:</span></span><br><span class="line"><span class="comment">// Revision 0.01 - File Created</span></span><br><span class="line"><span class="comment">// Additional Comments:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dual_port_ram_demo(</span><br><span class="line"><span class="keyword">input</span> USER_CLK</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DLY #1  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Port A declaration</span></span><br><span class="line"><span class="keyword">reg</span> FPGA_Enable=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span> FPGA_Write_Enable=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Address=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Write_Data=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data_reg=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Port B declaration</span></span><br><span class="line"><span class="keyword">reg</span> enb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] web=<span class="number">4&#x27;h0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] addrb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] dinb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] doutb_reg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] doutb=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">10</span>:<span class="number">0</span>] count=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> USER_CLK)  </span><br><span class="line"><span class="keyword">begin</span>  </span><br><span class="line">    count &lt;= count + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;=<span class="number">100</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">105</span>)&amp;&amp;(count &gt;<span class="number">100</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= FPGA_Write_Data + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">110</span>)&amp;&amp;(count &gt;<span class="number">105</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Address &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">117</span>)&amp;&amp;(count &gt;<span class="number">110</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Read_Data_reg &lt;= FPGA_Read_Data;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">118</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        count &lt;= count;  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line">dpRAM u1 (  </span><br><span class="line">  <span class="variable">.clka</span>(USER_CLK), <span class="comment">// input clka  </span></span><br><span class="line">  <span class="variable">.ena</span>(FPGA_Enable), <span class="comment">// input ena  </span></span><br><span class="line">  <span class="variable">.wea</span>(FPGA_Write_Enable), <span class="comment">// input [3 : 0] wea  </span></span><br><span class="line">  <span class="variable">.addra</span>(FPGA_Address), <span class="comment">// input [31 : 0] addra  </span></span><br><span class="line">  <span class="variable">.dina</span>(FPGA_Write_Data), <span class="comment">// input [31 : 0] dina  </span></span><br><span class="line">  <span class="variable">.douta</span>(FPGA_Read_Data), <span class="comment">// output [31 : 0] douta  </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="variable">.clkb</span>(USER_CLK), <span class="comment">// input clkb  </span></span><br><span class="line">  <span class="variable">.enb</span>(enb), <span class="comment">// input enb  </span></span><br><span class="line">  <span class="variable">.web</span>(web), <span class="comment">// input [3 : 0] web  </span></span><br><span class="line">  <span class="variable">.addrb</span>(addrb), <span class="comment">// input [31 : 0] addrb  </span></span><br><span class="line">  <span class="variable">.dinb</span>(dinb), <span class="comment">// input [31 : 0] dinb  </span></span><br><span class="line">  <span class="variable">.doutb</span>(doutb) <span class="comment">// output [31 : 0] doutb  </span></span><br><span class="line">);  </span><br><span class="line"><span class="keyword">endmodule</span>  </span><br></pre></td></tr></table></figure> ​testbench文件如下：
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Company: </span></span><br><span class="line"><span class="comment">// Engineer: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Create Date: 2017/12/09 22:47:26</span></span><br><span class="line"><span class="comment">// Design Name: </span></span><br><span class="line"><span class="comment">// Module Name: simu</span></span><br><span class="line"><span class="comment">// Project Name: </span></span><br><span class="line"><span class="comment">// Target Devices: </span></span><br><span class="line"><span class="comment">// Tool Versions: </span></span><br><span class="line"><span class="comment">// Description: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Dependencies: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Revision:</span></span><br><span class="line"><span class="comment">// Revision 0.01 - File Created</span></span><br><span class="line"><span class="comment">// Additional Comments:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> simu(</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"><span class="comment">//testbench 时钟信号</span></span><br><span class="line"><span class="keyword">reg</span> clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> # <span class="number">10</span> clk &lt;= ~clk;</span><br><span class="line"><span class="comment">//调用dual_port_ram_demo模块</span></span><br><span class="line">dual_port_ram_demo demo1(clk);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure> 仿真结果如下： <img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-26-41.png#pic_center" title="图4.1" alt="图4.1">
程序在1时刻准备好地址和要写入RAM的数据，在2时刻写入RAM中，在3时刻端口才会输出2时刻写入RAM的数据，注意与PG058的图稍有不同。
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-27-26.png#pic_center" title="图4.2" alt="图4.2"> # 后记
关于BRAM，推荐一个youtube视频，里面讲的非常清晰易懂。 <a href="https://www.youtube.com/watch?v=fqUuvwl4QJA">What is a Block RAM
in an FPGA?</a> # 参考文献 [1] <a href="http://blog.csdn.net/DanielLee_ustb/article/details/46446359">基于FPGA的双口RAM设计方法</a>
[2] <a href="http://blog.csdn.net/yzy19900402/article/details/45025901">关于Xilinx芯片中Block
RAM和Distributed RAM 的区别</a> [3] <a href="http://blog.csdn.net/jbb0523/article/details/6533760">Block RAM
和Distributed RAM</a> [4] <a href="https://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_2/pg058-blk-mem-gen.pdf">Block
Memory Generator v8.2 LogiCORE IP Product Guide (PG058)</a> [5] <a href="http://blog.csdn.net/c602273091/article/details/39694145">FPGA开发之RAM
IP的使用</a> [6] <a href="https://www.altera.com.cn/support/support-resources/design-examples/design-software/verilog/ver-true-dual-port-ram-sclk.html">Verilog
HDL：具有单时钟的真双端口RAM</a> [7] <a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_4/ug901-vivado-synthesis.pdf">Vivado
Design Suite User Guide: Synthesis (UG901)</a> [8] <a href="http://blog.csdn.net/yanglong890124/article/details/32742297">FPGA
内部双口块RAM 读写实现</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPAG</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析比特币脚本</title>
    <url>/2022/06/17/%E6%B5%85%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言">前言</h1>
<p>在比特币网络中，每个用户的身份是通过公钥来识别的，由此实现了一定程度的用户的匿名性。那么，直觉上，自然而然地我们会认为每一笔交易是通过公钥来指明支付的对象，毕竟现在公钥就等价于用户的身份证号码。然而实际上并非如此，每一笔交易的输出实际上只是指明了一个脚本(script)，通过脚本，间接地指明这笔交易会把多少比特币转给谁。那么为什么交易的输出不是直接用公钥来指明比特币的支付对象，而要通过脚本来指明呢？
<span id="more"></span>
实际上这是为了保证两点，其一，支付对象的匿名性；其二，所支付的比特币只能被支付对象所使用。举个例子，如下图所示，假如Alice在交易a的输出中，将十个比特币给了Bob，在交易b中，Bob又将这十个比特币转给了Carol，那么Alice在交易a中应该怎么做才能保证这十个比特币在后续的交易中只能被Bob使用，而不是被别人偷走？
<img src="/2022/06/17/%E6%B5%85%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/2022-06-17-16-19-26.png#pic_center" alt="2022-06-17-16-19-26"></p>
<p>Alice应该在交易输出中给出Bob的公钥哈希，并且要求，假如Bob要使用这个十个比特币，那就必须要提供Bob的公钥以及Bob的数字签名，只有当Bob给出的公钥的哈希与Alice给的相等，并且Bob的数字签名有效时，才能使用这十个比特币。为什么Alice不是在交易输出中直接指明Bob的公钥，而是指明Bob的公钥哈希？这是为了实现匿名性，具体原因可以参考这篇博客<a href="https://happypeter.github.io/binfo/address.html#:~:text=%E6%AF%94%E7%89%B9%E5%B8%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF,%E5%AE%9E%E9%99%85%E4%B8%AD%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0%E3%80%82">为何使用地址而不是公钥？</a>。</p>
<p>当Alice在交易输出中使用Bob的公钥哈希时，Alice可以证明这笔支付是给了Bob；而当Bob在后续的交易公开给出公钥和他的数字签名时，可以向大家证明他是Bob，从而解锁Alice所支付的比特币，注意，Bob需要在后续交易中公开公钥，而不是简单地给出他的公钥哈希，这样才能让别人在验证他的数字签名是有效的同时，也证明上一次Alice所支付的地址的确是Bob的公钥哈希。Alice支付的过程就是通过给出输出脚本来实现的，而Bob解锁Alice所支付给他的比特币的过程则是通过输入脚本来实现的。当Bob要解锁Alice支付的比特币时，Bob会给出输入脚本，这个输入脚本会和Alice给出的输出脚本拼接到一起，组成一个完整的脚本，然后执行脚本，如果结果是True，那么就解锁成功，Bob的这次交易就能被成功地添加到区块中，否则这次交易无效，不会被添加到区块中。
# 比特币脚本语言结构
从上面一节可以看出，Bob要完成一次交易，需要执行一个比特币脚本，该脚本由输入脚本(scriptSig)和输出脚本(scriptPubKey)两部分组成，输出脚本由Alice在之前的交易(交易a)的输出中给出，输入脚本则由Bob在本次交易(交易b)中给出。比特币脚本使用方法主要有以下几种。</p>
<ol type="1">
<li>P2PK (Pay to Public Key)</li>
<li>P2PKH (Pay to Public Key Hash)</li>
<li>P2SH (Pay to Script Hash)</li>
<li>多重签名</li>
<li>Proof of Burn</li>
</ol>
<p>在本文中介绍的例子将会使用第二种(P2PKH)，这种是最常用的方法，有关其它方法的细节，可以参考<a href="https://blog.csdn.net/ice_fire_x/article/details/104173840">比特币脚本原理和使用方法</a>一文，这里不再细述。一个P2PKH输出脚本(scriptPubKey)的例子如下所示，在上面交易例子中由Alice在交易a的输出中给出，输出脚本里包含了Bob的公钥哈希(69e02e18...)，以及一些操作，后面会提到这些操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">69e02e18...</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>一个输入脚本(scriptSig)的例子如下所示，在上面的交易例子中由Bob在交易b的输入中给出。这里的输入由两部分组成，一是Bob用他自己的私钥对本次交易(即交易b)进行签名所得到的数字签名(sig,
signature)，另一部分就是Bob的公钥(pubKey, public
key)。给出公钥主要有两个目的，一个是证明Alice在交易a中支付的对象的确是Bob，前面提到，Alice在交易a中只是给出了一个公钥哈希，但是并没有明确指明Bob的公钥，那么别人怎么能知道Alice给的这个公钥哈希就是Bob的公钥哈希呢？因此，为了证明这点，Bob需要在交易b公开他的公钥，然后取哈希，一旦得到的哈希与Alice给的相等，那就证明了Alice给的公钥哈希的确是Bob的公钥哈希，换言之，Alice这十个比特币的确是支付给Bob的。另外一个目的就是为了进行数字验签，Bob需要给出公钥，别人才能用他的公钥和数字签名进行验签，才能确认他的数字签名有效，即他的确是Bob。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubKey&gt;</span><br></pre></td></tr></table></figure>
<p>Bob在进行交易b时，需要证明他是Bob，以解锁交易a输出中给Bob的十个比特币，这个证明的过程是通过执行脚本来实现的。Bob会将Alice在交易a输出中给出的输出脚本拼接到他给的输入脚本后面，组成一个完整的脚本，然后执行该脚本，拼接后Bob所执行的完整的脚本如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubKey&gt;</span><br><span class="line">------------------------</span><br><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">69e02e18...</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<h1 id="脚本执行过程">脚本执行过程</h1>
<p>比特币脚本所使用的语言是一门基于堆栈的语言，脚本的每一行要么是数据，要么是指令，执行过程从脚本的第一行开始，自上到下。如果是数据的话，就将其压入到堆栈中，如果是指令的话，就执行该指令。</p>
<p>还是以上面的例子来进行说明，当Bob在交易b要解锁Alice在交易a支付给他的十个比特币时，Bob需要执行上面的这个完整的比特币脚本，执行过程如下。</p>
<ul>
<li>第一步，将Bob在交易b的输入脚本中给出的他对当前交易(即交易b)的数字签名&lt;sig&gt;压入堆栈。</li>
<li>第二步，将Bob在交易b的输入脚本中给出的他自己的公钥&lt;pubKey&gt;压入堆栈。</li>
<li>第三步，执行OP_DUP，该操作将会复制Bob的公钥并添加到栈顶。</li>
<li>第四步，执行OP_HASH160，该操作将对当前栈顶的Bob的公钥拷贝进行哈希运算，得到Bob的公钥哈希&lt;pubKeyHash&gt;，并将其替换当前栈顶的Bob的公钥拷贝。</li>
<li>第五步，将Alice在输出脚本中给出的Bob的公钥哈希&lt;pubKeyHash?&gt;(在上面的例子中是69e02e18...)弹入到堆栈中。</li>
<li>第六步，执行OP_EQUALVERIFY，判断Alice给出的公钥哈希&lt;pubKeyHash?&gt;，和第四步对Bob的公钥进行哈希运算后得到的公钥哈希&lt;pubKeyHash&gt;进行对比，判断两者是否相等，相等则继续往下执行，否则认为本次交易失败。</li>
<li>第七步，假如第六步的操作成功，那么将执行这一步。到这一步时，堆栈中只剩下Bob在交易b的输入脚本中给出的他的公钥(&lt;pubKey&gt;)，以及他用自己的私钥对交易b进行签名所得到的数字签名(&lt;sig&gt;)。执行OP_CHECKSIG，该操作将进行数字验签。验签过程大致如下，用Bob给出的公钥(&lt;pubKey&gt;)对他给出的他对交易b的数字签名进行解密，得到一个哈希值hash
= decrypt(publicKey,
signature)，然后再对交易b进行哈希运算，得到另一个哈希值hash'，假如hash和hash’相等，那么数字验签成功，即Bob证明了他是Bob，可以开始使用Alice在交易a中给他的十个比特币了，本次交易有效，将被加入到新创建的区块中；否则验签失败，本次交易被丢弃。关于数字验签，可以参考<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626">签名算法</a>以及<a href="https://segmentfault.com/a/1190000024523772">一文彻底搞懂加密、数字签名和数字证书！</a>这两篇文章。</li>
</ul>
<p>上面的执行过程可以用下图表示，大家可以参考这张图，结合上面的描述来理解整个过程。
<img src="/2022/06/17/%E6%B5%85%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/2022-06-17-16-21-56.png#pic_center" alt="2022-06-17-16-21-56"> # 参考文献</p>
<ol type="1">
<li><a href="https://happypeter.github.io/binfo/address.html#:~:text=%E6%AF%94%E7%89%B9%E5%B8%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF,%E5%AE%9E%E9%99%85%E4%B8%AD%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0%E3%80%82">为何使用地址而不是公钥？</a></li>
<li><a href="https://blog.csdn.net/ice_fire_x/article/details/104173840">比特币脚本原理和使用方法</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626">签名算法</a></li>
<li><a href="https://segmentfault.com/a/1190000024523772">一文彻底搞懂加密、数字签名和数字证书！</a></li>
<li><a href="https://www.liaoxuefeng.com/article/1124144362997184">深入理解比特币交易的脚本</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25461051">理解比特币脚本</a></li>
<li><a href="https://bitcoinbook.cs.princeton.edu/">Bitcoin and
Cryptocurrency Technologies</a> by Arvind Narayanan, Joseph Bonneau
etl.</li>
</ol>
]]></content>
      <categories>
        <category>比特币</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
</search>
