<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LTE网络RLC层的polling机制</title>
    <url>/2022/06/16/LTE%E7%BD%91%E7%BB%9CRLC%E5%B1%82%E7%9A%84polling%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>本文将从UE角度对LTE网络RLC层的polling机制进行详细阐述。</p>
</blockquote>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在LTE网络中，RLC层提供了两种服务模式，一种是保证数据无损传输(lossless)的<code>AM模式</code>(acknowledged mode)，另一种是不保证数据可靠传输的<code>UM模式</code>(unacknowledged mode)。在<code>AM模式</code>下，RLC层要保证数据可靠传输，因此，此时的RLC协议是一种<code>可靠性数据传输协议</code>(reliable data transmission protocol, RDP)。</p>
<p>RDP是网络协议中常用的一种协议，TCP协议就是其中之一。与TCP协议相比，RLC位于无线通信协议栈的更底层，对时延的要求更高。因此，为了更快地实现数据的无损传输，RLC层引入了<code>polling</code>(问询)机制。</p>
<h2 id="-more-"><a class="markdownIt-Anchor" href="#-more-"></a> <span id="more"></span></h2>
<h1 id="polling的目的"><a class="markdownIt-Anchor" href="#polling的目的"></a> Polling的目的</h1>
<p>UE<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="User equipment，在蜂窝网络中指终端设备，大部分场景下是手机，也可能是智能手表，智能仪表等其它无线终端设备。
">[1]</span></a></sup> 在向网络发送数据的过程中，由于物理层存在一定的误码率(BLER)，有一些包(packet, 即RLC PDU)有时候可能会在传输过程中发送失败或者丢失。但是，哪一些包发送失败了，从UE侧是无法知道的。因此，为了实现数据的可靠传输，UE需要网络侧的反馈，告诉UE在网络侧哪一些包已经收到，哪一些还没有收到，从而让UE能够重传那些网络还没收到的包，这个反馈就是<code>状态报告</code>(status report)。</p>
<p>但是网络侧怎么能够知道什么时候给UE发送<code>状态报告</code>呢？如果网络侧频繁不停地给UE发送<code>状态报告</code>，那么虽然UE能够很及时地知道网络侧接收情况，但是这样就浪费了很多下行资源；而如果网络侧周期性地给UE发送<code>状态报告</code>，那么UE侧又无法及时得知网络侧的接收情况。引入<code>Polling</code>就是为了这个目的。UE需要向网络询问，哪一些包收到了，哪一些还没收到，这样网络就会回复<code>状态报告</code>，UE就能及时地重传那些没被网络收到(acknowledged)的包。</p>
<hr>
<h1 id="polling的触发条件"><a class="markdownIt-Anchor" href="#polling的触发条件"></a> Polling的触发条件</h1>
<p>在每个RLC data PDU的header部分，有一个P位的标志位，这个标志位就代表<code>polling</code>。当P位为1时，表示UE向网络侧发送<code>polling</code>，期望对方回复<code>状态报告</code>，反之亦然。在以下任一条件满足的情况下，UE都会触发<code>polling</code>：</p>
<ul>
<li>PDU_WITHOUT_POLL &gt;= <em>pollPDU</em></li>
<li>BYTE_WITHOUT_POLL &gt;= <em>pollByte</em></li>
<li>在发送完当前的RLC data PDU后，buffer里不再剩余任何待发送的RLC data PDU</li>
<li><em>t-PollRetransmit</em> 定时器超时</li>
</ul>
<p>UE每发送一个新的RLC data PDU时，PDU_WITHOUT_POLL会加1；BYTE_WITHOUT_POLL也会增加sizeof(RLC PDU payload)。在更新了PDU_WITHOUT_POLL和BYTE_WITHOUT_POLL后，假如PDU_WITHOUT_POLL <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo></mrow><annotation encoding="application/x-tex">\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span></span></span></span> <em>pollPDU</em>，或者BYTE_WITHOUT_POLL <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo></mrow><annotation encoding="application/x-tex">\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span></span></span></span> <em>pollByte</em> ，那么UE需要将该RLC PDU header的P位置1，向网络发送<code>polling</code>。这两个条件保证了UE每向网络发送一部分数据后，都能及时地知道这些数据在网络侧的接收情况。<em>pollPDU</em> 和 <em>pollByte</em> 由网络配置，通过RRC层向RLC层下发。</p>
<p>当UE发送buffer里最后一个新传RLC data PDU时，也应该置P位为1。这也是符合直觉的。因为在发送完最后一个新传RLC data PDU后，UE有可能很长时间都不会发送新的数据了，这时候前两个条件就无法触发了。因此，这时候需要向网络发送<code>polling</code>，获取网络的接收状态报告，然后及时地将前面还没发送成功的包给发送出去。</p>
<p>假如在上面的<code>polling</code>触发，并且重传RLC PDU后，网络侧还是有一些包没收到，而此时UE不再有新的包发送了，那么网络侧岂不是再也收不到这些没收到的包了？针对这个问题，RLC层提供了最后一个polling触发条件，保证了在这种场景下，UE还能向网络发送这些丢失的包。UE在RLC层有一个 <em>t-PollRetransmit</em> 定时器，每当UE发送了<code>polling</code>后，都会启动 <em>t-PollRetransmit</em> 定时器(或者重启，假如此时定时器还在运行)。当 <em>t-PollRetransmit</em> 定时器超时时，假如</p>
<ul>
<li>buffer(包括RLC data PDU新传队列和重传队列)为空</li>
<li>或者无法发送新传RLC PDU(比如此时因为收不到给VT(A)的ACK，导致window stall了)</li>
</ul>
<p>那么UE需要向网络重传一包RLC data PDU，并将该RLC data PDU的P位置1，向网络发送<code>polling</code>，这样就保证了在无法发送新传的数据时，UE还能收到网络的<code>状态报告</code>，从而重传之前丢失的包，补齐网络侧的接收窗口，而不至于让网络侧长时间无法完全收到这些包。UE在这种场景下向网络侧重传的RLC data PDU，可以选择以下两种之一：</p>
<ul>
<li>SN<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Sequence number，每一包RLC data PDU都有一个sequence number，在一段时间内可以唯一标识这包RLC data PDU。">[2]</span></a></sup>为VT(S) – 1的RLC data PDU，即发送窗口最右侧的那个RLC data PDU</li>
<li>发送窗口中任何一个还没被网络侧确认已经收到的RLC data PDU</li>
</ul>
<hr>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文从UE侧角度介绍了LTE网络RLC层的一个基本功能——<code>polling</code>机制。<code>polling</code>机制只在<code>AM模式</code>下才会生效，其目的是为了能及时得知网络侧的接收情况，从而及时地向网络重传丢失的数据包，保证数据的低时延可靠传输。最后介绍了<code>polling</code>的触发条件。</p>
<hr>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] 3GPP协议 36322 section 5.2.2<br>
[2] <font color="DodgerBlue">Radio Protocols for LTE and LTE-Advanced (2012)</font> by SeungJune Yi, SungDuck Chun, etl. section 5.4.4<br>
[3] 深入理解LTE-A. 温金辉著. section 36.3.3.2</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">User equipment，在蜂窝网络中指终端设备，大部分场景下是手机，也可能是智能手表，智能仪表等其它无线终端设备。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Sequence number，每一包RLC data PDU都有一个sequence number，在一段时间内可以唯一标识这包RLC data PDU。<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>RLC</tag>
      </tags>
  </entry>
  <entry>
    <title>LTE网络MAC层令牌桶算法</title>
    <url>/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<p>LTE MAC层的一个重要的功能是从各个逻辑信道读取数据(MAC SDU)，然后将它们封装成一个数据块(MAC transport block)，再交给物理层从空口发生出去，这个过程叫packet build。每一次packet build能发送的数据块的大小由网络决定，网络会通过PDCCH指示UE在哪个子帧上可以发送多少字节的数据，可以发送的字节数就是最终能发送的数据块的大小，也叫UL grant(Uplink grant)。</p>
<span id="more"></span>
<p>那么UE的MAC层在接收到UL grant后，应该如何将这些UL grant分配到不同的逻辑信道上呢？是要将这些UL grant平均分配给当前所有的逻辑信道，每个逻辑信道都能发送同样的数据量吗？这个方法虽然很公平，但是却并不高效，主要有两个原因，其一，不同逻辑信道之间要发送的数据量可能差异非常大，这就导致了对有的逻辑信道来说所分得的UL grant不足以发送buffer里所有的数据，而对另一些逻辑信道来说所分得的UL grant可能又太多了，超出了buffer里的数据量，从而造成了浪费。那么按照先来后到的原则行不行，先发送最早激活的逻辑信道的数据，假如在清空该逻辑信道的buffer后，如果还有剩余的UL grant，再发送次早激活的逻辑信道的数据，依次类推。按照这种方法，能够保证所有的UL grant都被用来发送有效数据，不会造成资源浪费，但是这时又出现了另外一个问题，假如先激活的逻辑信道数据量一直很大，而后激活的逻辑信道数据量虽然没那么大，但是却很重要，这就会导致所有的UL grant都被用来发送先激活的逻辑信道数据了，而后激活的逻辑信道却始终得不到服务，重要的数据发不出去，这样会导致某些上层应用完全停滞，严重影响用户体验。那么按照逻辑信道优先级来服务呢？先发送优先级最高的逻辑信道的数据，再依次发送低优先级逻辑信道的数据，这样就能保证重要的数据先发送出去。但是这样也会有类似的问题，假如高优先级逻辑信道的数据量一直很大，就会导致低优先级逻辑信道一直得不到服务，通俗来说就是一直处于饥饿状态。</p>
<p>为了能既保证一定程度的公平(即所有的逻辑信道都能得到不同程度的服务)又兼顾效率(即UL grant不会被浪费)，LTE的MAC层的packet build过程采用了令牌桶算法(token bucket algorithm)。</p>
<h1 id="令牌桶算法概述"><a class="markdownIt-Anchor" href="#令牌桶算法概述"></a> 令牌桶算法概述</h1>
<p>令牌桶算法被广泛用于有线网络和无线网络的数据调度中。令牌桶算法工作过程大致如下图(a)和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span>所示。主机维护了一个令牌桶，以速率R往令牌桶中注入令牌。主机往网络发送数据的时候，会先判断令牌桶里面是否还有令牌，如果有，才能发送数据，并且发送多少数据就从令牌桶中取出多少令牌。如果令牌桶为空，那么主机就不能向网络发送数据了，所有的packet只能缓存在主机的队列里。</p>
<p><img src="/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/2022-06-17-00-38-27.png#pic_center" alt="2022-06-17-00-38-27"></p>
<p>在传统的有线网络中，令牌桶算法可被应用于路由器(网络层, network layer)，用于对网络流量进行平滑整形，以减少网络拥塞。令牌桶限制了数据流的长期速率，但是却允许短期的数据洪流(burst)。主机在短时间内可以以极高的速率发送数据，而不必缓存任何的数据，因此在这段时间内数据不会有任何的时延。从长期来看，数据速率会被限定为令牌增加的速率R，一旦令牌桶被清空，后续的数据发送速率就只能受限于令牌注入的速度了。</p>
<p>在无线通信网络中，令牌桶算法可以用于保证不同的上层业务的服务质量(QoS, quality of service)。在LTE网络里，MAC层就采用了令牌桶算法。</p>
<h1 id="mac令牌桶算法实现"><a class="markdownIt-Anchor" href="#mac令牌桶算法实现"></a> MAC令牌桶算法实现</h1>
<p>MAC实体在每一次要进行HARQ新传的时候，都会按照令牌桶(token bucket)算法对UL grant进行分配，这个过程叫<strong>Logical Channel Prioritization</strong>过程。</p>
<p>对每个逻辑信道，RRC都为其分配一个逻辑信道优先级(<strong>priority</strong>)，以此控制上行数据的调度。优先级的数字越小，其优先级越高。比如，SRB1(逻辑信道ID为1)的优先级通常为1，表示其优先级最高。除了逻辑信道优先级，RRC还会分配<strong>prioritisedBitRate</strong>，<strong>bucketSizeDuration</strong> 这两个参数。<strong>prioritisedBitRate</strong>(PBR, Prioritized Bit Rate)表示对每个逻辑信道的缓存数据需要以多大的速率进行优先处理，保证了各个逻辑信道的最低服务质量。<strong>bucketSizeDuration</strong> (BSD, Bucket Size Duration)表示令牌桶的深度，通过限制令牌桶的深度对突发数据流(data burst)进行一定程度的流控，从而保证数据的平滑传输。</p>
<p>对每个逻辑信道(用变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>表示)，MAC实体都为其维护一个变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示令牌桶当前令牌数目 。在该逻辑信道新添加时，需要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>初始化为0，其后每个TTI(对LTE来说是1ms)，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 都应增加PBR × TTI(即PRB)，表示往令牌桶中新增加令牌数为PBR，其中PBR就是该逻辑信道需要优先处理的数据比特率(Prioritized Bit Rate of logical channel <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>)。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不会无限增大，当令牌桶的令牌溢出时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的值就会被限定为令牌桶的大小，其大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">B_{j}=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> PBR × BSD。PBR和BSD都是由RRC层配置，RRC层在配置MAC实体时会设置这两个参数。</p>
<p>当MAC实体收到UL grant，需要进行新传时，UL grant的分配过程如下图所示，这个过程叫Logical Channel Prioritization procedure。<br>
<img src="/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/2022-06-17-00-44-53.png#pic_center" alt="2022-06-17-00-44-53"></p>
<p>根据上图，MAC实体按以下过程对UL grant进行分配。</p>
<ol>
<li>按逻辑信道优先级从高到低的顺序对UL grant进行分配，对每个逻辑信道进行组包(MAC UL transport block)。注意，这里是按逻辑信道优先级排序。因为数字越小表示优先级越高，所以会从priority数字最小的逻辑信道开始进行组包。在分配UL grant给逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的时候，会先看看令牌桶还有多少令牌(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>有多大)，如果令牌数大于等于buffer的数据量(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>⩾</mo></mrow><annotation encoding="application/x-tex">B_{j}\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span></span></span></span>  buffer的数据量)，那么给逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的buffer有多少数据，就给它分配多少UL grant，当然如果UL grant不足以发送逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的buffer里所有的数据，那么有多少UL grant就给它分配多少UL grant。如果令牌数小于buffer的数据量(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">B_{j}&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span></span></span>  buffer的数据量)，那么有多少令牌就分配多少UL grant，当然如果UL grant比令牌数还小，那就把所有的UL grant都分配给逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。当逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的PBR设为&quot;infinity&quot;时，则在为其分配UL grant时不会考虑其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的大小，所有的UL grant都会先分配给该逻辑信道，假如在发送完其buffer的数据后，还有剩余的UL grant，这时才会再将剩余的UL grant分配给其它的逻辑信道。</li>
<li>从逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>中减去步骤1所build的所有MAC SDUs的大小之和。(参考实现：对于逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，每传输一个RLC SDU，先比较<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>是否大于0。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则往MAC PDU中添加该SDU，然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>−</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">B_{j}-=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>sizeof(RLC SDU)，并判断是否满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>⩽</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}\leqslant 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，如此反复，直到满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>⩽</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}\leqslant 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，再处理下一逻辑信道)。</li>
<li>如果前两步执行完还剩有UL grant的话，则不管<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的大小，把剩余的UL grant按照逻辑信道优先级从高到低分配给各个逻辑信道。只有当高优先级的逻辑信道服务完(即所有的数据都发送完毕)，且还有剩余的UL grant可用于服务剩余的逻辑信道时，才会继续服务优先级较低的逻辑信道。对剩余的逻辑信道也是执行同样的逻辑。在这一步，因为所有的逻辑信道都已经得到了最低保障，因此不会再考虑公平的原则。MAC实体会尽全力服务高优先级的逻辑信道，尽可能地把高优先级的逻辑信道的数据尽快发送出去。</li>
</ol>
<p>在上述UL grant分配过程中，MAC层遵循以下原则：</p>
<ul>
<li>如果剩余的UL grant足够发送整个RLC SDU，则不应对该SDU分段。</li>
<li>如果受限于剩余UL grant的大小，不得不对RLC SDU分段，则应根据剩余UL grant的大小，尽可能地填入最大的分段。即尽可能地有效利用剩余的UL grant。</li>
<li>应最大化数据的传输。</li>
<li>如果某个无线承载(RB, radio bearer)被挂起(suspend)，那么不应该build该RB所对应逻辑信道的数据。</li>
<li>如果UL grant<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo></mrow><annotation encoding="application/x-tex">\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span></span></span></span> 4bytes，而buffer里还有数据要发送时，则MAC实体不应该把这些UL grant都用来发送padding BSR或者padding，换言之MAC实体应该尽可能发送有效数据，除非UL grant <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 7bytes且要发送的数据是RLC PDU segment，此时因为UL grant不足以发送任何的RLC PDU payload，因此只能发送padding BSR或者padding。</li>
</ul>
<p>如果所有的逻辑信道的PBR都设为0 kBps，就不再保证各个逻辑信道的服务质量都能得到最低保障，此时就会退化为只考虑优先级的调度算法，等价于上面的算法只剩下第三步。在这种情况下，MAC实体会尽力服务优先级更高的逻辑信道，然后依次往下服务低优先级的逻辑信道。当然，对每个逻辑信道的服务都是建立在UL grant还有剩余的前提下，如果UL grant已经用完，那么剩余的逻辑信道在本次packet build就不能得到服务了。</p>
<p>在上述算法的第二步可以看到，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的值可能为负，这是因为，在算法的第一步，会遵循尽量不对RLC SDU分段的原则。在UL grant足够的情况下，宁可让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的使用超出预算，也要争取把RLC SDU给完整地build完。因此，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，但<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>−</mo></mrow><annotation encoding="application/x-tex">B_{j}-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">−</span></span></span></span>sizeof(RLC SDU)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，假如剩余的UL grant足够的话，MAC实体依然会在本次build完这个RLC SDU，而不是对其分段。在build完这个RLC SDU后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>将为负数，令牌桶的令牌已经用完，逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>就不能再build任何RLC SDU了。其后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>将逐渐恢复，在每个子帧，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都会增加PBR，只有当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，即令牌桶又有令牌了，才能继续对逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>进行packet build。</p>
<p>以上的算法可以用以下的伪代码表示(仅供参考，真正的实现有所出入)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sort the logic channel by priority</span><br><span class="line"></span><br><span class="line">iterate each active logic channel from highest priority to lowest</span><br><span class="line">  <span class="keyword">if</span> Bj &gt;= available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">    <span class="keyword">if</span> UL grant is sufficient to send all the available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      UL grant -= available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      build all the packet in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allocate all the UL grant to the current logic channel</span><br><span class="line">      build all UL grant bytes <span class="keyword">for</span> the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> UL grant is sufficient to use up all the Bj</span><br><span class="line">      UL grant -= Bj</span><br><span class="line">      build Bj bytes RLC PDUs</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allocate all the UL grant to the current logic channel</span><br><span class="line">      build all UL grant bytes <span class="keyword">for</span> the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> there is still any UL grant left</span><br><span class="line">  iterate each active logic channel from highest priority to lowest</span><br><span class="line">    leftover UL grant is used to serve the leftover data in the buffer</span><br><span class="line">    <span class="keyword">if</span> there is no leftover UL grant</span><br><span class="line">      <span class="keyword">break</span>;        </span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] 深入理解LTE-A. 温金辉著. 第17章17.1节<br>
[2] 3GPP协议36.321. 第5.4.3.1节<br>
[3] Computer networks(fifth edition). By Andrew S. Tanenbaum etl. Section 5.4.2</p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04编译及安装LLDB</title>
    <url>/2021/12/16/compile-and-install-lldb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#%E7%AE%80%E4%BB%8B">在ubuntu20.04安装LLVM</a>已经介绍了如何在本地编译及安装llvm，但是当时只是编译和安装了<code>llvm;clang;libcxx;libcxxabi</code>这四个库，本文将介绍如何编译及安装lldb。</p>
<span id="more"></span>
<h1 id="配置及安装lldb"><a class="markdownIt-Anchor" href="#配置及安装lldb"></a> 配置及安装LLDB</h1>
<p>在进行下面的步骤时，假设你已经下载了llvm整个工程，并且安装了所需的依赖工具。如果你还没进行这些操作，可以参考<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#%E7%AE%80%E4%BB%8B">在ubuntu20.04安装LLVM</a>一文的<code>本地编译安装LLVM</code>一节的<code>前提条件</code>和<code>下载LLVM源文件</code>这两部分内容，先完成这两步。</p>
<p>完成上述步骤后，输入以下命令。首先cd进入llvm-project工程，然后生成cmake文件。<code>-S llvm</code>表示源文件所在文件夹为当前路径下的llvm文件夹；<code>-B build</code>表示生成的cmake文件将放到当前路径下的build文件夹；<code>-G Ninja</code>表示生成的cmake文件将给Ninja在编译时使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build #若已经创建build目录此步可以省略</span><br><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; #1,这条命令与下面这条命令2选1</span><br><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; ./llvm #2,这条命令与上面的命令2选1</span><br><span class="line">cd build</span><br><span class="line">ninja lldb</span><br></pre></td></tr></table></figure>
<p>在编译到第[4169/4171]个文件时，会出现以下错误。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-18-17-22-28.png" alt="2021-12-18-17-22-28"><br>
参考<a href="https://blog.csdn.net/Vin_tt/article/details/110421022">这篇文章</a>解决这个问题，输入以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project/build</span><br><span class="line">sudo mkdir swapfile</span><br><span class="line">cd /swapfile</span><br><span class="line">sudo dd if=/dev/zero of=swap bs=1024 count=20000000</span><br><span class="line">sudo mkswap -f swap</span><br><span class="line">sudo swapon swap</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/16/compile-and-install-lldb/2021-12-18-17-56-57.png" alt="2021-12-18-17-56-57"><br>
可以看到，剩下的三个文件都被成功地编译了。编译出来生成的应用程序位于llvm-project/build/bin路径下，将其拷贝到/usr/local/bin/文件夹下即可。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-18-18-17-50.png" alt="2021-12-18-18-17-50"></p>
<h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1>
<p>这部分讲的是后续的失败经历，以及没有解决的问题。</p>
<p>上述编译命令在编译lldb过程中会有debug信息，其体积会很大，而且编译出来的文件在llvm-project/build文件夹下面，还需要<code>ninja install</code>命令将其安装至默认路径下，但是由于体积过大，在安装时容易出问题。最好是编译release版本，并且在生成cmake文件的时候指明安装路径，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build #若已经创建build目录此步可以省略</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;lldb&quot;</span> <span class="comment">#1,这条命令与下面这条命令2选1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;lldb&quot;</span> ./llvm <span class="comment">#2,这条命令与上面的命令2选1</span></span></span><br><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLDB_INCLUDE_TESTS=OFF -DCMAKE_INSTALL_PREFIX=&quot;/usr/local/llvm&quot; #1,这条命令与下面这条命令2选1</span><br><span class="line">cmake -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLDB_INCLUDE_TESTS=OFF -DCMAKE_INSTALL_PREFIX=&quot;/usr/local/llvm&quot; ./llvm #2,这条命令与上面的命令2选1</span><br><span class="line">cd build</span><br><span class="line">ninja lldb</span><br></pre></td></tr></table></figure>
<p>编译完成后，生成的文件位于llvm-project/build文件夹内，我们要把它们安装到/usr/local/路径下，因此，需要输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ninja install</span><br></pre></td></tr></table></figure>
<p>然后就会开始将lldb安装到/usr/local/路径下,在安装到第[203/1128]个文件时，出现了<code>fatal error: ld terminated with signal 9 [Killed]</code>错误，参照上面的方法，在build文件夹创建swapfile尝试解决。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-21-23-18-01.png" alt="2021-12-21-23-18-01"><br>
在安装剩下的文件时，安装到[375/927]个文件时仍然出现了以上错误。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-22-08-27-51.png" alt="2021-12-22-08-27-51"><br>
再次尝试用上述方法安装剩下的文件。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-22-08-39-08.png" alt="2021-12-22-08-39-08"><br>
依旧出现以上问题，最终只得作罢。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-22-09-05-29.png" alt="2021-12-22-09-05-29"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://lldb.llvm.org/resources/build.html#building-lldb-with-cmake">Building LLDB with CMake</a></li>
<li><a href="https://blog.csdn.net/Vin_tt/article/details/110421022">LLVM编译collect2: fatal error: ld terminated with signal 9</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>LTE MAC token bucket algorithm</title>
    <url>/2021/11/27/LTE-MAC-token-bucket-algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="abbreviation"><a class="markdownIt-Anchor" href="#abbreviation"></a> Abbreviation</h1>
<p>Below are the abbreviation of some jargons that will be used in the essay.</p>
<p>NW: network<br>
UL: uplink<br>
WFQ: weighted fair queueing</p>
<h1 id="preface"><a class="markdownIt-Anchor" href="#preface"></a> Preface</h1>
<p>In LTE protocol stack, MAC lies in the so-called layer2. One of its main functionalities is managing the UL grant we receive from layer1. In other words, it allocates the UL grant to different logic channels. In this essay, I will briefly talk about how MAC layer allocates the UL grant to different logic channel. It does so by implementing the toket bucket algorithm, which is the official MAC UL sheduling algorithm used by LTE MAC layer, specified in 3GPP specification 36.321.</p>
<span id="more"></span>
<h1 id="token-bucket-algorithm"><a class="markdownIt-Anchor" href="#token-bucket-algorithm"></a> Token bucket algorithm</h1>
<p>Suppose we have below 3 active logic channels. For each logic channel, there will be a bucket which holds the tokens. The size of token bucket for each logic channel are not neccessarily the same. They may vary, depending on NW’s configuration.</p>
<p>Each TTI, a certain amount of token will be injected to seperate logic channel’s token bucket. The amount of token injected each TTI is equal to PBR, which is actually the data rate that we want to ensure that the logic channel can achieve at the very least, to avoid that some logic channel of higher priority might hog over the UL grant and hunger those less prioritized logic channels to death. We want to make sure that as long as there is UL grant, each logic channel might relish a share of it, even for those of low priority.<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-09-22-56-19.png" alt="2022-02-09-22-56-19"></p>
<p>In actual implementation, the token bucket algorithm is essentially a combination of WFQ algorithm and round-robin queueing algorivthm. When we get an UL grant, how should we allocate them to different logic channels? For the sake of discussion, let’s take the below graph as an example. In below graph, each logic channel’s token bucket has 500bytes of token. And each logic channel’s buffer has 3000bytes of data pending in it. Now, if we get an UL grant of 3000bytes at some point, how should we allocate it? If we allocate all of them to one logic channel, that would be unfair to the other 2 logic channels because they don’t get the chance to send out any bit of data. Then how about sharing it fairly among the logic channels? Well, that doesn’t seem a wise choice as well, because in the real-life scenario, some traffic, such as video or audio data, are obviously more important than other application’s traffic, such as FTP. We can tolerate a slowly downloaded file but we have zero tolerance for a jittering video call or voice call!<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-09-23-24-07.png" alt="2022-02-09-23-24-07"></p>
<p>Alright, enough for those non-sense, then what should we do here? Well, after the trade-off of fairness and effectiveness, someone came up with an ingenuous idea that balances both pretty well. In the actual MAC token bucket algorithm, there are 2 rounds of UL grant allocation. The first round is actually somewhat like the WFQ algorithm. In this round, we will start from the highest prioritized logic channel, we allocate a part of the UL grant to it. How many? Depends on the available token bytes and the data pending in the buffer. If there are too much data pending the buffer that the number of token cannot match it, then sorry, we can only allocate the size of the UL grant upto the amount of available token to that particular logic channel at this round. The number of token is the budget. We can’t exceed the budget. If there are not much pending data and the token is enough, then congratulation, we don’t have to consume all the token. Instead, we only need to allocate the size of UL grant that is equal to the number pending data to that logic channel. So, the grant allotment to a logic channel can be summarized with one simple equation as follows. MIN stands for taking the minimum value.</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>=</mo><mi>M</mi><mi>I</mi><mi>N</mi><mo stretchy="false">(</mo><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">allotment=MIN(pending\_data\_size, number\_of\_token)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>After allocating the UL grant to the highest logic channel, we will apply the same logic to allocate the leftover grant to the rest logic channel, one by one, from secondary highest prioritized logic channel all the way down to the least significant logic channel, as long as there is still UL grant left. This is how the first round works. The main purpose of this round is fairness. Regardless it is good or bad, we want to make sure every logic channel can enjoy a piece of the UL grant. The quality of service each logic channel can get depends on the PBR and token bucket size. They work together as the weight in the WFQ algorithm. They defines the weight of each logic channel. Now, let’s take the above graph as an example. How will the situation looks like after the first round of grant allocation? Well, apparently, each logic channel has enough pending data(3000bytes), so all of their available token(500bytes) will be consumed. So the situation will be as follows.<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-10-00-02-20.png" alt="2022-02-10-00-02-20"></p>
<p>All the logic channels’ token bucket are empty. Each one’s buffer will have 500 bytes less(i.e. the amount the token consumed), so there are now only 2500 bytes pending in each logic channels’ buffer. The leftover grant will be only 1500 bytes now. Now, after this round, seems every body is happy with the result right? Everyone can enjoy a bit of it. Fair enough. Well, is it? Suppose LICD1 is the highest prioritized logic channel here, I’m afraid LCID1 will say no! Because sometimes some traffic are much more important than the others(e.g. video or voice call traffic versus downloaded file traffic), they should be preferred when we allocate the UL grant. Fairness might backfire here if we only consider it. So,in order to achieve effectiveness, we will adopt a round-robin strategy in the second round of grant allocation.</p>
<p>Let’s continue the analysis of the scenario above. Now we still have 1500 bytes of UL grant left. Each logic channel’s token bucket is already empty. And each logic channel still has 2500 bytes of pending data. What should we do now? You might think that since the token bucket is already empty, we cannot allocate the grant to any of the logic channel and cannot send out any data anymore. But that’s not the case, because in this round token bucket is not involved at all. Remember, the existence of token bucket is to ensure that each logic channel can get a certain amount of UL grant and hence get some service, regardless of good or bad. Since they have all be served in the first round, we have acheived our goal, so there is no need to adhere to such principle in this round anymore. Instead, we should forget it and try a best-effort strategy in order that the most important logic channel can get the best service. Therefore, starting from the highest prioritized logic channel, we will allocate all the leftover UL grant to it as long as there is enough data in its buffer to consume the UL grant. If after its pending data is all consumed, there is still UL grant left, then we will continue to apply the same logic to the secondary highest prioritized logic channel, until the UL grant has all been consumed or all logic channels’ data has been consumed. So, in this round, all the leftover UL grant(1500 bytes) will be allocated to logic channel 1, and logic channel 1 will have 1000 bytes left. LCID3 and LCID5 channels don’t get the chance to be served in this round, but that’s ok since they have been served in the first round. The scenario will be as below after the second round.<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-10-23-37-24.png" alt="2022-02-10-23-37-24"></p>
<p>There are also might be some minor details skipped here, but that’s the general idea of the token bucket algorithm used in actual implementation.</p>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1>
<p>[1] Computer Networks: A Top-Down Approach. By Behrouz A. Forouzan, Firouz Mosharraf<br>
[2] Computer Networks. By ANDREW S. TANENBAUM, DAVID J. WETHERALL<br>
[3] 36.321. By 3GPP specialist panel.</p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/27/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>在ubuntu20.04安装LLVM</title>
    <url>/2021/12/04/ubuntu-install-llvm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>在ubuntu20.04上安装LLVM，主要有四种方法。</p>
<ul>
<li>方法一：运行官方的自动安装脚本进行安装</li>
<li>方法二：通过包管理器进行安装</li>
<li>方法三：使用官方预编译二进制文件进行安装</li>
<li>方法四：从源码编译安装</li>
</ul>
<span id="more"></span>
<p>第一种方法最为简单，只需要一条命令，执行一下脚本，就不要进行任何操作了。第二种方法较第一种要麻烦一点点，但是也比较简单。第三种办法要麻烦点，但是会比较快，简单来说就是直接到网上下载预编译好的binary文件，将其下载到ubuntu20.04系统中，然后解压，再把解压后的所有文件全部拷贝到系统的/usr/local文件夹下，然后就可以使用了。第四种方法最为麻烦，而且很慢，简单来说就是从网上下载LLVM工程的源代码到ubuntu系统，然后在本机上编译，编译完成再安装。</p>
<p>如果只是为了使用LLVM的工具链，个人建议采用方法一或者二和三(我安装的时候使用的是方法三)，简单快捷。如果为了体验一下在本地编译LLVM工程那种更原汁原味的感觉，可以采用方法四，但是这种方法比较麻烦，因为需要安装一些依赖工具，并且在本地编译LLVM耗时严重，整个过程将会相当漫长，所以如果时间预算不是很充足，又或者电脑配置不太好的情况下，我不建议采用方法四。当然，这里四种方法的过程我都会介绍。</p>
<h1 id="使用官方安装脚本安装"><a class="markdownIt-Anchor" href="#使用官方安装脚本安装"></a> 使用官方安装脚本安装</h1>
<p>首先介绍第一种方法，这种方法又有两个选择，第一个是可以选择安装最新版本的，另外一个就是安装某个特定版本。参考下图，来自<a href="https://apt.llvm.org/">官网</a>的介绍。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-08-23-55-45.png" alt="2021-12-08-23-55-45"></p>
<blockquote>
<p>For convenience there is an automatic installation script available that installs LLVM for you.<br>
To install the latest stable version:<br>
bash -c “$(wget -O - <a href="https://apt.llvm.org/llvm.sh">https://apt.llvm.org/llvm.sh</a>)”</p>
<p>To install a specific version of LLVM:<br>
wget <a href="https://apt.llvm.org/llvm.sh">https://apt.llvm.org/llvm.sh</a><br>
chmod +x <a href="http://llvm.sh">llvm.sh</a><br>
sudo ./llvm.sh <version number></version></p>
</blockquote>
<h2 id="安装最新稳定版llvm"><a class="markdownIt-Anchor" href="#安装最新稳定版llvm"></a> 安装最新稳定版LLVM</h2>
<p>在ubuntu命令终端执行以下命令，将会运行官网上的llvm.sh这个shell脚本，自动给你安装最新的稳定版本的llvm了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(wget -O - https://apt.llvm.org/llvm.sh)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="安装特定版llvm"><a class="markdownIt-Anchor" href="#安装特定版llvm"></a> 安装特定版LLVM</h2>
<p>假如我们想用老的版本的话，我们也可以指明某个特定的版本进行安装，在ubuntu命令终端执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh &lt;version number&gt;</span><br></pre></td></tr></table></figure>
<p>其中，&lt;version number&gt;需要替换成你想安装的那个版本的版本号。例如，假如我们想安装13版本的LLVM时，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh 13</span><br></pre></td></tr></table></figure>
<h1 id="使用包管理器安装"><a class="markdownIt-Anchor" href="#使用包管理器安装"></a> 使用包管理器安装</h1>
<p>使用包管理器安装，我们需要先修改<code>/etc/apt/source.list</code>，参考以下<a href="https://apt.llvm.org/">官方内容</a>，我们需要先在<code>/etc/apt/source.list</code>加入以下内容，<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-15-09.png" alt="2021-12-09-00-15-09"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">12</span></span><br><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal-12 main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-12 main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">13</span></span><br><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal-13 main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-13 main</span><br></pre></td></tr></table></figure>
<p>加上以上内容后，我们有三种方法可以安装LLVM。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<p>执行以下shell命令，执行后将会安装LLVM release 13。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LLVM</span></span><br><span class="line">apt install libllvm-13-ocaml-dev libllvm13 llvm-13 llvm-13-dev llvm-13-doc llvm-13-examples llvm-13-runtime</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clang and co</span></span><br><span class="line">apt install clang-13 clang-tools-13 clang-13-doc libclang-common-13-dev libclang-13-dev libclang1-13 clang-format-13 python-clang-13 clangd-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libfuzzer</span></span><br><span class="line">apt install libfuzzer-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lldb</span></span><br><span class="line">apt install lldb-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lld (linker)</span></span><br><span class="line">apt install lld-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libc++</span></span><br><span class="line">apt install libc++-13-dev libc++abi-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenMP</span></span><br><span class="line">apt install libomp-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libclc</span></span><br><span class="line">apt install libclc-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libunwind</span></span><br><span class="line">apt install libunwind-13-dev</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<p>参考官网，执行以下shell命令，执行后将会为我们安装最新版本的LLVM（当前版本为version 14）<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-40-49.png" alt="2021-12-09-00-40-49"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install clang-format clang-tidy clang-tools clang clangd libc++-dev libc++1 libc++abi-dev libc++abi1 libclang-dev libclang1 liblldb-dev libllvm-ocaml-dev libomp-dev libomp5 lld lldb llvm-dev llvm-runtime llvm python-clang</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<p>这种方法是用来安装特定稳定版本的LLVM的，参考官网。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-42-26.png" alt="2021-12-09-00-42-26"><br>
以安装13版本为例，首先我们需要获取文档签名，执行以下shell命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421</span></span><br></pre></td></tr></table></figure>
<p>获取签名后，我们就可以安装LLVM了。假如我们只想安装其中的clang，lld和lldb库(13 release)，我们可以执行以下shell命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install clang-13 lldb-13 lld-13</span><br></pre></td></tr></table></figure>
<p>假如我们想安装所有的关键的库，那就不要执行上述命令，而是执行以下shell命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LLVM</span></span><br><span class="line">apt-get install libllvm-13-ocaml-dev libllvm13 llvm-13 llvm-13-dev llvm-13-doc llvm-13-examples llvm-13-runtime</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clang and co</span></span><br><span class="line">apt-get install clang-13 clang-tools-13 clang-13-doc libclang-common-13-dev libclang-13-dev libclang1-13 clang-format-13 python-clang-13 clangd-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libfuzzer</span></span><br><span class="line">apt-get install libfuzzer-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lldb</span></span><br><span class="line">apt-get install lldb-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lld (linker)</span></span><br><span class="line">apt-get install lld-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libc++</span></span><br><span class="line">apt-get install libc++-13-dev libc++abi-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenMP</span></span><br><span class="line">apt-get install libomp-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libclc</span></span><br><span class="line">apt-get install libclc-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libunwind</span></span><br><span class="line">apt-get install libunwind-13-dev</span><br></pre></td></tr></table></figure>
<h1 id="使用预编译二进制文件安装"><a class="markdownIt-Anchor" href="#使用预编译二进制文件安装"></a> 使用预编译二进制文件安装</h1>
<h2 id="下载文件"><a class="markdownIt-Anchor" href="#下载文件"></a> 下载文件</h2>
<p>接下来介绍方法三，使用预编译二进制文件安装。顾名思义，预编译二进制文件就是说别人已经帮你编译好LLVM工程，生成了二进制文件，你所需的只是将其下载下来，然后放到合适的位置，就可以使用了。从哪里下载LLVM预编译二进制文件呢？这里我提供两个可选的地址。一个是<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-13.0.0">官方Github仓库</a>，LLVM项目组已经将他们的工程放到了这个Github仓库里了，我们只要从里面下载<code>clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</code>(假如你的操作系统是ubuntu20.04版本的话)或者<code>clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-16.04.tar.xz</code>(假如你的操作系统是ubuntu16.04版本的话)，将其下载到ubuntu系统本地即可。由于国内访问Github网速较慢，而我们所下载的压缩文件大小为500MB左右，为了节省时间起见，我个人建议从另一个地址下载，那就是国内的<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/llvm/llvm-project/LatestRelease/">清华镜像源</a>。</p>
<h2 id="安装文件"><a class="markdownIt-Anchor" href="#安装文件"></a> 安装文件</h2>
<p>下载好二进制文件到ubuntu系统本地后，我们需要先将文件解压，然后再安装。先解压文件，解压的命令如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xz -d clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz #此处你下载的包是clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz，这里是第一步解压</span><br><span class="line">tar -xvf clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz #此处已经是上一步解压完了，文件夹里剩下的是.tar文件</span><br></pre></td></tr></table></figure>
<p>然后再将解压后文件夹下的5个文件夹（bin,include,share,lib,libexec）及里面的所有文件全部复制到/usr/local目录下即可，复制命令如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/* /usr/local/ #此处的*代表这个目录下的五个文件都要被复制</span><br></pre></td></tr></table></figure>
<p>也可以一个一个文件夹地复制，命令如下。注意，如果/usr/local/没有对应的文件夹(e.g. libexec)时，需要先创建该文件夹，然后再复制解压到对应文件夹里面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/bin/* /usr/local/bin/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/include/* /usr/local/include/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/share/* /usr/local/share/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/lib/* /usr/local/lib/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/libexec/* /usr/local/libexec/ #此处的*代表这个目录下的五个文件都要被复制</span><br></pre></td></tr></table></figure>
<p>完成以上步骤后，我们就可以使用clang了，先测试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang --version</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-04-17-16-26.png" alt="2021-12-04-17-16-26"><br>
可以看到，我们已经成功安装clang，版本为13.0.0，接下来就可以愉快地使用了。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>总结来说，就是执行以下命令,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不从Github下载，而是从清华镜像源下载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo wget https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span></span><br><span class="line">sudo wget https://mirrors.tuna.tsinghua.edu.cn/github-release/llvm/llvm-project/LatestRelease/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span><br><span class="line">sudo tar xvf clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span><br><span class="line">sudo mv clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04 llvm</span><br><span class="line">export PATH=&quot;$PATH:/usr/local/llvm/bin&quot;</span><br></pre></td></tr></table></figure>
<h1 id="本地编译安装llvm"><a class="markdownIt-Anchor" href="#本地编译安装llvm"></a> 本地编译安装LLVM</h1>
<h2 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h2>
<p>下面介绍方法四，在安装前，需要先安装以下工具，这些工具会在编译LLVM工程过程中使用到，参考<a href="https://llvm.org/docs/GettingStarted.html">官网</a>说明：<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-03-12.png" alt="2021-12-10-14-03-12"></p>
<ul>
<li>CMake &gt;= 3.13.4</li>
<li>GCC &gt;= 5.1.0</li>
<li>Python &gt;= 3.6</li>
<li>zlib &gt;= 1.2.3.4</li>
<li>GNU Make &gt;= 3.79</li>
<li>Ninja &gt;= 1.10.0</li>
</ul>
<p>在ubuntu系统上<a href="https://zhuanlan.zhihu.com/p/321882707">安装Ninja</a>和<a href="https://blog.csdn.net/lj402159806/article/details/76408597">安装CMake</a>非常简单，执行以下命令即可，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build</span><br><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure>
<h2 id="下载llvm源文件"><a class="markdownIt-Anchor" href="#下载llvm源文件"></a> 下载LLVM源文件</h2>
<p>下载LLVM工程源文件到本地，然后在本地编译，再安装。首先我们需要下载LLVM工程源代码，这里我们可以选择从官方Github仓库下载或者是从清华镜像源下载，个人建议从清华镜像源下载，因为这样会快很多。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/llvm/llvm-project.git #地址一，从官方Github仓库下载</span><br><span class="line">git clone https://mirrors.tuna.tsinghua.edu.cn/git/llvm-project.git #地址二，从清华镜像源下载</span><br></pre></td></tr></table></figure>
<p>下载完成后可以看到llvm-project文件夹了。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-11-04.png" alt="2021-12-10-14-11-04"></p>
<h2 id="配置llvm"><a class="markdownIt-Anchor" href="#配置llvm"></a> 配置LLVM</h2>
<p>下载完LLVM项目源文件后，下一步就是编译这些源文件了。这里推荐使用Ninja来编译，速度会快很多，当然也可以使用其他编译系统生成工具，比如Unix Makefiles等。在使用Ninja进行编译之前，我们还需要生成编译过程所需编译文件，这些文件会告诉Ninja如何对LLVM-project进行编译。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-17-16.png" alt="2021-12-10-14-17-16"><br>
运行以下shell命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project #cd进入llvm-project文件夹</span><br><span class="line">mkdir build #在llvm-project文件夹创建build文件夹</span><br><span class="line">cd build #cd进入build文件夹</span><br><span class="line">cmake -G Ninja ../llvm #在当前目录(build)生成Ninja编译过程所需的文件，cmake的源文件目录为llvm-project下的llvm文件夹</span><br></pre></td></tr></table></figure>
<p>上面的第四条命令，格式为<code>cmake -G &lt;generator&gt; [options] ../llvm</code>,这里的generator我选择的是Ninja。options则表示可选的选项，常用的有<code>-DLLVM_ENABLE_PROJECTS</code>，表示除了LLVM，你还想编译哪些LLVM子项目。比如，如果除了LLVM外，你还想编译Clang，libcxx和libcxxabi，那么你可以使用编译选项<code>-DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot;</code>，上述的第四条命令就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; ../llvm </span><br></pre></td></tr></table></figure>
<p>也可以不运行上面的shell命令，而是运行下面的shell命令（参考<a href="https://github.com/llvm/llvm-project">官网指导</a>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project #cd进入llvm-project文件夹</span><br><span class="line">mkdir build #在llvm-project文件夹创建build文件夹</span><br><span class="line">cmake -S llvm -B build -G Ninja #对llvm文件夹下的源文件进行cmake，生成的文件放在build目录下，生成的文件将在Ninja编译过程使用</span><br></pre></td></tr></table></figure>
<p>上面的第三条命令，格式为<code>cmake -S llvm -B build -G &lt;generator&gt; [options]</code>,-S表示cmake的源文件所在文件夹，这里是llvm。-B表示cmake后生成的文件所在的文件夹，这里是build文件夹。-G表示将要使用这些生成的cmake文件来编译的工具，这里是Ninja。如果不清楚这些cmake短选项的含义的话，可以<code>cmake -help</code>查看一下帮助。后面的<code>[options]</code>则表示其它的cmake选项，常用的有<code>-DLLVM_ENABLE_PROJECTS='...'</code>，具体含义如前所述。假如我们除了llvm子项目以外，还想编译其它的子项目，比如Clang，libcxx，libcxxabi，那我们可以使用<code>-DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</code>选项，上面第三条shell命令就是:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-45-31.png" alt="2021-12-10-14-45-31"><br>
cmake完成后可以看到编译文件已被写到build文件夹下。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-15-01-48.png" alt="2021-12-10-15-01-48"></p>
<h2 id="编译llvm"><a class="markdownIt-Anchor" href="#编译llvm"></a> 编译LLVM</h2>
<p>生成Ninja编译LLVM所需的文件后，下一步就是编译llvm了，参考<a href="https://github.com/llvm/llvm-project">官网</a>，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p>上述命令的格式为<code>cmake --build build [-- [options] &lt;target&gt;]</code>，–build指明编译后文件写入的文件夹，这里是build文件夹。–target选项指明所使用的编译工具，假如安装了Ninja的话，默认的target是Ninja。也可以输入以下命令，显式地调用Ninja:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">ninja -j 8</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-12-39-32.png" alt="2021-12-11-12-39-32"><br>
在编译到第3257个文件的时候，可能会发生如下错误：<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-19-07-48.png" alt="2021-12-10-19-07-48"><br>
原因是因为我的GCC版本太低了，还是9.3.0版本。根据<a href="https://reviews.llvm.org/rGac7031b2b2fa">网上的说法</a>，升级到11.2.0版（也是当前的最新版）就可以解决这个问题了，因此，需要<a href="https://yang-yuke.github.io/2021/12/10/install-latest-gcc/">升级GCC到最新版</a>。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-19-05-59.png" alt="2021-12-10-19-05-59"><br>
在升级到最新版GCC后，再重复上面的编译命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</span><br><span class="line">cd build</span><br><span class="line">ninja -j 8</span><br></pre></td></tr></table></figure>
<p>依然出现了大量以下错误，<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-24-36.png" alt="2021-12-11-16-24-36"><br>
这些错误是在编译libcxxabi库的cpp文件时出现的，说明有可能是我们在cmake配置编译的时候出了问题，回到<a href="https://llvm.org/docs/GettingStarted.html">LLVM官网Get started页面</a>，发现与<a href="https://github.com/llvm/llvm-project">LLVM Github Get started</a>上对<code>DLLVM_ENABLE_PROJECTS</code>编译选项的细节描述有点出入，<code>&quot;libcxx;libcxxabi&quot;</code>应该要放到<code>DLLVM_ENABLE_RUNTIMES</code>编译选项里，而不是<code>DLLVM_ENABLE_PROJECTS</code>里面。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-29-07.png" alt="2021-12-11-16-29-07"><br>
于是，重新进行cmake配置和编译，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot;</span><br><span class="line">cd build</span><br><span class="line">ninja -j8</span><br></pre></td></tr></table></figure>
<p>此时，发现能够继续往下编译了，但是每编译十几个cpp文件后就会出现以下错误“fatal error: ld terminated with signal 9 [Killed]”，然后就停止了。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-32-11.png" alt="2021-12-11-16-32-11"><br>
查了一下，<a href="https://stackoverflow.com/questions/65633304/not-able-to-build-llvm-from-its-source-code">这里</a>提到有可能是因为内存不足所致的，于是重新配置并编译，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; -DLLVM_PARALLEL_LINK_JOBS=1</span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-38-00.png" alt="2021-12-11-18-38-00"><br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-38-29.png" alt="2021-12-11-18-38-29"><br>
上述命令中，<code>-DCMAKE_BUILD_TYPE=Release</code>表示编译的版本是release版本，release版本要小很多，如果不指明的话编译的就是debug版本。<code>-DLLVM_PARALLEL_LINK_JOBS=1</code>表示不开parallel build。等待一段时间后，可以看到这一次可以完全编译所有的文件了。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-42-53.png" alt="2021-12-11-18-42-53"><br>
编译完成后，需要切换到root用户进行安装，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build #cd进入llvm-project/build文件夹</span><br><span class="line">sudo su root #切换到root用户权限</span><br><span class="line">ninja install #安装llvm</span><br></pre></td></tr></table></figure>
<p>安装完成后，可以看到clang已被安装到<code>/usr/local/bin</code>路径下，说明安装已经成功。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-13-22-17-01.png" alt="2021-12-13-22-17-01"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://blog.csdn.net/zerolord/article/details/116891720">Ubuntu20.04安装llvm</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-project.git/">LLVM Git 源码仓库镜像使用帮助</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102028114">LLVM概述——介绍与安装</a></li>
<li><a href="https://apt.llvm.org/">LLVM Debian/Ubuntu nightly packages</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/321882707">Ninja安装和基本使用</a></li>
<li><a href="https://blog.csdn.net/lj402159806/article/details/76408597">ubuntu安装CMake的几种方式</a></li>
<li><a href="https://llvm.org/docs/GettingStarted.html">Getting Started with the LLVM System</a></li>
<li><a href="https://github.com/llvm/llvm-project">Getting Started with the LLVM System(github)</a></li>
<li><a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch01.html">第1章 编译和安装LLVM</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04编译lldb-mi</title>
    <url>/2021/12/28/compile-lldb-mi/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>lldb-mi(lldb machine interface)是一个C/C<ins>调试器，原来是LLVM项目中lldb的一部分，但是由于长时间没有人维护和更新，于是是从LLVM项目的lldb中分了出去，成为单独的一个工程。在linux环境下，使用vscode对C/C</ins>代码进行调试时，常用的调试器是GDB，除此之外，还有个选择就是lldb-mi。本文将介绍如何在本地对lldb-mi工程源码进行编译，从而生成可执行文件。编译lldb-mi，需要一个C++14编译器以及LLDB，而LLDB又依赖于Clang和LLVM，因此，在编译lldb-mi之前，需要先安装Clang，LLVM和LLDB，可以参考<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/">这篇博客</a>进行安装。</p>
<span id="more"></span>
<h1 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h1>
<p>输入以下命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ #进入home目录</span><br><span class="line">mkdir buildspace #在home目录下建立buildspace目录</span><br><span class="line">cd ~/buildspace #进入buildspace目录</span><br><span class="line">mkdir llvm-inst #创建llvm-inst目录</span><br><span class="line">git clone https://github.com/lldb-tools/lldb-mi #将lldb-mi工程下载到当前目录（即buildspace目录）</span><br><span class="line">cd lldb-mi #进入lldb-mi工程目录里</span><br><span class="line">mkdir build #在当前目录（即lldb-mi目录）建立build目录，用来存放编译后生成的文件</span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=~/buildspace/llvm-inst/ -GNinja .. #在当前目录（即build目录）的上一级目录（即lldb-mi目录）下生成cmake文件</span><br><span class="line">ninja #编译</span><br></pre></td></tr></table></figure>
<p>执行完以上命令后，可以看到，所生成的lldb-mi可执行文件将位于lldb-mi/build/src目录下，这个就是lldb-mi调试器。然后，我们就可以开始在vscode中使用这个调试器对程序进行调试了。<br>
<img src="/2021/12/28/compile-lldb-mi/2021-12-29-00-49-15.png" alt="2021-12-29-00-49-15"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://github.com/lldb-tools/lldb-mi">Building against custom LLDB</a></li>
<li><a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/">在ubuntu20.04安装LLVM</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
        <tag>lldb-mi</tag>
        <tag>调试器</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04安装最新版GCC</title>
    <url>/2021/12/10/install-latest-gcc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#more">编译LLVM</a>过程中，出现了很多头文件无法解析的错误，根据<a href="https://reviews.llvm.org/rGac7031b2b2fa">网上的说法</a>，原因是因为GCC版本过低，将GCC升级至最新版11.2.0就可以解决这个问题了。本文将介绍如何升级GCC到最新版(当前为11.2.0)。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-33-08.png" alt="2021-12-10-23-33-08"></p>
<span id="more"></span>
<h1 id="下载gcc最新源码包"><a class="markdownIt-Anchor" href="#下载gcc最新源码包"></a> 下载gcc最新源码包</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.gz</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-19-24-58.png" alt="2021-12-10-19-24-58"></p>
<h1 id="解压缩"><a class="markdownIt-Anchor" href="#解压缩"></a> 解压缩</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf gcc-11.2.0.tar.gz</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-19-27-42.png" alt="2021-12-10-19-27-42"></p>
<h1 id="进入解压缩目录"><a class="markdownIt-Anchor" href="#进入解压缩目录"></a> 进入解压缩目录</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gcc-11.2.0</span><br></pre></td></tr></table></figure>
<h1 id="运行预备库下载脚本"><a class="markdownIt-Anchor" href="#运行预备库下载脚本"></a> 运行预备库下载脚本</h1>
<p>运行download_prerequisites脚本,这个脚本会自动帮你下载所需要的依赖文件和库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
<p>在运行该脚本时，出现以下错误，无法下载依赖文件库<code>gmp-6.1.0.tar.bz2</code>。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-37-55.png" alt="2021-12-10-19-37-55"><br>
解决办法为改从清华镜像源下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gmp/gmp-6.1.0.tar.bz2 #从清华镜像源下载gmp-6.1.0.tar.bz2文件</span><br><span class="line">tar xvfj gmp-6.1.0.tar.bz2 #解压缩文件</span><br><span class="line">ln -s gmp-6.1.0 gmp #在当前目录下创建名为gmp的快捷方式，链接到gmp-6.1.0文件夹</span><br></pre></td></tr></table></figure>
<p>改从清华镜像源下载后速度真的很快。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-44-43.png" alt="2021-12-10-19-44-43"><br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-45-18.png" alt="2021-12-10-19-45-18"><br>
继续执行脚本下载依赖文件，出现以下错误，无法下载依赖文件库<code>mpfr-3.1.6.tar.bz2</code>。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-50-42.png" alt="2021-12-10-19-50-42"><br>
解决办法为改从清华镜像源下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpfr/mpfr-3.1.6.tar.bz2 #从清华镜像源下载mpfr-3.1.6.tar.bz2文件</span><br><span class="line">tar xvfj mpfr-3.1.6.tar.bz2 #解压缩文件</span><br><span class="line">ln -s mpfr-3.1.6 mpfr #在当前目录下创建名为mpfr的快捷方式，链接到mpfr-3.1.6文件夹</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-19-54-01.png" alt="2021-12-10-19-54-01"><br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-54-59.png" alt="2021-12-10-19-54-59"><br>
继续执行脚本下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
<p>出现以下错误，无法下载<code>mpc-1.0.3.tar.gz</code>文件，<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-20-04-14.png" alt="2021-12-10-20-04-14"><br>
解决办法为改从清华镜像源下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpc/mpc-1.0.3.tar.gz</span><br><span class="line">tar xvfz mpc-1.0.3.tar.gz</span><br><span class="line">ln -s mpc-1.0.3 mpc #在当前目录下创建名为mpc的快捷方式，链接到mpc-1.0.3文件夹</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-20-07-46.png" alt="2021-12-10-20-07-46"><br>
继续执行下载脚本，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
<p>出现以下错误，无法下载<code>isl-0.18.tar.bz2</code>文件，<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-20-23-02.png" alt="2021-12-10-20-23-02"><br>
因为这个文件在清华镜像源上没有，因此解决办法为从GNU官网通过http下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2</span><br><span class="line">tar xvfj isl-0.18.tar.bz2</span><br><span class="line">ln -s isl-0.18 isl</span><br></pre></td></tr></table></figure>
<h1 id="创建编译目录"><a class="markdownIt-Anchor" href="#创建编译目录"></a> 创建编译目录</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir gcc-build</span><br><span class="line">cd $_</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-20-30-04.png" alt="2021-12-10-20-30-04"></p>
<h1 id="生成makefile文件"><a class="markdownIt-Anchor" href="#生成makefile文件"></a> 生成Makefile文件</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib #../configure表示返回上级目录执行configure命令</span><br></pre></td></tr></table></figure>
<p><code>–enable-languages</code>表示你要让你的gcc支持那些语言，<code>–disable-multilib</code>表示不生成编译为其他平台可执行代码的交叉编译器。<code>–disable-checking</code>表示生成的编译器在编译过程中不做额外检查，也可以使用<code>–enable-checking=xxx</code>来增加一些检查。</p>
<h1 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>这里-j8表示的是使用8核进行编译，因为我的电脑CPU为8核。因为make默认是serial build的，如果不加-j选项，就不会开启多核parallel build，这样的话速度会慢很多，所以这里我开启了8核编译。即便如此，这一步花费时间也非常长，我在虚拟机里用了将近两个小时完成这一步，而且虚拟机一定要留出至少20GB的空间，不然可能会出现磁盘不足的问题。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-20-38-17.png" alt="2021-12-10-20-38-17"></p>
<h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su root #安装GCC需要root权限，这里先切换为root用户</span><br><span class="line">make install #安装</span><br><span class="line">source /etc/profile #安装完成后手动刷新一下profile</span><br><span class="line">gcc -v #检查当前gcc版本</span><br></pre></td></tr></table></figure>
<p>可以看到，当前的gcc版本更新到了11.2.0，至此安装成功。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-22-35-17.png" alt="2021-12-10-22-35-17"></p>
<h1 id="环境变量设置"><a class="markdownIt-Anchor" href="#环境变量设置"></a> 环境变量设置</h1>
<p>在安装GCC完成后，可以将其永久地加入到系统路径中，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su yukeyang #这里yukeyang替换成你的用户名，先从root用户切换回超级用户</span><br><span class="line">cd ~/ #cd进入当前用户(我的是yukeyang)的home目录</span><br><span class="line">code .bashrc #用vscode打开.bashrc文件</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-22-46-15.png" alt="2021-12-10-22-46-15"><br>
GCC可执行程序所在路径为：<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-24-28.png" alt="2021-12-10-23-24-28"><br>
因此，将以下两行加入到.bashrc文件中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/bin:$PATH #设置GCC可执行程序路径</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib64:$LD_LIBRARY_PATH #设置动态链接库路径</span><br></pre></td></tr></table></figure>
<p>至此就完成了所有步骤了，更多的环境变量设置，可以参考<a href="https://www.cnblogs.com/jessepeng/p/11674780.html">这篇博客</a>。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-26-40.png" alt="2021-12-10-23-26-40"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1532384">centos 编译安装gcc8.1</a></li>
<li><a href="https://solarianprogrammer.com/2016/10/07/building-gcc-ubuntu-linux/">Building GCC 10 on Ubuntu Linux</a></li>
<li><a href="https://blog.csdn.net/21aspnet/article/details/105708122">安装最新的GCC</a></li>
<li><a href="https://www.cnblogs.com/jessepeng/p/11674780.html">[Linux] 非root安装GCC9.1.0</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>双口RAM及其VIVADO的IP核的使用</title>
    <url>/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="双口ram概述"><a class="markdownIt-Anchor" href="#双口ram概述"></a> 双口RAM概述</h1>
<p>双口RAM（dual port RAM）在异构系统中应用广泛，通过双口RAM，不同硬件架构的芯片可以实现数据的交互，从而实现通信。例如，一般情况下，ARM与DSP之间的通信，可以利用双口RAM实现，ARM通过EBI总线连接到双口RAM的A口，DSP通过EMIF总线（也可以是uPP总线，取决于速度需求）连接到双口RAM的B口，两者对同一块存储区域进行操作，即可实现两者的数据交互。</p>
<span id="more"></span>
<p>但是，因为双口RAM的A口和B口都可以对相同的内存地址进行操作，这就引出了一个问题——假如通信双方在两个端口对同一地址同时读写，就会引发冲突。要解决这个问题，办法有二。一是通信双方在时序上保证不会同时读写同一地址，将ARM和DSP可写地址范围进行分区，无论任何一方写完数据后都通过IO发送中断通知对方，对方进行数据读取（乒乓RAM操作），这样是比较可靠的；另外一个办法就是在fpga里设置写busy信号，实现两端写同步<a href="http://blog.csdn.net/DanielLee_ustb/article/details/46446359">1</a>。在FPGA中，构建双口RAM可以通过两种方法，一种是利用distributed RAM构建，另一种是利用Block RAM构建，关于两者的具体区别，可以参考这两篇文章<a href="http://blog.csdn.net/yzy19900402/article/details/45025901">2</a><a href="http://blog.csdn.net/jbb0523/article/details/6533760">3</a>。简而言之，Block RAM是是使用FPGA中的整块双口RAM资源，而distributed RAM则是用FPGA中的逻辑资源拼凑形成的。一般的原则是，较大的存储应用，建议用bram；零星的小ram，一般就用dram。</p>
<p>在Vivado中，RAM IP核在Memories &amp; Strorage Elements\RAM &amp; ROMs和RAM &amp; ROMs &amp; BRAM文件夹下，如图所示，下面简要介绍一下Vivado的双口RAM IP核。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-23-22.png#pic_center" alt="图1.1" title="图1.1"></p>
<h1 id="vivado-双口ram-ip核"><a class="markdownIt-Anchor" href="#vivado-双口ram-ip核"></a> Vivado 双口RAM IP核</h1>
<h2 id="block-memory-generator概述"><a class="markdownIt-Anchor" href="#block-memory-generator概述"></a> Block Memory Generator概述</h2>
<p>点击图1.1的Block Memory Generator项，利用BRAM来构建双口RAM。Block Memory Generator窗口如图2.1所示。图中，第1部分，在IP symbol选项卡，点击&quot;+&quot;号可以展开端口具体信号，如图2.2所示。第2部分，Component Name可以设置IP核的名字。第3部分，Basic选项卡，在Memory Type下拉列表中，可以设置内存的类型，如图2.3所示。Block Memory Gnerator一共可以产生5种不同类型的内存空间，其中block RAM有三种：单口RAM、简化双口RAM和真双口RAM<a href="https://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_2/pg058-blk-mem-gen.pdf">4</a>。单口RAM只有一个端口（A端口），可以对A端口进行读写。简化双口RAM有两个端口（A和B端口），但是A端口只能进行写入操作，不能进行读出操作，而B端口则只能进行读出操作，不能进行写入操作。真双口RAM有两个端口（A和B端口），A和B端口都能进行读写操作<a href="http://blog.csdn.net/c602273091/article/details/39694145">5</a>。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-24-16.png#pic_center" alt="图2.1" title="图2.1"><br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-24-48.png#pic_center" alt="图2.2" title="图2.2"><br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-25-15.png#pic_center" alt="图2.3" title="图2.3"></p>
<h2 id="真双口ram的设置"><a class="markdownIt-Anchor" href="#真双口ram的设置"></a> 真双口RAM的设置</h2>
<h3 id="basic设置"><a class="markdownIt-Anchor" href="#basic设置"></a> Basic设置</h3>
<p><img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-25-36.png#pic_center" alt="图2.4" title="图2.4"></p>
<h3 id="port设置"><a class="markdownIt-Anchor" href="#port设置"></a> Port设置</h3>
<p>点击Port A Options选项卡，对A端口进行设置， 设置Write Width为16（即RAM单元为16位），Write Width为1024（即内存深度为1024，该端口可读写的RAM单元有1024个），Operating Mode（操作模式）一共有三种：Write First，Read First，No Change。在Write First模式中，在一个时钟周期里，写入内存单元的数据被同步输出到输出数据总线上；在Read First模式中，在一个时钟周期里，写入到内存单元的数据是当前输入数据总线上的数据，而输出到输出数据总线上的数据则是上一个时钟周期存储在内存单元中的数据。细节可参考PG058的49到50页4。Enable Port Type设置为Always Enabled，一直使能端口A。其它设置使用默认设置。如图2.5所示。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-26-04.png#pic_center" alt="图2.5" title="图2.5"><br>
端口B设置为与A一致。在Other Options选项卡中，保留默认设置。Load Init File设置是否用Coe文件对内存区域初始化，这个在初始化ROM的时候会用到，这里不勾选，保持默认。最后，在Summary选项卡会显示消耗的资源。</p>
<h1 id="双口ram例程"><a class="markdownIt-Anchor" href="#双口ram例程"></a> 双口RAM例程</h1>
<p>​例程1，该例程是Altera官方例程<a href="https://www.altera.com.cn/support/support-resources/design-examples/design-software/verilog/ver-true-dual-port-ram-sclk.html">6</a>，采用寄存器构建双口RAM，代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> true_dpram_sclk</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data_a, data_b,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>:<span class="number">0</span>] addr_a, addr_b,</span><br><span class="line">    <span class="keyword">input</span> we_a, we_b, clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] q_a, q_b</span><br><span class="line">);</span><br><span class="line">    <span class="comment">// Declare the RAM variable</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] ram[<span class="number">63</span>:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Port A</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (we_a) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            ram[addr_a] &lt;= data_a;</span><br><span class="line">            q_a &lt;= data_a;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q_a &lt;= ram[addr_a];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Port B</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (we_b)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            ram[addr_b] &lt;= data_b;</span><br><span class="line">            q_b &lt;= data_b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q_b &lt;= ram[addr_b];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>例程2，该例程是Xilinx官方例程<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_4/ug901-vivado-synthesis.pdf">7</a>，采用寄存器构建真双口RAM，代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dual-Port Block RAM with Two Write Ports</span></span><br><span class="line"><span class="comment">// File: rams_16.v</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> v_rams_16 (clka,clkb,ena,enb,wea,web,addra,addrb,dia,dib,doa,dob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clka,clkb,ena,enb,wea,web;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">9</span>:<span class="number">0</span>] addra,addrb;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] dia,dib;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] doa,dob;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] ram [<span class="number">1023</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">15</span>:<span class="number">0</span>] doa,dob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clka) <span class="keyword">begin</span> <span class="keyword">if</span> (ena)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">if</span> (wea)</span><br><span class="line"> ram[addra] &lt;= dia;</span><br><span class="line"> doa &lt;= ram[addra];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clkb) <span class="keyword">begin</span> <span class="keyword">if</span> (enb)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">if</span> (web)</span><br><span class="line"> ram[addrb] &lt;= dib;</span><br><span class="line"> dob &lt;= ram[addrb];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>​例程3，该例程是网友博客中的例程<a href="http://blog.csdn.net/yanglong890124/article/details/32742297">8</a>，代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TOP(  </span><br><span class="line"><span class="keyword">input</span> USER_CLK  </span><br><span class="line">    );  </span><br><span class="line">  </span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DLY #1  </span></span><br><span class="line"><span class="keyword">reg</span> FPGA_Enable=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] FPGA_Write_Enable=<span class="number">4&#x27;h0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Address=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Write_Data=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data_reg=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">10</span>:<span class="number">0</span>] count=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> USER_CLK)  </span><br><span class="line"><span class="keyword">begin</span>  </span><br><span class="line">    count &lt;= count + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;=<span class="number">100</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;h0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">105</span>)&amp;&amp;(count &gt;<span class="number">100</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;hf</span>;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= FPGA_Write_Data + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">110</span>)&amp;&amp;(count &gt;<span class="number">105</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;h0</span>;  </span><br><span class="line">        FPGA_Address &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">117</span>)&amp;&amp;(count &gt;<span class="number">110</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;h0</span>;  </span><br><span class="line">        FPGA_Read_Data_reg &lt;= FPGA_Read_Data;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">118</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        count &lt;= count;  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line">BBBB your_instance_name (  </span><br><span class="line">  <span class="variable">.clka</span>(USER_CLK), <span class="comment">// input clka  </span></span><br><span class="line">  <span class="variable">.ena</span>(FPGA_Enable), <span class="comment">// input ena  </span></span><br><span class="line">  <span class="variable">.wea</span>(FPGA_Write_Enable), <span class="comment">// input [3 : 0] wea  </span></span><br><span class="line">  <span class="variable">.addra</span>(FPGA_Address), <span class="comment">// input [31 : 0] addra  </span></span><br><span class="line">  <span class="variable">.dina</span>(FPGA_Write_Data), <span class="comment">// input [31 : 0] dina  </span></span><br><span class="line">  <span class="variable">.douta</span>(FPGA_Read_Data), <span class="comment">// output [31 : 0] douta  </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="variable">.clkb</span>(clkb), <span class="comment">// input clkb  </span></span><br><span class="line">  <span class="variable">.enb</span>(enb), <span class="comment">// input enb  </span></span><br><span class="line">  <span class="variable">.web</span>(web), <span class="comment">// input [3 : 0] web  </span></span><br><span class="line">  <span class="variable">.addrb</span>(addrb), <span class="comment">// input [31 : 0] addrb  </span></span><br><span class="line">  <span class="variable">.dinb</span>(dinb), <span class="comment">// input [31 : 0] dinb  </span></span><br><span class="line">  <span class="variable">.doutb</span>(doutb) <span class="comment">// output [31 : 0] doutb  </span></span><br><span class="line">);  </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>​该例程中，在count为101（&gt;100）后开始往地址4到20写入1-5，然后在count为111（&gt;110）的时候读出写入的数据。</p>
<h1 id="仿真"><a class="markdownIt-Anchor" href="#仿真"></a> 仿真</h1>
<p>下面利用Modelsim和Vivado进行联合仿真，关于vivado如何与modelsim进行联合仿真可以参考这篇文章：</p>
<p><a href="http://blog.chinaaet.com/crazybird/p/5100000539">vivado与modelsim的关联以及器件库编译</a></p>
<p>有一点要注意的是，我用的是Vivado2017.1版本，这个版本只支持Modelsim10.5及以上的版本，如果是低版本的Modelsim，在用Vivado2017.1编译Modelsim的仿真库时，会出错。Modelsim10.5版本可以在这里下载：</p>
<p><a href="http://bbs.eetop.cn/viewthread.php?tid=629292&amp;extra=&amp;page=1">modelsim 10.5 适用vivado 2017.1</a></p>
<p>用Modelsim仿真时，会在sim_1/behav文件夹下产生3个.do文件，分别是xx_compile.do，xx_simulate.do，xx _wave.do文件。在设计的verilog文件修改之后，如果在Modelsim中直接restart，仿真的其实还是没有修改前的文件，要使修改的.v文件在Modelsim中生效，可以在Modelsim的命令窗口输入do xx_compile.do文件，对仿真的库文件以及设计文件（.v文件）重新编译，然后在输入do xx_simulate.do文件，才能仿真修改后的文件。输入do xx_compile.do命令对设计文件重新编译的时候，Modelsim会强制退出，这时由最后一句force quit命令引起的，只要把它删掉就行了。如果要保存波形文件，可以save format，另存为xx_wave.do文件。</p>
<p>参考上面双口RAM的例程3进行功能仿真，RAM IP使用Write First模式，设计文件代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Company: </span></span><br><span class="line"><span class="comment">// Engineer: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Create Date: 2017/12/09 22:36:48</span></span><br><span class="line"><span class="comment">// Design Name: </span></span><br><span class="line"><span class="comment">// Module Name: dual_port_ram_demo</span></span><br><span class="line"><span class="comment">// Project Name: </span></span><br><span class="line"><span class="comment">// Target Devices: </span></span><br><span class="line"><span class="comment">// Tool Versions: </span></span><br><span class="line"><span class="comment">// Description: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Dependencies: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Revision:</span></span><br><span class="line"><span class="comment">// Revision 0.01 - File Created</span></span><br><span class="line"><span class="comment">// Additional Comments:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dual_port_ram_demo(</span><br><span class="line"><span class="keyword">input</span> USER_CLK</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DLY #1  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Port A declaration</span></span><br><span class="line"><span class="keyword">reg</span> FPGA_Enable=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span> FPGA_Write_Enable=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Address=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Write_Data=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data_reg=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Port B declaration</span></span><br><span class="line"><span class="keyword">reg</span> enb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] web=<span class="number">4&#x27;h0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] addrb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] dinb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">31</span>:<span class="number">0</span>] doutb_reg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">wire</span>[<span class="number">31</span>:<span class="number">0</span>] doutb=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">reg</span>[<span class="number">10</span>:<span class="number">0</span>] count=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> USER_CLK)  </span><br><span class="line"><span class="keyword">begin</span>  </span><br><span class="line">    count &lt;= count + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;=<span class="number">100</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">105</span>)&amp;&amp;(count &gt;<span class="number">100</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= FPGA_Write_Data + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">110</span>)&amp;&amp;(count &gt;<span class="number">105</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Address &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((count &lt;= <span class="number">117</span>)&amp;&amp;(count &gt;<span class="number">110</span>))  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Read_Data_reg &lt;= FPGA_Read_Data;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(count == <span class="number">118</span>)  </span><br><span class="line">    <span class="keyword">begin</span>  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        count &lt;= count;  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line">dpRAM u1 (  </span><br><span class="line">  <span class="variable">.clka</span>(USER_CLK), <span class="comment">// input clka  </span></span><br><span class="line">  <span class="variable">.ena</span>(FPGA_Enable), <span class="comment">// input ena  </span></span><br><span class="line">  <span class="variable">.wea</span>(FPGA_Write_Enable), <span class="comment">// input [3 : 0] wea  </span></span><br><span class="line">  <span class="variable">.addra</span>(FPGA_Address), <span class="comment">// input [31 : 0] addra  </span></span><br><span class="line">  <span class="variable">.dina</span>(FPGA_Write_Data), <span class="comment">// input [31 : 0] dina  </span></span><br><span class="line">  <span class="variable">.douta</span>(FPGA_Read_Data), <span class="comment">// output [31 : 0] douta  </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="variable">.clkb</span>(USER_CLK), <span class="comment">// input clkb  </span></span><br><span class="line">  <span class="variable">.enb</span>(enb), <span class="comment">// input enb  </span></span><br><span class="line">  <span class="variable">.web</span>(web), <span class="comment">// input [3 : 0] web  </span></span><br><span class="line">  <span class="variable">.addrb</span>(addrb), <span class="comment">// input [31 : 0] addrb  </span></span><br><span class="line">  <span class="variable">.dinb</span>(dinb), <span class="comment">// input [31 : 0] dinb  </span></span><br><span class="line">  <span class="variable">.doutb</span>(doutb) <span class="comment">// output [31 : 0] doutb  </span></span><br><span class="line">);  </span><br><span class="line"><span class="keyword">endmodule</span>  </span><br></pre></td></tr></table></figure>
<p>​testbench文件如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Company: </span></span><br><span class="line"><span class="comment">// Engineer: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Create Date: 2017/12/09 22:47:26</span></span><br><span class="line"><span class="comment">// Design Name: </span></span><br><span class="line"><span class="comment">// Module Name: simu</span></span><br><span class="line"><span class="comment">// Project Name: </span></span><br><span class="line"><span class="comment">// Target Devices: </span></span><br><span class="line"><span class="comment">// Tool Versions: </span></span><br><span class="line"><span class="comment">// Description: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Dependencies: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Revision:</span></span><br><span class="line"><span class="comment">// Revision 0.01 - File Created</span></span><br><span class="line"><span class="comment">// Additional Comments:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> simu(</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"><span class="comment">//testbench 时钟信号</span></span><br><span class="line"><span class="keyword">reg</span> clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">always</span> # <span class="number">10</span> clk &lt;= ~clk;</span><br><span class="line"><span class="comment">//调用dual_port_ram_demo模块</span></span><br><span class="line">dual_port_ram_demo demo1(clk);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>仿真结果如下：<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-26-41.png#pic_center" alt="图4.1" title="图4.1"><br>
程序在1时刻准备好地址和要写入RAM的数据，在2时刻写入RAM中，在3时刻端口才会输出2时刻写入RAM的数据，注意与PG058的图稍有不同。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8A%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-27-26.png#pic_center" alt="图4.2" title="图4.2"></p>
<h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1>
<p>关于BRAM，推荐一个youtube视频，里面讲的非常清晰易懂。<br>
<a href="https://www.youtube.com/watch?v=fqUuvwl4QJA">What is a Block RAM in an FPGA?</a></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="http://blog.csdn.net/DanielLee_ustb/article/details/46446359">基于FPGA的双口RAM设计方法</a><br>
[2] <a href="http://blog.csdn.net/yzy19900402/article/details/45025901">关于Xilinx芯片中Block RAM和Distributed RAM 的区别</a><br>
[3] <a href="http://blog.csdn.net/jbb0523/article/details/6533760">Block RAM 和Distributed RAM</a><br>
[4] <a href="https://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_2/pg058-blk-mem-gen.pdf">Block Memory Generator v8.2 LogiCORE IP Product Guide (PG058)</a><br>
[5] <a href="http://blog.csdn.net/c602273091/article/details/39694145">FPGA开发之RAM IP的使用</a><br>
[6] <a href="https://www.altera.com.cn/support/support-resources/design-examples/design-software/verilog/ver-true-dual-port-ram-sclk.html">Verilog HDL：具有单时钟的真双端口RAM</a><br>
[7] <a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_4/ug901-vivado-synthesis.pdf">Vivado Design Suite User Guide: Synthesis (UG901)</a><br>
[8] <a href="http://blog.csdn.net/yanglong890124/article/details/32742297">FPGA 内部双口块RAM 读写实现</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPAG</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币区块结构</title>
    <url>/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>比特币账本是以区块链的形式组织起来的，每个区块以<code>merkle tree</code>的形式记录着多条交易的具体信息， 而区块与区块间则通过哈希指针链接起来，从而实现了对所有历史交易的记录。本文将对比特币区块的所有相关概念进行简介。</p>
<h2 id="-more-"><a class="markdownIt-Anchor" href="#-more-"></a> <span id="more"></span></h2>
<p><code>以下是本篇文章正文内容</code></p>
<h1 id="哈希指针"><a class="markdownIt-Anchor" href="#哈希指针"></a> 哈希指针</h1>
<p>前面提到，比特币区块与区块间是通过哈希指针链接起来的，那么，哈希指针是什么呢？这里介绍一下这个概念。<code>哈希指针(Hash pointer)</code>，顾名思义，是一个带有哈希值的指针。其结构如下图所示，该指针不仅记录了其所指向的数据块的地址，同时也记录了该数据块的哈希值。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-09-48.png#pic_center" alt="2022-06-17-18-09-48"></p>
<h1 id="区块链"><a class="markdownIt-Anchor" href="#区块链"></a> 区块链</h1>
<p>比特币的账本(<code>ledger</code>)是以区块链(<code>block chain</code>)的形式组织起来的，其结构如下图所示。每个区块里包含了一个字段<code>previousblockhash</code>，记录着上一个区块的哈希值。每往区块链里添加一个新的区块时，需要计算上一个区块的哈希值并填入新加的区块的<code>previousblockhash</code>字段中。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-10-34.png#pic_center" alt="2022-06-17-18-10-34"><br>
区块链的这种特殊的结构形式，使得它具有防篡改的属性。那么，区块链是如何体现出其防篡改属性的呢？以下图为例，假如有人恶意篡改了区块1的内容，那么为了保持一致，他必然要对篡改后的区块1的内容重新进行哈希运算，然后将所得到的哈希值填入区块2的<code>previousblockhash</code>字段，而因为区块2的<code>previousblockhash</code>字段改变了，他又不得不对区块2重新进行哈希运算并将得到的哈希值填入区块3的<code>previousblockhash</code>字段 。最终，他将不得不修改区块链链首的哈希指针。只要我们记录了这个指针，那么他将无法篡改这个指针的信息。结果就是，如果我们对最后一个区块(在下面的例子中是区块3)求哈希，那么结果一定和我们所保存的链首哈希指针不一致，从而就可以识别出区块链内容有被人篡改过。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-11-12.png#pic_center" alt="2022-06-17-18-11-12"></p>
<h1 id="merkle-tree"><a class="markdownIt-Anchor" href="#merkle-tree"></a> Merkle tree</h1>
<p>每个比特币区块中记录了多条交易信息，这些交易是以<code>merkle tree</code>的形式组织起来的，如下图所示。首先会对每条交易求哈希，然后对得到的哈希两两配对，再求哈希，然后再将所求得的哈希两两配对，最终，将会得到一个哈希值，这个哈希值就是<code>merkleroot</code>。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-11-52.png#pic_center" alt="2022-06-17-18-11-52"><br>
以<code>merkle tree</code>的形式将区块内的所有交易组织起来，主要有两个好处。</p>
<ol>
<li>防篡改(tamper evident)</li>
<li>验证身份(proof of membership)</li>
</ol>
<h2 id="防篡改"><a class="markdownIt-Anchor" href="#防篡改"></a> 防篡改</h2>
<p>与前面区块链防篡改的机制类似，只要我们记住了<code>merkle tree</code>的根节点的哈希值<code>merkleroot</code>，我们就能防止篡改。具体过程如下，以下图为例，假如有人恶意篡改了交易1的信息，那么为了保持信息一致，他必须沿着交易1所在的分支一直往上，重新计算所有的哈希值，直到根节点。但是，因为我们在本地保存了<code>merkleroot</code>的值，所以攻击者在篡改根节点的其中一个哈希值后，他无法再进一步篡改<code>merkleroot</code>的值了，而我们验证时，只要计算一下根节点的哈希值，然后与本地保存的<code>merkleroot</code>比较一下，就能检测出这个区块的交易信息有被篡改过。所以，在区块链的基础之上，<code>merkle tree</code>进一步加强了防篡改的能力。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-12-44.png#pic_center" alt="2022-06-17-18-12-44"></p>
<h2 id="验证身份"><a class="markdownIt-Anchor" href="#验证身份"></a> 验证身份</h2>
<p><code>merkle tree</code>的另一大优点是通过它可以很轻易地验证一条交易是否属于这个区块。以下图为例，假如某人想证明交易1属于这个区块。与前面一样，我们只需要记住<code>merkleroot</code>。当某人要证明交易1属于这个区块时，他需要给出一条分支，该分支的根节点的哈希值要等于我们所保存的<code>merkleroot</code>，叶子节点则是要证明的交易，下图里是交易1。我们只要沿着这条分支，对路径上所有的哈希值验算一遍，如果得到的所有哈希值都与分支上各个节点所记录的哈希值一致，那么就证明了交易1属于该区块。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-13-16.png#pic_center" alt="2022-06-17-18-13-16"><br>
从上面的例子可以看出，利用<code>merkle tree</code>可以很容易地验证交易1属于这个区块。反过来，要是一个交易不属于该区块，那么也很容易证明。以下图为例，假如某人想将不属于该区块的交易x伪装成属于该区块，那么他必须将这个伪交易插入到<code>merkle tree</code>的某个位置。假如他插入的是交易2的位置，那么在证明交易x属于这个区块时，我们可以要求他出示交易x在<code>merkle tree</code>上的前一个交易和后一个交易以及其所在的分支 。于是，他需要给出下图所示的几个分支，为了保持信息一致，他不得不沿着原来交易2所在的分支，对所有的哈希重新算一遍并进行篡改，而由于我们记住了<code>merkleroot</code>，他无法篡改这个值，所以只要我们对根节点的哈希进行验算，就会发现得到的哈希值与我们保存的<code>merkleroot</code>不一致，从而证明了交易x并不属于这个<code>merkle tree</code>，即不属于这个区块。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-13-48.png#pic_center" alt="2022-06-17-18-13-48"></p>
<h1 id="比特币区块链"><a class="markdownIt-Anchor" href="#比特币区块链"></a> 比特币区块链</h1>
<p>比特币区块链结构图如下图所示，由图可以看出各个区块之间以<code>哈希指针</code>链接起来，区块内部各个交易则以<code>merkle tree</code>的形式组织起来。每个区块都记录两个哈希指针，一个是<code>previousblockhash</code>，指向上一个区块，记录着上一个区块的哈希值，另一个是<code>merkle root</code>，指向其所在区块的<code>merkle tree</code>的根节点，记录着该节点的哈希值。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-14-33.png#pic_center" alt="2022-06-17-18-14-33"></p>
<h1 id="比特币区块"><a class="markdownIt-Anchor" href="#比特币区块"></a> 比特币区块</h1>
<p>比特币区块的结构如图所示，区块由两部分组成，一部分是<code>区块头</code>，记录着区块的一些关键的特征信息，受限于页面大小，下面图中只展示出一部分，后面会介绍不在图上的其它项。另一部分是<code>交易列表</code>，记录着该区块里每条交易的哈希值，这里的划分只是一种概念上的划分，实际上区块的数据结构中不会专门用两个不同数据结构来分别存放<code>区块头</code>和<code>交易列表</code>，而是会把它们统一记录在一个数据结构中。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-15-13.png#pic_center" alt="2022-06-17-18-15-13"><br>
比特币区块各字段如下表所示。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>当前区块Hash</td>
</tr>
<tr>
<td>confirmations</td>
<td>区块链网络确认数</td>
</tr>
<tr>
<td>size</td>
<td>区块大小</td>
</tr>
<tr>
<td>height</td>
<td>区块高度</td>
</tr>
<tr>
<td>version</td>
<td>区块版本</td>
</tr>
<tr>
<td>versionHex</td>
<td>区块版本的16进制表示</td>
</tr>
<tr>
<td>merkleroot</td>
<td>区块中所有交易的merkle根Hash</td>
</tr>
<tr>
<td>tx</td>
<td>交易列表</td>
</tr>
<tr>
<td>time</td>
<td>区块的时间戳</td>
</tr>
<tr>
<td>mediantime</td>
<td>过去11个区块的中值时间</td>
</tr>
<tr>
<td>nonce</td>
<td>32位的任意随机数，挖矿时用于工作量证明算法的一个扰动输入参数</td>
</tr>
<tr>
<td>bits</td>
<td>区块的难度目标</td>
</tr>
<tr>
<td>chainwork</td>
<td>区块链上的总计工作量，它是一个32位的整数，代表了区块链上所有区块的计算工作量</td>
</tr>
<tr>
<td>previousblockhash</td>
<td>前一个区块的Hash值</td>
</tr>
<tr>
<td>nextblockhash</td>
<td>下一个区块的Hash值</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="获取区块数据"><a class="markdownIt-Anchor" href="#获取区块数据"></a> 获取区块数据</h1>
<p>前面介绍了比特币区块的结构以及里面的各个字段，下面介绍在实际网络中如何获取一个真实存在的区块的数据。目前网络上有多个区块链浏览器，这些区块链浏览器不光能查询区块的内容，还能实时地监测网上正在进行的交易，一个比较常用的在线区块链查询网站是<a href="https://www.blockchain.com/explorer">https://www.blockchain.com/explorer</a>。</p>
<p>点击进入该网址，在Assets-&gt;Bitcoin页面，可以看到最新加入到区块链中的区块(Latest Blocks)，以及最新的交易情况(Latest Transactions)。滚动到该页面的最下方，点击进入Resources-&gt;APIs页面。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-15-51.png#pic_center" alt="2022-06-17-18-15-51"><br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-16-12.png#pic_center" alt="2022-06-17-18-16-12"><br>
在Resources-&gt;APIs页面，可以看到这个网站提供了很多不同的API和查询功能，点击查看Blockchain Data API的Documentation，这个Documentation就是关于如何查询区块数据的说明书。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-16-54.png#pic_center" alt="2022-06-17-18-16-54"><br>
在里面可以看到，我们既可以查询某个区块的内容，也可以查询某个交易的内容，要查询区块内容，只需要在浏览器输入<code>https://blockchain.info/rawblock/$block_hash</code>格式的URL然后跳转即可，其中<code>$block_hash</code>是该区块的哈希值。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-17-11.png#pic_center" alt="2022-06-17-18-17-11"><br>
点击查看前面的Assets-&gt;Bitcoin-&gt;Latest Blocks页面，查看最新的区块，作为例子，从其中选一个比较小的区块，如下图的Block 740337，查看该区块的内容，可以看到，其哈希值为<mark>000000000000000000055092e5f54d01ea178a879cef5f331f4b974172cccefe</mark>，则查询该区块内容的URL为<a href="https://blockchain.info/rawblock/000000000000000000055092e5f54d01ea178a879cef5f331f4b974172cccefe">https://blockchain.info/rawblock/000000000000000000055092e5f54d01ea178a879cef5f331f4b974172cccefe</a><br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-17-27.png#pic_center" alt="2022-06-17-18-17-27"><br>
转到上面的URL后，我们看到的JSON格式的网页内容是乱序的，需要进行排序以便观察。将其内容复制到<a href="https://www.bejson.com/json/format/">https://www.bejson.com/json/format/)</a>这个网址，格式化校验之后，点击保存校验数据，然后即可看到格式化后的JSON文件内容，如下图所示。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-17-45.png#pic_center" alt="2022-06-17-18-17-45"><br>
上面的JSON文件可以到以下<a href="https://gitee.com/yuke-yang/bitcoin">地址</a>中下载，文件名为<font color="SteelBlue">Block 740370.json</font>。</p>
<h1 id="coinbase交易"><a class="markdownIt-Anchor" href="#coinbase交易"></a> coinbase交易</h1>
<p>每个区块的第一条交易是<code>coinbase交易</code>。<code>coinbase交易</code>会生成新的比特币，要生成新的比特币，只能通过<code>coinbase交易</code>。与普通的交易相比，<code>coinbase交易</code>有如下的几个特点：</p>
<ul>
<li>只有一个输入和一个输出</li>
<li>因为coinbase交易只是铸造新的比特币，而不花费任何现有的比特币，因此其输入并不赎回任何的之前的输出，这样，输入的prev_out字段就会包含一个空的哈希指针</li>
<li>当前的输出值比6BTC要稍大。输出值就是矿工从这个区块所获得的回报(reward)。reward由两部分组成，一部分是固定的挖矿奖励(block reward)，目前的值为6.25BTC，在某一段时间内，不管哪个矿工挖到一个新的区块，其所得到的block reward基本都是固定的，这部分收益在不同的区块间不会有差别，但是值得注意的是，每挖到210000个新的区块后(大约4年)，这个值就会减半；另一部分就是矿工从区块中的所有交易所收取的交易费(fee reward)，这部分收益在不同的区块之间就会有所不同，取决于区块中所包含的交易的数目以及每条交易所收取的交易费。</li>
</ul>
<p>以上面的JSON文件为例，摘取其交易列表的第一条交易(即<code>coinbase交易</code>)出来，从下面可以看到，这个区块的<code>coinbase交易</code>新造了6.25150003枚比特币，其中block reward为6.25150003BTC，fee reward为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tx&quot;</span>: [&#123;</span><br><span class="line">    <span class="string">&quot;hash&quot;</span>: <span class="string">&quot;f58dc5d553b86f47fb901757e3be85b2b08f3f36317fc1e690fb2ca7cbe37156&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ver&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;vin_sz&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;vout_sz&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;size&quot;</span>: <span class="number">217</span>,</span><br><span class="line">    <span class="string">&quot;weight&quot;</span>: <span class="number">760</span>,</span><br><span class="line">    <span class="string">&quot;fee&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;relayed_by&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lock_time&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">    <span class="string">&quot;double_spend&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;time&quot;</span>: <span class="number">1654947331</span>,</span><br><span class="line">    <span class="string">&quot;block_index&quot;</span>: <span class="number">740337</span>,</span><br><span class="line">    <span class="string">&quot;block_height&quot;</span>: <span class="number">740337</span>,</span><br><span class="line">    <span class="string">&quot;inputs&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;sequence&quot;</span>: <span class="number">4294967295</span>,</span><br><span class="line">        <span class="string">&quot;witness&quot;</span>: <span class="string">&quot;01200000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;script&quot;</span>: <span class="string">&quot;03f14b0b04037ea4622f466f756e6472792055534120506f6f6c202364726f70676f6c642f0c027cef00003c1706000000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;prev_out&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;tx_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;n&quot;</span>: <span class="number">4294967295</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;spent&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;script&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;spending_outpoints&quot;</span>: [&#123;</span><br><span class="line">                <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">                <span class="string">&quot;n&quot;</span>: <span class="number">0</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;out&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;spent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="number">625150003</span>,</span><br><span class="line">        <span class="string">&quot;spending_outpoints&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;n&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">        <span class="string">&quot;script&quot;</span>: <span class="string">&quot;76a9145e9b23809261178723055968d134a947f47e799f88ac&quot;</span>,</span><br><span class="line">        <span class="string">&quot;addr&quot;</span>: <span class="string">&quot;19dENFt4wVwos6xtgwStA6n8bbA57WCS58&quot;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;spent&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;spending_outpoints&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;n&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;tx_index&quot;</span>: <span class="number">3041508898170271</span>,</span><br><span class="line">        <span class="string">&quot;script&quot;</span>: <span class="string">&quot;6a24aa21a9edeb61edfb90d450a17115e960c6e6b216442b28c0ff48a9e390dfa2a767e80ec0&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, </span><br></pre></td></tr></table></figure>
<p>该<code>coinbase交易</code>的细节可以到<a href="https://www.blockchain.com/btc/tx/f58dc5d553b86f47fb901757e3be85b2b08f3f36317fc1e690fb2ca7cbe37156">https://www.blockchain.com/btc/tx/f58dc5d553b86f47fb901757e3be85b2b08f3f36317fc1e690fb2ca7cbe37156</a>查看，如下图所示。这个URL的最后一部分是该交易的哈希，假如我们要查询其它交易的细节，将其它交易的哈希替换这个URL的最后一部分(该交易的哈希)即可。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-18-35.png#pic_center" alt="2022-06-17-18-18-35"><br>
下图又是另外一个例子<a href="https://www.blockchain.com/btc/block/000000000000000000032e39bbd3a6af9b311982a256acf1dab5518b2eb79c9a">https://www.blockchain.com/btc/block/000000000000000000032e39bbd3a6af9b311982a256acf1dab5518b2eb79c9a</a>，从图中可以看出，Block Reward是6.25000000BTC，而Fee Reward是0.00080987，因此挖得此区块的总的收益(revenue)是6.25150003。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/2022-06-17-18-19-04.png#pic_center" alt="2022-06-17-18-19-04"></p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文介绍了与比特币区块链有关的数据结构以及相关概念，包括<code>哈希指针</code>，<code>merkle tree</code>，<code>比特币区块链</code>，<code>比特币区块</code>，介绍了它们所具有的一些属性，它们是比特币网络的基本部件(building block)，要理解比特币网络，首先必须要正确理解这些概念。</p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="http://www.woshipm.com/blockchain/1022259.html">通俗易懂揭秘比特币区块的内部结构</a><br>
[2] <a href="https://segmentfault.com/a/1190000017055507">Bitcoin 区块和交易数据结构</a><br>
[3] <a href="https://zhuanlan.zhihu.com/p/42584683">bitcoin区块结构分析</a><br>
[4] <a href="https://www.liaoxuefeng.com/wiki/1207298049439968/1207297665661664#:~:text=%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%8C%BA%E5%9D%97,%E5%B9%B6%E4%BA%A7%E7%94%9F%E6%96%B0%E7%9A%84UTXO%E3%80%82">区块结构</a><br>
[5] <a href="https://blog.csdn.net/u013137970/article/details/69891985">比特币区块结构解析</a><br>
[6] <font color="CornflowerBlue">Bitcoin and Cryptocurrency Technologies </font>by Arvind Narayanan, Joseph Bonneau etl. Section 3.4</p>
]]></content>
      <categories>
        <category>比特币</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>多重签名</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析比特币脚本</title>
    <url>/2022/06/17/%E6%B5%85%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在比特币网络中，每个用户的身份是通过公钥来识别的，由此实现了一定程度的用户的匿名性。那么，直觉上，自然而然地我们会认为每一笔交易是通过公钥来指明支付的对象，毕竟现在公钥就等价于用户的身份证号码。然而实际上并非如此，每一笔交易的输出实际上只是指明了一个脚本(script)，通过脚本，间接地指明这笔交易会把多少比特币转给谁。那么为什么交易的输出不是直接用公钥来指明比特币的支付对象，而要通过脚本来指明呢？</p>
<span id="more"></span>
<p>实际上这是为了保证两点，其一，支付对象的匿名性；其二，所支付的比特币只能被支付对象所使用。举个例子，如下图所示，假如Alice在交易a的输出中，将十个比特币给了Bob，在交易b中，Bob又将这十个比特币转给了Carol，那么Alice在交易a中应该怎么做才能保证这十个比特币在后续的交易中只能被Bob使用，而不是被别人偷走？<br>
<img src="/2022/06/17/%E6%B5%85%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/2022-06-17-16-19-26.png#pic_center" alt="2022-06-17-16-19-26"></p>
<p>Alice应该在交易输出中给出Bob的公钥哈希，并且要求，假如Bob要使用这个十个比特币，那就必须要提供Bob的公钥以及Bob的数字签名，只有当Bob给出的公钥的哈希与Alice给的相等，并且Bob的数字签名有效时，才能使用这十个比特币。为什么Alice不是在交易输出中直接指明Bob的公钥，而是指明Bob的公钥哈希？这是为了实现匿名性，具体原因可以参考这篇博客<a href="https://happypeter.github.io/binfo/address.html#:~:text=%E6%AF%94%E7%89%B9%E5%B8%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF,%E5%AE%9E%E9%99%85%E4%B8%AD%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0%E3%80%82">为何使用地址而不是公钥？</a>。</p>
<p>当Alice在交易输出中使用Bob的公钥哈希时，Alice可以证明这笔支付是给了Bob；而当Bob在后续的交易公开给出公钥和他的数字签名时，可以向大家证明他是Bob，从而解锁Alice所支付的比特币，注意，Bob需要在后续交易中公开公钥，而不是简单地给出他的公钥哈希，这样才能让别人在验证他的数字签名是有效的同时，也证明上一次Alice所支付的地址的确是Bob的公钥哈希。Alice支付的过程就是通过给出输出脚本来实现的，而Bob解锁Alice所支付给他的比特币的过程则是通过输入脚本来实现的。当Bob要解锁Alice支付的比特币时，Bob会给出输入脚本，这个输入脚本会和Alice给出的输出脚本拼接到一起，组成一个完整的脚本，然后执行脚本，如果结果是True，那么就解锁成功，Bob的这次交易就能被成功地添加到区块中，否则这次交易无效，不会被添加到区块中。</p>
<h1 id="比特币脚本语言结构"><a class="markdownIt-Anchor" href="#比特币脚本语言结构"></a> 比特币脚本语言结构</h1>
<p>从上面一节可以看出，Bob要完成一次交易，需要执行一个比特币脚本，该脚本由输入脚本(scriptSig)和输出脚本(scriptPubKey)两部分组成，输出脚本由Alice在之前的交易(交易a)的输出中给出，输入脚本则由Bob在本次交易(交易b)中给出。比特币脚本使用方法主要有以下几种。</p>
<ol>
<li>P2PK (Pay to Public Key)</li>
<li>P2PKH (Pay to Public Key Hash)</li>
<li>P2SH (Pay to Script Hash)</li>
<li>多重签名</li>
<li>Proof of Burn</li>
</ol>
<p>在本文中介绍的例子将会使用第二种(P2PKH)，这种是最常用的方法，有关其它方法的细节，可以参考<a href="https://blog.csdn.net/ice_fire_x/article/details/104173840">比特币脚本原理和使用方法</a>一文，这里不再细述。一个P2PKH输出脚本(scriptPubKey)的例子如下所示，在上面交易例子中由Alice在交易a的输出中给出，输出脚本里包含了Bob的公钥哈希(69e02e18…)，以及一些操作，后面会提到这些操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">69e02e18...</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>一个输入脚本(scriptSig)的例子如下所示，在上面的交易例子中由Bob在交易b的输入中给出。这里的输入由两部分组成，一是Bob用他自己的私钥对本次交易(即交易b)进行签名所得到的数字签名(sig, signature)，另一部分就是Bob的公钥(pubKey, public key)。给出公钥主要有两个目的，一个是证明Alice在交易a中支付的对象的确是Bob，前面提到，Alice在交易a中只是给出了一个公钥哈希，但是并没有明确指明Bob的公钥，那么别人怎么能知道Alice给的这个公钥哈希就是Bob的公钥哈希呢？因此，为了证明这点，Bob需要在交易b公开他的公钥，然后取哈希，一旦得到的哈希与Alice给的相等，那就证明了Alice给的公钥哈希的确是Bob的公钥哈希，换言之，Alice这十个比特币的确是支付给Bob的。另外一个目的就是为了进行数字验签，Bob需要给出公钥，别人才能用他的公钥和数字签名进行验签，才能确认他的数字签名有效，即他的确是Bob。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubKey&gt;</span><br></pre></td></tr></table></figure>
<p>Bob在进行交易b时，需要证明他是Bob，以解锁交易a输出中给Bob的十个比特币，这个证明的过程是通过执行脚本来实现的。Bob会将Alice在交易a输出中给出的输出脚本拼接到他给的输入脚本后面，组成一个完整的脚本，然后执行该脚本，拼接后Bob所执行的完整的脚本如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubKey&gt;</span><br><span class="line">------------------------</span><br><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">69e02e18...</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<h1 id="脚本执行过程"><a class="markdownIt-Anchor" href="#脚本执行过程"></a> 脚本执行过程</h1>
<p>比特币脚本所使用的语言是一门基于堆栈的语言，脚本的每一行要么是数据，要么是指令，执行过程从脚本的第一行开始，自上到下。如果是数据的话，就将其压入到堆栈中，如果是指令的话，就执行该指令。</p>
<p>还是以上面的例子来进行说明，当Bob在交易b要解锁Alice在交易a支付给他的十个比特币时，Bob需要执行上面的这个完整的比特币脚本，执行过程如下。</p>
<ul>
<li>第一步，将Bob在交易b的输入脚本中给出的他对当前交易(即交易b)的数字签名&lt;sig&gt;压入堆栈。</li>
<li>第二步，将Bob在交易b的输入脚本中给出的他自己的公钥&lt;pubKey&gt;压入堆栈。</li>
<li>第三步，执行OP_DUP，该操作将会复制Bob的公钥并添加到栈顶。</li>
<li>第四步，执行OP_HASH160，该操作将对当前栈顶的Bob的公钥拷贝进行哈希运算，得到Bob的公钥哈希&lt;pubKeyHash&gt;，并将其替换当前栈顶的Bob的公钥拷贝。</li>
<li>第五步，将Alice在输出脚本中给出的Bob的公钥哈希&lt;pubKeyHash?&gt;(在上面的例子中是69e02e18…)弹入到堆栈中。</li>
<li>第六步，执行OP_EQUALVERIFY，判断Alice给出的公钥哈希&lt;pubKeyHash?&gt;，和第四步对Bob的公钥进行哈希运算后得到的公钥哈希&lt;pubKeyHash&gt;进行对比，判断两者是否相等，相等则继续往下执行，否则认为本次交易失败。</li>
<li>第七步，假如第六步的操作成功，那么将执行这一步。到这一步时，堆栈中只剩下Bob在交易b的输入脚本中给出的他的公钥(&lt;pubKey&gt;)，以及他用自己的私钥对交易b进行签名所得到的数字签名(&lt;sig&gt;)。执行OP_CHECKSIG，该操作将进行数字验签。验签过程大致如下，用Bob给出的公钥(&lt;pubKey&gt;)对他给出的他对交易b的数字签名进行解密，得到一个哈希值hash = decrypt(publicKey, signature)，然后再对交易b进行哈希运算，得到另一个哈希值hash’，假如hash和hash’相等，那么数字验签成功，即Bob证明了他是Bob，可以开始使用Alice在交易a中给他的十个比特币了，本次交易有效，将被加入到新创建的区块中；否则验签失败，本次交易被丢弃。关于数字验签，可以参考<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626">签名算法</a>以及<a href="https://segmentfault.com/a/1190000024523772">一文彻底搞懂加密、数字签名和数字证书！</a>这两篇文章。</li>
</ul>
<p>上面的执行过程可以用下图表示，大家可以参考这张图，结合上面的描述来理解整个过程。<br>
<img src="/2022/06/17/%E6%B5%85%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/2022-06-17-16-21-56.png#pic_center" alt="2022-06-17-16-21-56"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://happypeter.github.io/binfo/address.html#:~:text=%E6%AF%94%E7%89%B9%E5%B8%81%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF,%E5%AE%9E%E9%99%85%E4%B8%AD%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0%E3%80%82">为何使用地址而不是公钥？</a></li>
<li><a href="https://blog.csdn.net/ice_fire_x/article/details/104173840">比特币脚本原理和使用方法</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227943022626">签名算法</a></li>
<li><a href="https://segmentfault.com/a/1190000024523772">一文彻底搞懂加密、数字签名和数字证书！</a></li>
<li><a href="https://www.liaoxuefeng.com/article/1124144362997184">深入理解比特币交易的脚本</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25461051">理解比特币脚本</a></li>
<li><a href="https://bitcoinbook.cs.princeton.edu/">Bitcoin and Cryptocurrency Technologies</a> by Arvind Narayanan, Joseph Bonneau etl.</li>
</ol>
]]></content>
      <categories>
        <category>比特币</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币多重签名</title>
    <url>/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p>在“<a href="https://blog.csdn.net/zengaliang/article/details/125133213?spm=1001.2014.3001.5501">浅析比特币脚本</a>”一文中，曾经提到过比特币脚本的一个应用是多重签名(Multi-Signature)。顾名思义，多重签名(以下简称多签)是指一笔交易需要多个私钥签名才能被执行。</p>
<p>在大多数情况下，交易都是一对一进行的，买家向卖家给出的地址(即卖家的公钥哈希)支付比特币，卖家要使用该比特币的时候提供自己的数字签名并验证自己的数字签名有效即可。但也会有这样一类场景：一个钱包被多个人共同持有。比如，某公司有5个合伙人，公司钱包相应就有5个私钥，每个合伙人持有其中1个私钥。为了防止其中某一个合伙人想中饱私囊或者肆意挥霍，必须有5个人中的3人同时签名才可以把钱包中的币取走，这类情况就需要使用“多重签名”。</p>
<span id="more"></span>
<p>在比特币中，多签的含义是：一个钱包如果有m个私钥，交易的时候，需要其中n(1≤n≤m) 个私钥的签名，交易才能被执行。对应到现实里，可以想象为这样一个场景：m个人共同管理一笔资金(比特币)，他们各自持有一把私钥，要花费这笔资金需要取得其中至少n个人的同意(签名) 才能进行。对应到这个场景的话，m就是5，n就是3。</p>
<p>使用多签有这些优点：</p>
<ul>
<li>一个钱包可以由多人共同管理</li>
<li>避免单点故障，防止某一个私钥被盗影响整个钱包</li>
<li>多个私钥可以起备份作用，防止单一私钥在丢失的情况下导致大量属于该私钥持有者的资金损失</li>
</ul>
<p>多签主要有两种实现方式：</p>
<ul>
<li>CHECKMULTISIG实现多签</li>
<li>P2SH实现多签</li>
</ul>
<p>下面将对这两种实现方式进行介绍。</p>
<h1 id="checkmultisig实现多签"><a class="markdownIt-Anchor" href="#checkmultisig实现多签"></a> CHECKMULTISIG实现多签</h1>
<p>用CHECKMULTISIG实现多签，输出脚本(也叫锁定脚本)的形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_1)</span></span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_2)</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_m)</span></span><br><span class="line">m</span><br><span class="line">OP_CHECKMULTSIG</span><br></pre></td></tr></table></figure>
<p>如果输出脚本是这种形式的话，这笔交易就是一笔<strong>付款到多重签名</strong>(P2MS，Pay to Multi Signature)的交易，也常用multisig表示。其中m表示一共有m个人，每个人各自有一把公钥，共有m把公钥，这笔钱将会付给这m个人，由他们共同持有；n表示需要当这m个人想要使用这笔钱的时候，需要其中n个人的数字签名(即获得n个人的同意)才能使用这笔钱。</p>
<p>解锁UTXO(可理解为输出脚本所支付的比特币的ID)时，需要提供输入脚本(也叫解锁脚本)，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br></pre></td></tr></table></figure>
<p>可以理解为需要n个签名(即获得n个人的同意)才能使用这笔钱。在需要使用这笔钱的时候，n个人提供输入脚本，将输入脚本与输出脚本拼接到一起，得到完整的执行脚本，然后执行该脚本。拼接后的脚本形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br><span class="line">n</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_1)</span></span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_2)</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_m)</span></span><br><span class="line">m</span><br><span class="line">OP_CHECKMULTSIG</span><br></pre></td></tr></table></figure>
<p>其执行过程如图：<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/2022-06-17-18-00-06.png#pic_center" alt="2022-06-17-18-00-06"><br>
可见，OP_CHECKMULTISIG一条语句就能完成整个多签的验证。</p>
<p>但是这种验证方式也有不足，它需要付款人（输出脚本）提供所有收款人的公钥。换句话说，要给有5个合伙人的公司打款，需要付款人先去获得每个合伙人的公钥，这样很不方便。</p>
<p>如果5个合伙人能提供单一的收款地址，不需要付款人把他们的公钥一一列出来，那样是最简便的，而这可以通过P2SH来实现。</p>
<h1 id="p2sh实现单签"><a class="markdownIt-Anchor" href="#p2sh实现单签"></a> P2SH实现单签</h1>
<p>P2SH(Pay to Script Hash)是除P2K(Pay to public key)、P2KH(Pay to public key hash)之外的另一种付款方式。在P2SH的输入脚本中需要提供一个被称为RedeemScript的脚本，在P2SH的输出脚本则需要提供RedeemScript的哈希。在讨论P2SH实现多签之前，先讨论P2SH实现单签这种简单的情况。</p>
<p>P2SH的输出脚本格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure>
<p>输入脚本格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br></pre></td></tr></table></figure>
<p>拼接后的脚本如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure>
<p>使用P2SH方式付款时，收款人只需要向付款人提供一个地址，付款人往这个地址支付比特币即可，这个地址就是收款人的Redeem Script的哈希；当收款人要花这笔钱的时候，需要提供相应的Redeem Script，以及收款人的数字签名。如果Redeem Script执行后，栈顶等于TRUE，那么表示整个付款的验证通过。</p>
<p>执行拼接后的脚本，执行过程如下图所示：<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/2022-06-17-18-01-00.png#pic_center" alt="2022-06-17-18-01-00"><br>
在上图中，如果<strong>OP_EQUALVERIFY</strong>执行结果为TRUE，那么接下来会执行redeemScript，而redeemScript是收款人自定义的，我们也可以通过它来实现多签。</p>
<h1 id="p2sh实现多签"><a class="markdownIt-Anchor" href="#p2sh实现多签"></a> P2SH实现多签</h1>
<p>使用P2SH的支付方式，可以通过Redeem Script来实现多签。</p>
<p>P2SH实现多签时的输出脚本格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure>
<p>可以看到，P2SH的输出脚本格式在实现多签和单签时是一样的。</p>
<p>输入脚本格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br></pre></td></tr></table></figure>
<p>可以看到，在实现多签时，输入脚本与单签时的格式略微有所不同，此时需要提供的数字签名不再只有一个，而是多个。</p>
<p>拼接后的脚本如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OP_PUSHDATA(sig_1)</span><br><span class="line">OP_PUSHDATA(sig_2)</span><br><span class="line">...</span><br><span class="line">OP_PUSHDATA(sig_n)</span><br><span class="line">OP_PUSHDATA(redeemScript)</span><br><span class="line">OP_HASH160</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(redeemScriptHash)</span></span><br><span class="line">OP_EQUALVERIFY</span><br></pre></td></tr></table></figure>
<p>执行拼接后的脚本，如果<strong>OP_EQUALVERIFY</strong>等于TRUE，将开始执行redeemScript，redeemScript的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_1)</span></span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_2)</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">OP_PUSHDATA</span><span class="params">(publicKey_m)</span></span><br><span class="line">m</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>此时，执行redeemScript的过程将和前面&quot;CHECKMULTISIG实现多签&quot;一节的过程一样。</p>
<p>以上就是通过redeemScript来实现多签的过程，整个过程如下图所示。<br>
<img src="/2022/06/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%A4%9A%E9%87%8D%E7%AD%BE%E5%90%8D/2022-06-17-18-01-54.png#pic_center" alt="2022-06-17-18-01-54"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="https://qianniu.fun/2022/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%AD%BE%E7%9A%84%EF%BC%9F/">比特币脚本是如何实现多签的？</a><br>
[2] <a href="https://zhuanlan.zhihu.com/p/53652207">“付款到多重签名” 和 “付款到脚本哈希”</a><br>
[3] <a href="https://www.liaoxuefeng.com/wiki/1207298049439968/1207315329092960">多重签名</a><br>
[4] <a href="https://bitcoinbook.cs.princeton.edu/">Bitcoin and Cryptocurrency Technologies</a> by Arvind Narayanan, Joseph Bonneau etl. Section 3.2</p>
]]></content>
      <categories>
        <category>比特币</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>多重签名</tag>
      </tags>
  </entry>
</search>
