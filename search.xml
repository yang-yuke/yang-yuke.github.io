<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LTE MAC token bucket algorithm</title>
    <url>/2021/11/27/LTE-MAC-token-bucket-algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="abbreviation"><a class="markdownIt-Anchor" href="#abbreviation"></a> Abbreviation</h1>
<p>Below are the abbreviation of some jargons that will be used in the essay.</p>
<p>NW: network<br>
UL: uplink<br>
WFQ: weighted fair queueing</p>
<h1 id="preface"><a class="markdownIt-Anchor" href="#preface"></a> Preface</h1>
<p>In LTE protocol stack, MAC lies in the so-called layer2. One of its main functionalities is managing the UL grant we receive from layer1. In other words, it allocates the UL grant to different logic channels. In this essay, I will briefly talk about how MAC layer allocates the UL grant to different logic channel. It does so by implementing the toket bucket algorithm, which is the official MAC UL sheduling algorithm used by LTE MAC layer, specified in 3GPP specification 36.321.</p>
<span id="more"></span>
<h1 id="token-bucket-algorithm"><a class="markdownIt-Anchor" href="#token-bucket-algorithm"></a> Token bucket algorithm</h1>
<p>Suppose we have below 3 active logic channels. For each logic channel, there will be a bucket which holds the tokens. The size of token bucket for each logic channel are not neccessarily the same. They may vary, depending on NW’s configuration.</p>
<p>Each TTI, a certain amount of token will be injected to seperate logic channel’s token bucket. The amount of token injected each TTI is equal to PBR, which is actually the data rate that we want to ensure that the logic channel can achieve at the very least, to avoid that some logic channel of higher priority might hog over the UL grant and hunger those less prioritized logic channels to death. We want to make sure that as long as there is UL grant, each logic channel might relish a share of it, even for those of low priority.<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-09-22-56-19.png" alt="2022-02-09-22-56-19"></p>
<p>In actual implementation, the token bucket algorithm is essentially a combination of WFQ algorithm and round-robin queueing algorivthm. When we get an UL grant, how should we allocate them to different logic channels? For the sake of discussion, let’s take the below graph as an example. In below graph, each logic channel’s token bucket has 500bytes of token. And each logic channel’s buffer has 3000bytes of data pending in it. Now, if we get an UL grant of 3000bytes at some point, how should we allocate it? If we allocate all of them to one logic channel, that would be unfair to the other 2 logic channels because they don’t get the chance to send out any bit of data. Then how about sharing it fairly among the logic channels? Well, that doesn’t seem a wise choice as well, because in the real-life scenario, some traffic, such as video or audio data, are obviously more important than other application’s traffic, such as FTP. We can tolerate a slowly downloaded file but we have zero tolerance for a jittering video call or voice call!<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-09-23-24-07.png" alt="2022-02-09-23-24-07"></p>
<p>Alright, enough for those non-sense, then what should we do here? Well, after the trade-off of fairness and effectiveness, someone came up with an ingenuous idea that balances both pretty well. In the actual MAC token bucket algorithm, there are 2 rounds of UL grant allocation. The first round is actually somewhat like the WFQ algorithm. In this round, we will start from the highest prioritized logic channel, we allocate a part of the UL grant to it. How many? Depends on the available token bytes and the data pending in the buffer. If there are too much data pending the buffer that the number of token cannot match it, then sorry, we can only allocate the size of the UL grant upto the amount of available token to that particular logic channel at this round. The number of token is the budget. We can’t exceed the budget. If there are not much pending data and the token is enough, then congratulation, we don’t have to consume all the token. Instead, we only need to allocate the size of UL grant that is equal to the number pending data to that logic channel. So, the grant allotment to a logic channel can be summarized with one simple equation as follows. MIN stands for taking the minimum value.</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>t</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>=</mo><mi>M</mi><mi>I</mi><mi>N</mi><mo stretchy="false">(</mo><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>f</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">allotment=MIN(pending\_data\_size, number\_of\_token)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>After allocating the UL grant to the highest logic channel, we will apply the same logic to allocate the leftover grant to the rest logic channel, one by one, from secondary highest prioritized logic channel all the way down to the least significant logic channel, as long as there is still UL grant left. This is how the first round works. The main purpose of this round is fairness. Regardless it is good or bad, we want to make sure every logic channel can enjoy a piece of the UL grant. The quality of service each logic channel can get depends on the PBR and token bucket size. They work together as the weight in the WFQ algorithm. They defines the weight of each logic channel. Now, let’s take the above graph as an example. How will the situation looks like after the first round of grant allocation? Well, apparently, each logic channel has enough pending data(3000bytes), so all of their available token(500bytes) will be consumed. So the situation will be as follows.<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-10-00-02-20.png" alt="2022-02-10-00-02-20"></p>
<p>All the logic channels’ token bucket are empty. Each one’s buffer will have 500 bytes less(i.e. the amount the token consumed), so there are now only 2500 bytes pending in each logic channels’ buffer. The leftover grant will be only 1500 bytes now. Now, after this round, seems every body is happy with the result right? Everyone can enjoy a bit of it. Fair enough. Well, is it? Suppose LICD1 is the highest prioritized logic channel here, I’m afraid LCID1 will say no! Because sometimes some traffic are much more important than the others(e.g. video or voice call traffic versus downloaded file traffic), they should be preferred when we allocate the UL grant. Fairness might backfire here if we only consider it. So,in order to achieve effectiveness, we will adopt a round-robin strategy in the second round of grant allocation.</p>
<p>Let’s continue the analysis of the scenario above. Now we still have 1500 bytes of UL grant left. Each logic channel’s token bucket is already empty. And each logic channel still has 2500 bytes of pending data. What should we do now? You might think that since the token bucket is already empty, we cannot allocate the grant to any of the logic channel and cannot send out any data anymore. But that’s not the case, because in this round token bucket is not involved at all. Remember, the existence of token bucket is to ensure that each logic channel can get a certain amount of UL grant and hence get some service, regardless of good or bad. Since they have all be served in the first round, we have acheived our goal, so there is no need to adhere to such principle in this round anymore. Instead, we should forget it and try a best-effort strategy in order that the most important logic channel can get the best service. Therefore, starting from the highest prioritized logic channel, we will allocate all the leftover UL grant to it as long as there is enough data in its buffer to consume the UL grant. If after its pending data is all consumed, there is still UL grant left, then we will continue to apply the same logic to the secondary highest prioritized logic channel, until the UL grant has all been consumed or all logic channels’ data has been consumed. So, in this round, all the leftover UL grant(1500 bytes) will be allocated to logic channel 1, and logic channel 1 will have 1000 bytes left. LCID3 and LCID5 channels don’t get the chance to be served in this round, but that’s ok since they have been served in the first round. The scenario will be as below after the second round.<br>
<img src="/2021/11/27/LTE-MAC-token-bucket-algorithm/2022-02-10-23-37-24.png" alt="2022-02-10-23-37-24"></p>
<p>There are also might be some minor details skipped here, but that’s the general idea of the token bucket algorithm used in actual implementation.</p>
<h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1>
<p>[1] Computer Networks: A Top-Down Approach. By Behrouz A. Forouzan, Firouz Mosharraf<br>
[2] Computer Networks. By ANDREW S. TANENBAUM, DAVID J. WETHERALL<br>
[3] 36.321. By 3GPP specialist panel.</p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title>LTE网络MAC层令牌桶算法</title>
    <url>/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<p>LTE MAC层的一个重要的功能是从各个逻辑信道读取数据(MAC SDU)，然后将它们封装成一个数据块(MAC transport block)，再交给物理层从空口发生出去，这个过程叫packet build。每一次packet build能发送的数据块的大小由网络决定，网络会通过PDCCH指示UE在哪个子帧上可以发送多少字节的数据，可以发送的字节数就是最终能发送的数据块的大小，也叫UL grant(Uplink grant)。</p>
<span id="more"></span>
<p>那么UE的MAC层在接收到UL grant后，应该如何将这些UL grant分配到不同的逻辑信道上呢？是要将这些UL grant平均分配给当前所有的逻辑信道，每个逻辑信道都能发送同样的数据量吗？这个方法虽然很公平，但是却并不高效，主要有两个原因，其一，不同逻辑信道之间要发送的数据量可能差异非常大，这就导致了对有的逻辑信道来说所分得的UL grant不足以发送buffer里所有的数据，而对另一些逻辑信道来说所分得的UL grant可能又太多了，超出了buffer里的数据量，从而造成了浪费。那么按照先来后到的原则行不行，先发送最早激活的逻辑信道的数据，假如在清空该逻辑信道的buffer后，如果还有剩余的UL grant，再发送次早激活的逻辑信道的数据，依次类推。按照这种方法，能够保证所有的UL grant都被用来发送有效数据，不会造成资源浪费，但是这时又出现了另外一个问题，假如先激活的逻辑信道数据量一直很大，而后激活的逻辑信道数据量虽然没那么大，但是却很重要，这就会导致所有的UL grant都被用来发送先激活的逻辑信道数据了，而后激活的逻辑信道却始终得不到服务，重要的数据发不出去，这样会导致某些上层应用完全停滞，严重影响用户体验。那么按照逻辑信道优先级来服务呢？先发送优先级最高的逻辑信道的数据，再依次发送低优先级逻辑信道的数据，这样就能保证重要的数据先发送出去。但是这样也会有类似的问题，假如高优先级逻辑信道的数据量一直很大，就会导致低优先级逻辑信道一直得不到服务，通俗来说就是一直处于饥饿状态。</p>
<p>为了能既保证一定程度的公平(即所有的逻辑信道都能得到不同程度的服务)又兼顾效率(即UL grant不会被浪费)，LTE的MAC层的packet build过程采用了令牌桶算法(token bucket algorithm)。</p>
<h1 id="令牌桶算法概述"><a class="markdownIt-Anchor" href="#令牌桶算法概述"></a> 令牌桶算法概述</h1>
<p>令牌桶算法被广泛用于有线网络和无线网络的数据调度中。令牌桶算法工作过程大致如下图(a)和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span>所示。主机维护了一个令牌桶，以速率R往令牌桶中注入令牌。主机往网络发送数据的时候，会先判断令牌桶里面是否还有令牌，如果有，才能发送数据，并且发送多少数据就从令牌桶中取出多少令牌。如果令牌桶为空，那么主机就不能向网络发送数据了，所有的packet只能缓存在主机的队列里。</p>
<p><img src="/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/2022-06-17-00-38-27.png#pic_center" alt="2022-06-17-00-38-27"></p>
<p>在传统的有线网络中，令牌桶算法可被应用于路由器(网络层, network layer)，用于对网络流量进行平滑整形，以减少网络拥塞。令牌桶限制了数据流的长期速率，但是却允许短期的数据洪流(burst)。主机在短时间内可以以极高的速率发送数据，而不必缓存任何的数据，因此在这段时间内数据不会有任何的时延。从长期来看，数据速率会被限定为令牌增加的速率R，一旦令牌桶被清空，后续的数据发送速率就只能受限于令牌注入的速度了。</p>
<p>在无线通信网络中，令牌桶算法可以用于保证不同的上层业务的服务质量(QoS, quality of service)。在LTE网络里，MAC层就采用了令牌桶算法。</p>
<h1 id="mac令牌桶算法实现"><a class="markdownIt-Anchor" href="#mac令牌桶算法实现"></a> MAC令牌桶算法实现</h1>
<p>MAC实体在每一次要进行HARQ新传的时候，都会按照令牌桶(token bucket)算法对UL grant进行分配，这个过程叫<strong>Logical Channel Prioritization</strong>过程。</p>
<p>对每个逻辑信道，RRC都为其分配一个逻辑信道优先级(<strong>priority</strong>)，以此控制上行数据的调度。优先级的数字越小，其优先级越高。比如，SRB1(逻辑信道ID为1)的优先级通常为1，表示其优先级最高。除了逻辑信道优先级，RRC还会分配<strong>prioritisedBitRate</strong>，<strong>bucketSizeDuration</strong> 这两个参数。<strong>prioritisedBitRate</strong>(PBR, Prioritized Bit Rate)表示对每个逻辑信道的缓存数据需要以多大的速率进行优先处理，保证了各个逻辑信道的最低服务质量。<strong>bucketSizeDuration</strong> (BSD, Bucket Size Duration)表示令牌桶的深度，通过限制令牌桶的深度对突发数据流(data burst)进行一定程度的流控，从而保证数据的平滑传输。</p>
<p>对每个逻辑信道(用变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>表示)，MAC实体都为其维护一个变量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示令牌桶当前令牌数目 。在该逻辑信道新添加时，需要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>初始化为0，其后每个TTI(对LTE来说是1ms)，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 都应增加PBR × TTI(即PRB)，表示往令牌桶中新增加令牌数为PBR，其中PBR就是该逻辑信道需要优先处理的数据比特率(Prioritized Bit Rate of logical channel <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>)。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不会无限增大，当令牌桶的令牌溢出时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的值就会被限定为令牌桶的大小，其大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">B_{j}=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span> PBR × BSD。PBR和BSD都是由RRC层配置，RRC层在配置MAC实体时会设置这两个参数。</p>
<p>当MAC实体收到UL grant，需要进行新传时，UL grant的分配过程如下图所示，这个过程叫Logical Channel Prioritization procedure。<br>
<img src="/2022/06/17/LTE%E7%BD%91%E7%BB%9CMAC%E5%B1%82%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/2022-06-17-00-44-53.png#pic_center" alt="2022-06-17-00-44-53"></p>
<p>根据上图，MAC实体按以下过程对UL grant进行分配。</p>
<ol>
<li>按逻辑信道优先级从高到低的顺序对UL grant进行分配，对每个逻辑信道进行组包(MAC UL transport block)。注意，这里是按逻辑信道优先级排序。因为数字越小表示优先级越高，所以会从priority数字最小的逻辑信道开始进行组包。在分配UL grant给逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的时候，会先看看令牌桶还有多少令牌(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>有多大)，如果令牌数大于等于buffer的数据量(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>⩾</mo></mrow><annotation encoding="application/x-tex">B_{j}\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span></span></span></span>  buffer的数据量)，那么给逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的buffer有多少数据，就给它分配多少UL grant，当然如果UL grant不足以发送逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的buffer里所有的数据，那么有多少UL grant就给它分配多少UL grant。如果令牌数小于buffer的数据量(即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">B_{j}&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span></span></span>  buffer的数据量)，那么有多少令牌就分配多少UL grant，当然如果UL grant比令牌数还小，那就把所有的UL grant都分配给逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>。当逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的PBR设为&quot;infinity&quot;时，则在为其分配UL grant时不会考虑其<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的大小，所有的UL grant都会先分配给该逻辑信道，假如在发送完其buffer的数据后，还有剩余的UL grant，这时才会再将剩余的UL grant分配给其它的逻辑信道。</li>
<li>从逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>中减去步骤1所build的所有MAC SDUs的大小之和。(参考实现：对于逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，每传输一个RLC SDU，先比较<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>是否大于0。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则往MAC PDU中添加该SDU，然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>−</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">B_{j}-=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>sizeof(RLC SDU)，并判断是否满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>⩽</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}\leqslant 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，如此反复，直到满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>⩽</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}\leqslant 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，再处理下一逻辑信道)。</li>
<li>如果前两步执行完还剩有UL grant的话，则不管<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的大小，把剩余的UL grant按照逻辑信道优先级从高到低分配给各个逻辑信道。只有当高优先级的逻辑信道服务完(即所有的数据都发送完毕)，且还有剩余的UL grant可用于服务剩余的逻辑信道时，才会继续服务优先级较低的逻辑信道。对剩余的逻辑信道也是执行同样的逻辑。在这一步，因为所有的逻辑信道都已经得到了最低保障，因此不会再考虑公平的原则。MAC实体会尽全力服务高优先级的逻辑信道，尽可能地把高优先级的逻辑信道的数据尽快发送出去。</li>
</ol>
<p>在上述UL grant分配过程中，MAC层遵循以下原则：</p>
<ul>
<li>如果剩余的UL grant足够发送整个RLC SDU，则不应对该SDU分段。</li>
<li>如果受限于剩余UL grant的大小，不得不对RLC SDU分段，则应根据剩余UL grant的大小，尽可能地填入最大的分段。即尽可能地有效利用剩余的UL grant。</li>
<li>应最大化数据的传输。</li>
<li>如果某个无线承载(RB, radio bearer)被挂起(suspend)，那么不应该build该RB所对应逻辑信道的数据。</li>
<li>如果UL grant<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo></mrow><annotation encoding="application/x-tex">\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span></span></span></span> 4bytes，而buffer里还有数据要发送时，则MAC实体不应该把这些UL grant都用来发送padding BSR或者padding，换言之MAC实体应该尽可能发送有效数据，除非UL grant <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> 7bytes且要发送的数据是RLC PDU segment，此时因为UL grant不足以发送任何的RLC PDU payload，因此只能发送padding BSR或者padding。</li>
</ul>
<p>如果所有的逻辑信道的PBR都设为0 kBps，就不再保证各个逻辑信道的服务质量都能得到最低保障，此时就会退化为只考虑优先级的调度算法，等价于上面的算法只剩下第三步。在这种情况下，MAC实体会尽力服务优先级更高的逻辑信道，然后依次往下服务低优先级的逻辑信道。当然，对每个逻辑信道的服务都是建立在UL grant还有剩余的前提下，如果UL grant已经用完，那么剩余的逻辑信道在本次packet build就不能得到服务了。</p>
<p>在上述算法的第二步可以看到，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的值可能为负，这是因为，在算法的第一步，会遵循尽量不对RLC SDU分段的原则。在UL grant足够的情况下，宁可让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的使用超出预算，也要争取把RLC SDU给完整地build完。因此，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，但<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>−</mo></mrow><annotation encoding="application/x-tex">B_{j}-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">−</span></span></span></span>sizeof(RLC SDU)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，假如剩余的UL grant足够的话，MAC实体依然会在本次build完这个RLC SDU，而不是对其分段。在build完这个RLC SDU后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>将为负数，令牌桶的令牌已经用完，逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>就不能再build任何RLC SDU了。其后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>将逐渐恢复，在每个子帧，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">B_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都会增加PBR，只有当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>j</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B_{j}&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，即令牌桶又有令牌了，才能继续对逻辑信道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>进行packet build。</p>
<p>以上的算法可以用以下的伪代码表示(仅供参考，真正的实现有所出入)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sort the logic channel by priority</span><br><span class="line"></span><br><span class="line">iterate each active logic channel from highest priority to lowest</span><br><span class="line">  <span class="keyword">if</span> Bj &gt;= available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">    <span class="keyword">if</span> UL grant is sufficient to send all the available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      UL grant -= available data in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      build all the packet in the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allocate all the UL grant to the current logic channel</span><br><span class="line">      build all UL grant bytes <span class="keyword">for</span> the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> UL grant is sufficient to use up all the Bj</span><br><span class="line">      UL grant -= Bj</span><br><span class="line">      build Bj bytes RLC PDUs</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      allocate all the UL grant to the current logic channel</span><br><span class="line">      build all UL grant bytes <span class="keyword">for</span> the current logic channel<span class="number">&#x27;</span>s buffer</span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> there is still any UL grant left</span><br><span class="line">  iterate each active logic channel from highest priority to lowest</span><br><span class="line">    leftover UL grant is used to serve the leftover data in the buffer</span><br><span class="line">    <span class="keyword">if</span> there is no leftover UL grant</span><br><span class="line">      <span class="keyword">break</span>;        </span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] 深入理解LTE-A. 温金辉著. 第17章17.1节<br>
[2] 3GPP协议36.321. 第5.4.3.1节<br>
[3] Computer networks(fifth edition). By Andrew S. Tanenbaum etl. Section 5.4.2</p>
]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>MAC</tag>
      </tags>
  </entry>
  <entry>
    <title>LTE网络RLC层的polling机制</title>
    <url>/2022/06/16/LTE%E7%BD%91%E7%BB%9CRLC%E5%B1%82%E7%9A%84polling%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>本文将从UE角度对LTE网络RLC层的polling机制进行详细阐述。</p>
</blockquote>
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在LTE网络中，RLC层提供了两种服务模式，一种是保证数据无损传输(lossless)的<code>AM模式</code>(acknowledged mode)，另一种是不保证数据可靠传输的<code>UM模式</code>(unacknowledged mode)。在<code>AM模式</code>下，RLC层要保证数据可靠传输，因此，此时的RLC协议是一种<code>可靠性数据传输协议</code>(reliable data transmission protocol, RDP)。</p>
<p>RDP是网络协议中常用的一种协议，TCP协议就是其中之一。与TCP协议相比，RLC位于无线通信协议栈的更底层，对时延的要求更高。因此，为了更快地实现数据的无损传输，RLC层引入了<code>polling</code>(问询)机制。</p>
<h2 id="-more-"><a class="markdownIt-Anchor" href="#-more-"></a> <span id="more"></span></h2>
<h1 id="polling的目的"><a class="markdownIt-Anchor" href="#polling的目的"></a> Polling的目的</h1>
<p>UE<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="User equipment，在蜂窝网络中指终端设备，大部分场景下是手机，也可能是智能手表，智能仪表等其它无线终端设备。
">[1]</span></a></sup> 在向网络发送数据的过程中，由于物理层存在一定的误码率(BLER)，有一些包(packet, 即RLC PDU)有时候可能会在传输过程中发送失败或者丢失。但是，哪一些包发送失败了，从UE侧是无法知道的。因此，为了实现数据的可靠传输，UE需要网络侧的反馈，告诉UE在网络侧哪一些包已经收到，哪一些还没有收到，从而让UE能够重传那些网络还没收到的包，这个反馈就是<code>状态报告</code>(status report)。</p>
<p>但是网络侧怎么能够知道什么时候给UE发送<code>状态报告</code>呢？如果网络侧频繁不停地给UE发送<code>状态报告</code>，那么虽然UE能够很及时地知道网络侧接收情况，但是这样就浪费了很多下行资源；而如果网络侧周期性地给UE发送<code>状态报告</code>，那么UE侧又无法及时得知网络侧的接收情况。引入<code>Polling</code>就是为了这个目的。UE需要向网络询问，哪一些包收到了，哪一些还没收到，这样网络就会回复<code>状态报告</code>，UE就能及时地重传那些没被网络收到(acknowledged)的包。</p>
<hr>
<h1 id="polling的触发条件"><a class="markdownIt-Anchor" href="#polling的触发条件"></a> Polling的触发条件</h1>
<p>在每个RLC data PDU的header部分，有一个P位的标志位，这个标志位就代表<code>polling</code>。当P位为1时，表示UE向网络侧发送<code>polling</code>，期望对方回复<code>状态报告</code>，反之亦然。在以下任一条件满足的情况下，UE都会触发<code>polling</code>：</p>
<ul>
<li>PDU_WITHOUT_POLL &gt;= <em>pollPDU</em></li>
<li>BYTE_WITHOUT_POLL &gt;= <em>pollByte</em></li>
<li>在发送完当前的RLC data PDU后，buffer里不再剩余任何待发送的RLC data PDU</li>
<li><em>t-PollRetransmit</em> 定时器超时</li>
</ul>
<p>UE每发送一个新的RLC data PDU时，PDU_WITHOUT_POLL会加1；BYTE_WITHOUT_POLL也会增加sizeof(RLC PDU payload)。在更新了PDU_WITHOUT_POLL和BYTE_WITHOUT_POLL后，假如PDU_WITHOUT_POLL <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo></mrow><annotation encoding="application/x-tex">\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span></span></span></span> <em>pollPDU</em>，或者BYTE_WITHOUT_POLL <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⩾</mo></mrow><annotation encoding="application/x-tex">\geqslant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7733399999999999em;vertical-align:-0.13667em;"></span><span class="mrel amsrm">⩾</span></span></span></span> <em>pollByte</em> ，那么UE需要将该RLC PDU header的P位置1，向网络发送<code>polling</code>。这两个条件保证了UE每向网络发送一部分数据后，都能及时地知道这些数据在网络侧的接收情况。<em>pollPDU</em> 和 <em>pollByte</em> 由网络配置，通过RRC层向RLC层下发。</p>
<p>当UE发送buffer里最后一个新传RLC data PDU时，也应该置P位为1。这也是符合直觉的。因为在发送完最后一个新传RLC data PDU后，UE有可能很长时间都不会发送新的数据了，这时候前两个条件就无法触发了。因此，这时候需要向网络发送<code>polling</code>，获取网络的接收状态报告，然后及时地将前面还没发送成功的包给发送出去。</p>
<p>假如在上面的<code>polling</code>触发，并且重传RLC PDU后，网络侧还是有一些包没收到，而此时UE不再有新的包发送了，那么网络侧岂不是再也收不到这些没收到的包了？针对这个问题，RLC层提供了最后一个polling触发条件，保证了在这种场景下，UE还能向网络发送这些丢失的包。UE在RLC层有一个 <em>t-PollRetransmit</em> 定时器，每当UE发送了<code>polling</code>后，都会启动 <em>t-PollRetransmit</em> 定时器(或者重启，假如此时定时器还在运行)。当 <em>t-PollRetransmit</em> 定时器超时时，假如</p>
<ul>
<li>buffer(包括RLC data PDU新传队列和重传队列)为空</li>
<li>或者无法发送新传RLC PDU(比如此时因为收不到给VT(A)的ACK，导致window stall了)</li>
</ul>
<p>那么UE需要向网络重传一包RLC data PDU，并将该RLC data PDU的P位置1，向网络发送<code>polling</code>，这样就保证了在无法发送新传的数据时，UE还能收到网络的<code>状态报告</code>，从而重传之前丢失的包，补齐网络侧的接收窗口，而不至于让网络侧长时间无法完全收到这些包。UE在这种场景下向网络侧重传的RLC data PDU，可以选择以下两种之一：</p>
<ul>
<li>SN<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Sequence number，每一包RLC data PDU都有一个sequence number，在一段时间内可以唯一标识这包RLC data PDU。">[2]</span></a></sup>为VT(S) – 1的RLC data PDU，即发送窗口最右侧的那个RLC data PDU</li>
<li>发送窗口中任何一个还没被网络侧确认已经收到的RLC data PDU</li>
</ul>
<hr>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文从UE侧角度介绍了LTE网络RLC层的一个基本功能——<code>polling</code>机制。<code>polling</code>机制只在<code>AM模式</code>下才会生效，其目的是为了能及时得知网络侧的接收情况，从而及时地向网络重传丢失的数据包，保证数据的低时延可靠传输。最后介绍了<code>polling</code>的触发条件。</p>
<hr>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] 3GPP协议 36322 section 5.2.2<br>
[2] <font color="DodgerBlue">Radio Protocols for LTE and LTE-Advanced (2012)</font> by SeungJune Yi, SungDuck Chun, etl. section 5.4.4<br>
[3] 深入理解LTE-A. 温金辉著. section 36.3.3.2</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">User equipment，在蜂窝网络中指终端设备，大部分场景下是手机，也可能是智能手表，智能仪表等其它无线终端设备。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Sequence number，每一包RLC data PDU都有一个sequence number，在一段时间内可以唯一标识这包RLC data PDU。<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>RLC</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04编译及安装LLDB</title>
    <url>/2021/12/16/compile-and-install-lldb/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#%E7%AE%80%E4%BB%8B">在ubuntu20.04安装LLVM</a>已经介绍了如何在本地编译及安装llvm，但是当时只是编译和安装了<code>llvm;clang;libcxx;libcxxabi</code>这四个库，本文将介绍如何编译及安装lldb。</p>
<span id="more"></span>
<h1 id="配置及安装lldb"><a class="markdownIt-Anchor" href="#配置及安装lldb"></a> 配置及安装LLDB</h1>
<p>在进行下面的步骤时，假设你已经下载了llvm整个工程，并且安装了所需的依赖工具。如果你还没进行这些操作，可以参考<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#%E7%AE%80%E4%BB%8B">在ubuntu20.04安装LLVM</a>一文的<code>本地编译安装LLVM</code>一节的<code>前提条件</code>和<code>下载LLVM源文件</code>这两部分内容，先完成这两步。</p>
<p>完成上述步骤后，输入以下命令。首先cd进入llvm-project工程，然后生成cmake文件。<code>-S llvm</code>表示源文件所在文件夹为当前路径下的llvm文件夹；<code>-B build</code>表示生成的cmake文件将放到当前路径下的build文件夹；<code>-G Ninja</code>表示生成的cmake文件将给Ninja在编译时使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build #若已经创建build目录此步可以省略</span><br><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; #1,这条命令与下面这条命令2选1</span><br><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; ./llvm #2,这条命令与上面的命令2选1</span><br><span class="line">cd build</span><br><span class="line">ninja lldb</span><br></pre></td></tr></table></figure>
<p>在编译到第[4169/4171]个文件时，会出现以下错误。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-18-17-22-28.png" alt="2021-12-18-17-22-28"><br>
参考<a href="https://blog.csdn.net/Vin_tt/article/details/110421022">这篇文章</a>解决这个问题，输入以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project/build</span><br><span class="line">sudo mkdir swapfile</span><br><span class="line">cd /swapfile</span><br><span class="line">sudo dd if=/dev/zero of=swap bs=1024 count=20000000</span><br><span class="line">sudo mkswap -f swap</span><br><span class="line">sudo swapon swap</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/16/compile-and-install-lldb/2021-12-18-17-56-57.png" alt="2021-12-18-17-56-57"><br>
可以看到，剩下的三个文件都被成功地编译了。编译出来生成的应用程序位于llvm-project/build/bin路径下，将其拷贝到/usr/local/bin/文件夹下即可。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-18-18-17-50.png" alt="2021-12-18-18-17-50"></p>
<h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1>
<p>这部分讲的是后续的失败经历，以及没有解决的问题。</p>
<p>上述编译命令在编译lldb过程中会有debug信息，其体积会很大，而且编译出来的文件在llvm-project/build文件夹下面，还需要<code>ninja install</code>命令将其安装至默认路径下，但是由于体积过大，在安装时容易出问题。最好是编译release版本，并且在生成cmake文件的时候指明安装路径，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project</span><br><span class="line">mkdir build #若已经创建build目录此步可以省略</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;lldb&quot;</span> <span class="comment">#1,这条命令与下面这条命令2选1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;lldb&quot;</span> ./llvm <span class="comment">#2,这条命令与上面的命令2选1</span></span></span><br><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLDB_INCLUDE_TESTS=OFF -DCMAKE_INSTALL_PREFIX=&quot;/usr/local/llvm&quot; #1,这条命令与下面这条命令2选1</span><br><span class="line">cmake -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;lldb&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLDB_INCLUDE_TESTS=OFF -DCMAKE_INSTALL_PREFIX=&quot;/usr/local/llvm&quot; ./llvm #2,这条命令与上面的命令2选1</span><br><span class="line">cd build</span><br><span class="line">ninja lldb</span><br></pre></td></tr></table></figure>
<p>编译完成后，生成的文件位于llvm-project/build文件夹内，我们要把它们安装到/usr/local/路径下，因此，需要输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ninja install</span><br></pre></td></tr></table></figure>
<p>然后就会开始将lldb安装到/usr/local/路径下,在安装到第[203/1128]个文件时，出现了<code>fatal error: ld terminated with signal 9 [Killed]</code>错误，参照上面的方法，在build文件夹创建swapfile尝试解决。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-21-23-18-01.png" alt="2021-12-21-23-18-01"><br>
在安装剩下的文件时，安装到[375/927]个文件时仍然出现了以上错误。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-22-08-27-51.png" alt="2021-12-22-08-27-51"><br>
再次尝试用上述方法安装剩下的文件。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-22-08-39-08.png" alt="2021-12-22-08-39-08"><br>
依旧出现以上问题，最终只得作罢。<br>
<img src="/2021/12/16/compile-and-install-lldb/2021-12-22-09-05-29.png" alt="2021-12-22-09-05-29"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://lldb.llvm.org/resources/build.html#building-lldb-with-cmake">Building LLDB with CMake</a></li>
<li><a href="https://blog.csdn.net/Vin_tt/article/details/110421022">LLVM编译collect2: fatal error: ld terminated with signal 9</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04编译lldb-mi</title>
    <url>/2021/12/28/compile-lldb-mi/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>lldb-mi(lldb machine interface)是一个C/C<ins>调试器，原来是LLVM项目中lldb的一部分，但是由于长时间没有人维护和更新，于是是从LLVM项目的lldb中分了出去，成为单独的一个工程。在linux环境下，使用vscode对C/C</ins>代码进行调试时，常用的调试器是GDB，除此之外，还有个选择就是lldb-mi。本文将介绍如何在本地对lldb-mi工程源码进行编译，从而生成可执行文件。编译lldb-mi，需要一个C++14编译器以及LLDB，而LLDB又依赖于Clang和LLVM，因此，在编译lldb-mi之前，需要先安装Clang，LLVM和LLDB，可以参考<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/">这篇博客</a>进行安装。</p>
<span id="more"></span>
<h1 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h1>
<p>输入以下命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ #进入home目录</span><br><span class="line">mkdir buildspace #在home目录下建立buildspace目录</span><br><span class="line">cd ~/buildspace #进入buildspace目录</span><br><span class="line">mkdir llvm-inst #创建llvm-inst目录</span><br><span class="line">git clone https://github.com/lldb-tools/lldb-mi #将lldb-mi工程下载到当前目录（即buildspace目录）</span><br><span class="line">cd lldb-mi #进入lldb-mi工程目录里</span><br><span class="line">mkdir build #在当前目录（即lldb-mi目录）建立build目录，用来存放编译后生成的文件</span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=~/buildspace/llvm-inst/ -GNinja .. #在当前目录（即build目录）的上一级目录（即lldb-mi目录）下生成cmake文件</span><br><span class="line">ninja #编译</span><br></pre></td></tr></table></figure>
<p>执行完以上命令后，可以看到，所生成的lldb-mi可执行文件将位于lldb-mi/build/src目录下，这个就是lldb-mi调试器。然后，我们就可以开始在vscode中使用这个调试器对程序进行调试了。<br>
<img src="/2021/12/28/compile-lldb-mi/2021-12-29-00-49-15.png" alt="2021-12-29-00-49-15"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://github.com/lldb-tools/lldb-mi">Building against custom LLDB</a></li>
<li><a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/">在ubuntu20.04安装LLVM</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
        <tag>lldb-mi</tag>
        <tag>调试器</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/27/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>在ubuntu20.04安装最新版GCC</title>
    <url>/2021/12/10/install-latest-gcc/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>在<a href="https://yang-yuke.github.io/2021/12/04/ubuntu-install-llvm/#more">编译LLVM</a>过程中，出现了很多头文件无法解析的错误，根据<a href="https://reviews.llvm.org/rGac7031b2b2fa">网上的说法</a>，原因是因为GCC版本过低，将GCC升级至最新版11.2.0就可以解决这个问题了。本文将介绍如何升级GCC到最新版(当前为11.2.0)。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-33-08.png" alt="2021-12-10-23-33-08"></p>
<span id="more"></span>
<h1 id="下载gcc最新源码包"><a class="markdownIt-Anchor" href="#下载gcc最新源码包"></a> 下载gcc最新源码包</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gcc/gcc-11.2.0/gcc-11.2.0.tar.gz</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-19-24-58.png" alt="2021-12-10-19-24-58"></p>
<h1 id="解压缩"><a class="markdownIt-Anchor" href="#解压缩"></a> 解压缩</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf gcc-11.2.0.tar.gz</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-19-27-42.png" alt="2021-12-10-19-27-42"></p>
<h1 id="进入解压缩目录"><a class="markdownIt-Anchor" href="#进入解压缩目录"></a> 进入解压缩目录</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd gcc-11.2.0</span><br></pre></td></tr></table></figure>
<h1 id="运行预备库下载脚本"><a class="markdownIt-Anchor" href="#运行预备库下载脚本"></a> 运行预备库下载脚本</h1>
<p>运行download_prerequisites脚本,这个脚本会自动帮你下载所需要的依赖文件和库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
<p>在运行该脚本时，出现以下错误，无法下载依赖文件库<code>gmp-6.1.0.tar.bz2</code>。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-37-55.png" alt="2021-12-10-19-37-55"><br>
解决办法为改从清华镜像源下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gmp/gmp-6.1.0.tar.bz2 #从清华镜像源下载gmp-6.1.0.tar.bz2文件</span><br><span class="line">tar xvfj gmp-6.1.0.tar.bz2 #解压缩文件</span><br><span class="line">ln -s gmp-6.1.0 gmp #在当前目录下创建名为gmp的快捷方式，链接到gmp-6.1.0文件夹</span><br></pre></td></tr></table></figure>
<p>改从清华镜像源下载后速度真的很快。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-44-43.png" alt="2021-12-10-19-44-43"><br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-45-18.png" alt="2021-12-10-19-45-18"><br>
继续执行脚本下载依赖文件，出现以下错误，无法下载依赖文件库<code>mpfr-3.1.6.tar.bz2</code>。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-50-42.png" alt="2021-12-10-19-50-42"><br>
解决办法为改从清华镜像源下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpfr/mpfr-3.1.6.tar.bz2 #从清华镜像源下载mpfr-3.1.6.tar.bz2文件</span><br><span class="line">tar xvfj mpfr-3.1.6.tar.bz2 #解压缩文件</span><br><span class="line">ln -s mpfr-3.1.6 mpfr #在当前目录下创建名为mpfr的快捷方式，链接到mpfr-3.1.6文件夹</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-19-54-01.png" alt="2021-12-10-19-54-01"><br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-19-54-59.png" alt="2021-12-10-19-54-59"><br>
继续执行脚本下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
<p>出现以下错误，无法下载<code>mpc-1.0.3.tar.gz</code>文件，<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-20-04-14.png" alt="2021-12-10-20-04-14"><br>
解决办法为改从清华镜像源下载，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gnu/mpc/mpc-1.0.3.tar.gz</span><br><span class="line">tar xvfz mpc-1.0.3.tar.gz</span><br><span class="line">ln -s mpc-1.0.3 mpc #在当前目录下创建名为mpc的快捷方式，链接到mpc-1.0.3文件夹</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-20-07-46.png" alt="2021-12-10-20-07-46"><br>
继续执行下载脚本，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./contrib/download_prerequisites </span><br></pre></td></tr></table></figure>
<p>出现以下错误，无法下载<code>isl-0.18.tar.bz2</code>文件，<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-20-23-02.png" alt="2021-12-10-20-23-02"><br>
因为这个文件在清华镜像源上没有，因此解决办法为从GNU官网通过http下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2</span><br><span class="line">tar xvfj isl-0.18.tar.bz2</span><br><span class="line">ln -s isl-0.18 isl</span><br></pre></td></tr></table></figure>
<h1 id="创建编译目录"><a class="markdownIt-Anchor" href="#创建编译目录"></a> 创建编译目录</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir gcc-build</span><br><span class="line">cd $_</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-20-30-04.png" alt="2021-12-10-20-30-04"></p>
<h1 id="生成makefile文件"><a class="markdownIt-Anchor" href="#生成makefile文件"></a> 生成Makefile文件</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib #../configure表示返回上级目录执行configure命令</span><br></pre></td></tr></table></figure>
<p><code>–enable-languages</code>表示你要让你的gcc支持那些语言，<code>–disable-multilib</code>表示不生成编译为其他平台可执行代码的交叉编译器。<code>–disable-checking</code>表示生成的编译器在编译过程中不做额外检查，也可以使用<code>–enable-checking=xxx</code>来增加一些检查。</p>
<h1 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>这里-j8表示的是使用8核进行编译，因为我的电脑CPU为8核。因为make默认是serial build的，如果不加-j选项，就不会开启多核parallel build，这样的话速度会慢很多，所以这里我开启了8核编译。即便如此，这一步花费时间也非常长，我在虚拟机里用了将近两个小时完成这一步，而且虚拟机一定要留出至少20GB的空间，不然可能会出现磁盘不足的问题。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-20-38-17.png" alt="2021-12-10-20-38-17"></p>
<h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su root #安装GCC需要root权限，这里先切换为root用户</span><br><span class="line">make install #安装</span><br><span class="line">source /etc/profile #安装完成后手动刷新一下profile</span><br><span class="line">gcc -v #检查当前gcc版本</span><br></pre></td></tr></table></figure>
<p>可以看到，当前的gcc版本更新到了11.2.0，至此安装成功。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-22-35-17.png" alt="2021-12-10-22-35-17"></p>
<h1 id="环境变量设置"><a class="markdownIt-Anchor" href="#环境变量设置"></a> 环境变量设置</h1>
<p>在安装GCC完成后，可以将其永久地加入到系统路径中，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su yukeyang #这里yukeyang替换成你的用户名，先从root用户切换回超级用户</span><br><span class="line">cd ~/ #cd进入当前用户(我的是yukeyang)的home目录</span><br><span class="line">code .bashrc #用vscode打开.bashrc文件</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/10/install-latest-gcc/2021-12-10-22-46-15.png" alt="2021-12-10-22-46-15"><br>
GCC可执行程序所在路径为：<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-24-28.png" alt="2021-12-10-23-24-28"><br>
因此，将以下两行加入到.bashrc文件中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/bin:$PATH #设置GCC可执行程序路径</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib64:$LD_LIBRARY_PATH #设置动态链接库路径</span><br></pre></td></tr></table></figure>
<p>至此就完成了所有步骤了，更多的环境变量设置，可以参考<a href="https://www.cnblogs.com/jessepeng/p/11674780.html">这篇博客</a>。<br>
<img src="/2021/12/10/install-latest-gcc/2021-12-10-23-26-40.png" alt="2021-12-10-23-26-40"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1532384">centos 编译安装gcc8.1</a></li>
<li><a href="https://solarianprogrammer.com/2016/10/07/building-gcc-ubuntu-linux/">Building GCC 10 on Ubuntu Linux</a></li>
<li><a href="https://blog.csdn.net/21aspnet/article/details/105708122">安装最新的GCC</a></li>
<li><a href="https://www.cnblogs.com/jessepeng/p/11674780.html">[Linux] 非root安装GCC9.1.0</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu20.04安装LLVM</title>
    <url>/2021/12/04/ubuntu-install-llvm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>在ubuntu20.04上安装LLVM，主要有四种方法。</p>
<ul>
<li>方法一：运行官方的自动安装脚本进行安装</li>
<li>方法二：通过包管理器进行安装</li>
<li>方法三：使用官方预编译二进制文件进行安装</li>
<li>方法四：从源码编译安装</li>
</ul>
<span id="more"></span>
<p>第一种方法最为简单，只需要一条命令，执行一下脚本，就不要进行任何操作了。第二种方法较第一种要麻烦一点点，但是也比较简单。第三种办法要麻烦点，但是会比较快，简单来说就是直接到网上下载预编译好的binary文件，将其下载到ubuntu20.04系统中，然后解压，再把解压后的所有文件全部拷贝到系统的/usr/local文件夹下，然后就可以使用了。第四种方法最为麻烦，而且很慢，简单来说就是从网上下载LLVM工程的源代码到ubuntu系统，然后在本机上编译，编译完成再安装。</p>
<p>如果只是为了使用LLVM的工具链，个人建议采用方法一或者二和三(我安装的时候使用的是方法三)，简单快捷。如果为了体验一下在本地编译LLVM工程那种更原汁原味的感觉，可以采用方法四，但是这种方法比较麻烦，因为需要安装一些依赖工具，并且在本地编译LLVM耗时严重，整个过程将会相当漫长，所以如果时间预算不是很充足，又或者电脑配置不太好的情况下，我不建议采用方法四。当然，这里四种方法的过程我都会介绍。</p>
<h1 id="使用官方安装脚本安装"><a class="markdownIt-Anchor" href="#使用官方安装脚本安装"></a> 使用官方安装脚本安装</h1>
<p>首先介绍第一种方法，这种方法又有两个选择，第一个是可以选择安装最新版本的，另外一个就是安装某个特定版本。参考下图，来自<a href="https://apt.llvm.org/">官网</a>的介绍。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-08-23-55-45.png" alt="2021-12-08-23-55-45"></p>
<blockquote>
<p>For convenience there is an automatic installation script available that installs LLVM for you.<br>
To install the latest stable version:<br>
bash -c “$(wget -O - <a href="https://apt.llvm.org/llvm.sh">https://apt.llvm.org/llvm.sh</a>)”</p>
<p>To install a specific version of LLVM:<br>
wget <a href="https://apt.llvm.org/llvm.sh">https://apt.llvm.org/llvm.sh</a><br>
chmod +x <a href="http://llvm.sh">llvm.sh</a><br>
sudo ./llvm.sh <version number></version></p>
</blockquote>
<h2 id="安装最新稳定版llvm"><a class="markdownIt-Anchor" href="#安装最新稳定版llvm"></a> 安装最新稳定版LLVM</h2>
<p>在ubuntu命令终端执行以下命令，将会运行官网上的llvm.sh这个shell脚本，自动给你安装最新的稳定版本的llvm了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(wget -O - https://apt.llvm.org/llvm.sh)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="安装特定版llvm"><a class="markdownIt-Anchor" href="#安装特定版llvm"></a> 安装特定版LLVM</h2>
<p>假如我们想用老的版本的话，我们也可以指明某个特定的版本进行安装，在ubuntu命令终端执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh &lt;version number&gt;</span><br></pre></td></tr></table></figure>
<p>其中，&lt;version number&gt;需要替换成你想安装的那个版本的版本号。例如，假如我们想安装13版本的LLVM时，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line">chmod +x llvm.sh</span><br><span class="line">sudo ./llvm.sh 13</span><br></pre></td></tr></table></figure>
<h1 id="使用包管理器安装"><a class="markdownIt-Anchor" href="#使用包管理器安装"></a> 使用包管理器安装</h1>
<p>使用包管理器安装，我们需要先修改<code>/etc/apt/source.list</code>，参考以下<a href="https://apt.llvm.org/">官方内容</a>，我们需要先在<code>/etc/apt/source.list</code>加入以下内容，<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-15-09.png" alt="2021-12-09-00-15-09"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">12</span></span><br><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal-12 main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-12 main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">13</span></span><br><span class="line">deb http://apt.llvm.org/focal/ llvm-toolchain-focal-13 main</span><br><span class="line">deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-13 main</span><br></pre></td></tr></table></figure>
<p>加上以上内容后，我们有三种方法可以安装LLVM。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<p>执行以下shell命令，执行后将会安装LLVM release 13。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LLVM</span></span><br><span class="line">apt install libllvm-13-ocaml-dev libllvm13 llvm-13 llvm-13-dev llvm-13-doc llvm-13-examples llvm-13-runtime</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clang and co</span></span><br><span class="line">apt install clang-13 clang-tools-13 clang-13-doc libclang-common-13-dev libclang-13-dev libclang1-13 clang-format-13 python-clang-13 clangd-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libfuzzer</span></span><br><span class="line">apt install libfuzzer-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lldb</span></span><br><span class="line">apt install lldb-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lld (linker)</span></span><br><span class="line">apt install lld-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libc++</span></span><br><span class="line">apt install libc++-13-dev libc++abi-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenMP</span></span><br><span class="line">apt install libomp-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libclc</span></span><br><span class="line">apt install libclc-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libunwind</span></span><br><span class="line">apt install libunwind-13-dev</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<p>参考官网，执行以下shell命令，执行后将会为我们安装最新版本的LLVM（当前版本为version 14）<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-40-49.png" alt="2021-12-09-00-40-49"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install clang-format clang-tidy clang-tools clang clangd libc++-dev libc++1 libc++abi-dev libc++abi1 libclang-dev libclang1 liblldb-dev libllvm-ocaml-dev libomp-dev libomp5 lld lldb llvm-dev llvm-runtime llvm python-clang</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<p>这种方法是用来安装特定稳定版本的LLVM的，参考官网。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-09-00-42-26.png" alt="2021-12-09-00-42-26"><br>
以安装13版本为例，首先我们需要获取文档签名，执行以下shell命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key|sudo apt-key add -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fingerprint: 6084 F3CF 814B 57C1 CF12 EFD5 15CF 4D18 AF4F 7421</span></span><br></pre></td></tr></table></figure>
<p>获取签名后，我们就可以安装LLVM了。假如我们只想安装其中的clang，lld和lldb库(13 release)，我们可以执行以下shell命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install clang-13 lldb-13 lld-13</span><br></pre></td></tr></table></figure>
<p>假如我们想安装所有的关键的库，那就不要执行上述命令，而是执行以下shell命令，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LLVM</span></span><br><span class="line">apt-get install libllvm-13-ocaml-dev libllvm13 llvm-13 llvm-13-dev llvm-13-doc llvm-13-examples llvm-13-runtime</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clang and co</span></span><br><span class="line">apt-get install clang-13 clang-tools-13 clang-13-doc libclang-common-13-dev libclang-13-dev libclang1-13 clang-format-13 python-clang-13 clangd-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libfuzzer</span></span><br><span class="line">apt-get install libfuzzer-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lldb</span></span><br><span class="line">apt-get install lldb-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lld (linker)</span></span><br><span class="line">apt-get install lld-13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libc++</span></span><br><span class="line">apt-get install libc++-13-dev libc++abi-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OpenMP</span></span><br><span class="line">apt-get install libomp-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libclc</span></span><br><span class="line">apt-get install libclc-13-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libunwind</span></span><br><span class="line">apt-get install libunwind-13-dev</span><br></pre></td></tr></table></figure>
<h1 id="使用预编译二进制文件安装"><a class="markdownIt-Anchor" href="#使用预编译二进制文件安装"></a> 使用预编译二进制文件安装</h1>
<h2 id="下载文件"><a class="markdownIt-Anchor" href="#下载文件"></a> 下载文件</h2>
<p>接下来介绍方法三，使用预编译二进制文件安装。顾名思义，预编译二进制文件就是说别人已经帮你编译好LLVM工程，生成了二进制文件，你所需的只是将其下载下来，然后放到合适的位置，就可以使用了。从哪里下载LLVM预编译二进制文件呢？这里我提供两个可选的地址。一个是<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-13.0.0">官方Github仓库</a>，LLVM项目组已经将他们的工程放到了这个Github仓库里了，我们只要从里面下载<code>clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</code>(假如你的操作系统是ubuntu20.04版本的话)或者<code>clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-16.04.tar.xz</code>(假如你的操作系统是ubuntu16.04版本的话)，将其下载到ubuntu系统本地即可。由于国内访问Github网速较慢，而我们所下载的压缩文件大小为500MB左右，为了节省时间起见，我个人建议从另一个地址下载，那就是国内的<a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/llvm/llvm-project/LatestRelease/">清华镜像源</a>。</p>
<h2 id="安装文件"><a class="markdownIt-Anchor" href="#安装文件"></a> 安装文件</h2>
<p>下载好二进制文件到ubuntu系统本地后，我们需要先将文件解压，然后再安装。先解压文件，解压的命令如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xz -d clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz #此处你下载的包是clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz，这里是第一步解压</span><br><span class="line">tar -xvf clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz #此处已经是上一步解压完了，文件夹里剩下的是.tar文件</span><br></pre></td></tr></table></figure>
<p>然后再将解压后文件夹下的5个文件夹（bin,include,share,lib,libexec）及里面的所有文件全部复制到/usr/local目录下即可，复制命令如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/* /usr/local/ #此处的*代表这个目录下的五个文件都要被复制</span><br></pre></td></tr></table></figure>
<p>也可以一个一个文件夹地复制，命令如下。注意，如果/usr/local/没有对应的文件夹(e.g. libexec)时，需要先创建该文件夹，然后再复制解压到对应文件夹里面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/bin/* /usr/local/bin/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/include/* /usr/local/include/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/share/* /usr/local/share/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/lib/* /usr/local/lib/ #此处的*代表这个目录下的五个文件都要被复制</span><br><span class="line">sudo cp -r clang+llvm-11.0.0-x86_64-linux-gnu-ubuntu-20.04/libexec/* /usr/local/libexec/ #此处的*代表这个目录下的五个文件都要被复制</span><br></pre></td></tr></table></figure>
<p>完成以上步骤后，我们就可以使用clang了，先测试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang --version</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-04-17-16-26.png" alt="2021-12-04-17-16-26"><br>
可以看到，我们已经成功安装clang，版本为13.0.0，接下来就可以愉快地使用了。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>总结来说，就是执行以下命令,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不从Github下载，而是从清华镜像源下载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo wget https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span></span><br><span class="line">sudo wget https://mirrors.tuna.tsinghua.edu.cn/github-release/llvm/llvm-project/LatestRelease/clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span><br><span class="line">sudo tar xvf clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz</span><br><span class="line">sudo mv clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04 llvm</span><br><span class="line">export PATH=&quot;$PATH:/usr/local/llvm/bin&quot;</span><br></pre></td></tr></table></figure>
<h1 id="本地编译安装llvm"><a class="markdownIt-Anchor" href="#本地编译安装llvm"></a> 本地编译安装LLVM</h1>
<h2 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h2>
<p>下面介绍方法四，在安装前，需要先安装以下工具，这些工具会在编译LLVM工程过程中使用到，参考<a href="https://llvm.org/docs/GettingStarted.html">官网</a>说明：<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-03-12.png" alt="2021-12-10-14-03-12"></p>
<ul>
<li>CMake &gt;= 3.13.4</li>
<li>GCC &gt;= 5.1.0</li>
<li>Python &gt;= 3.6</li>
<li>zlib &gt;= 1.2.3.4</li>
<li>GNU Make &gt;= 3.79</li>
<li>Ninja &gt;= 1.10.0</li>
</ul>
<p>在ubuntu系统上<a href="https://zhuanlan.zhihu.com/p/321882707">安装Ninja</a>和<a href="https://blog.csdn.net/lj402159806/article/details/76408597">安装CMake</a>非常简单，执行以下命令即可，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ninja-build</span><br><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure>
<h2 id="下载llvm源文件"><a class="markdownIt-Anchor" href="#下载llvm源文件"></a> 下载LLVM源文件</h2>
<p>下载LLVM工程源文件到本地，然后在本地编译，再安装。首先我们需要下载LLVM工程源代码，这里我们可以选择从官方Github仓库下载或者是从清华镜像源下载，个人建议从清华镜像源下载，因为这样会快很多。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/llvm/llvm-project.git #地址一，从官方Github仓库下载</span><br><span class="line">git clone https://mirrors.tuna.tsinghua.edu.cn/git/llvm-project.git #地址二，从清华镜像源下载</span><br></pre></td></tr></table></figure>
<p>下载完成后可以看到llvm-project文件夹了。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-11-04.png" alt="2021-12-10-14-11-04"></p>
<h2 id="配置llvm"><a class="markdownIt-Anchor" href="#配置llvm"></a> 配置LLVM</h2>
<p>下载完LLVM项目源文件后，下一步就是编译这些源文件了。这里推荐使用Ninja来编译，速度会快很多，当然也可以使用其他编译系统生成工具，比如Unix Makefiles等。在使用Ninja进行编译之前，我们还需要生成编译过程所需编译文件，这些文件会告诉Ninja如何对LLVM-project进行编译。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-17-16.png" alt="2021-12-10-14-17-16"><br>
运行以下shell命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project #cd进入llvm-project文件夹</span><br><span class="line">mkdir build #在llvm-project文件夹创建build文件夹</span><br><span class="line">cd build #cd进入build文件夹</span><br><span class="line">cmake -G Ninja ../llvm #在当前目录(build)生成Ninja编译过程所需的文件，cmake的源文件目录为llvm-project下的llvm文件夹</span><br></pre></td></tr></table></figure>
<p>上面的第四条命令，格式为<code>cmake -G &lt;generator&gt; [options] ../llvm</code>,这里的generator我选择的是Ninja。options则表示可选的选项，常用的有<code>-DLLVM_ENABLE_PROJECTS</code>，表示除了LLVM，你还想编译哪些LLVM子项目。比如，如果除了LLVM外，你还想编译Clang，libcxx和libcxxabi，那么你可以使用编译选项<code>-DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot;</code>，上述的第四条命令就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; ../llvm </span><br></pre></td></tr></table></figure>
<p>也可以不运行上面的shell命令，而是运行下面的shell命令（参考<a href="https://github.com/llvm/llvm-project">官网指导</a>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd llvm-project #cd进入llvm-project文件夹</span><br><span class="line">mkdir build #在llvm-project文件夹创建build文件夹</span><br><span class="line">cmake -S llvm -B build -G Ninja #对llvm文件夹下的源文件进行cmake，生成的文件放在build目录下，生成的文件将在Ninja编译过程使用</span><br></pre></td></tr></table></figure>
<p>上面的第三条命令，格式为<code>cmake -S llvm -B build -G &lt;generator&gt; [options]</code>,-S表示cmake的源文件所在文件夹，这里是llvm。-B表示cmake后生成的文件所在的文件夹，这里是build文件夹。-G表示将要使用这些生成的cmake文件来编译的工具，这里是Ninja。如果不清楚这些cmake短选项的含义的话，可以<code>cmake -help</code>查看一下帮助。后面的<code>[options]</code>则表示其它的cmake选项，常用的有<code>-DLLVM_ENABLE_PROJECTS='...'</code>，具体含义如前所述。假如我们除了llvm子项目以外，还想编译其它的子项目，比如Clang，libcxx，libcxxabi，那我们可以使用<code>-DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</code>选项，上面第三条shell命令就是:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-14-45-31.png" alt="2021-12-10-14-45-31"><br>
cmake完成后可以看到编译文件已被写到build文件夹下。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-15-01-48.png" alt="2021-12-10-15-01-48"></p>
<h2 id="编译llvm"><a class="markdownIt-Anchor" href="#编译llvm"></a> 编译LLVM</h2>
<p>生成Ninja编译LLVM所需的文件后，下一步就是编译llvm了，参考<a href="https://github.com/llvm/llvm-project">官网</a>，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p>上述命令的格式为<code>cmake --build build [-- [options] &lt;target&gt;]</code>，–build指明编译后文件写入的文件夹，这里是build文件夹。–target选项指明所使用的编译工具，假如安装了Ninja的话，默认的target是Ninja。也可以输入以下命令，显式地调用Ninja:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">ninja -j 8</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-12-39-32.png" alt="2021-12-11-12-39-32"><br>
在编译到第3257个文件的时候，可能会发生如下错误：<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-19-07-48.png" alt="2021-12-10-19-07-48"><br>
原因是因为我的GCC版本太低了，还是9.3.0版本。根据<a href="https://reviews.llvm.org/rGac7031b2b2fa">网上的说法</a>，升级到11.2.0版（也是当前的最新版）就可以解决这个问题了，因此，需要<a href="https://yang-yuke.github.io/2021/12/10/install-latest-gcc/">升级GCC到最新版</a>。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-10-19-05-59.png" alt="2021-12-10-19-05-59"><br>
在升级到最新版GCC后，再重复上面的编译命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot;</span><br><span class="line">cd build</span><br><span class="line">ninja -j 8</span><br></pre></td></tr></table></figure>
<p>依然出现了大量以下错误，<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-24-36.png" alt="2021-12-11-16-24-36"><br>
这些错误是在编译libcxxabi库的cpp文件时出现的，说明有可能是我们在cmake配置编译的时候出了问题，回到<a href="https://llvm.org/docs/GettingStarted.html">LLVM官网Get started页面</a>，发现与<a href="https://github.com/llvm/llvm-project">LLVM Github Get started</a>上对<code>DLLVM_ENABLE_PROJECTS</code>编译选项的细节描述有点出入，<code>&quot;libcxx;libcxxabi&quot;</code>应该要放到<code>DLLVM_ENABLE_RUNTIMES</code>编译选项里，而不是<code>DLLVM_ENABLE_PROJECTS</code>里面。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-29-07.png" alt="2021-12-11-16-29-07"><br>
于是，重新进行cmake配置和编译，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot;</span><br><span class="line">cd build</span><br><span class="line">ninja -j8</span><br></pre></td></tr></table></figure>
<p>此时，发现能够继续往下编译了，但是每编译十几个cpp文件后就会出现以下错误“fatal error: ld terminated with signal 9 [Killed]”，然后就停止了。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-16-32-11.png" alt="2021-12-11-16-32-11"><br>
查了一下，<a href="https://stackoverflow.com/questions/65633304/not-able-to-build-llvm-from-its-source-code">这里</a>提到有可能是因为内存不足所致的，于是重新配置并编译，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -S llvm -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi&quot; -DLLVM_PARALLEL_LINK_JOBS=1</span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-38-00.png" alt="2021-12-11-18-38-00"><br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-38-29.png" alt="2021-12-11-18-38-29"><br>
上述命令中，<code>-DCMAKE_BUILD_TYPE=Release</code>表示编译的版本是release版本，release版本要小很多，如果不指明的话编译的就是debug版本。<code>-DLLVM_PARALLEL_LINK_JOBS=1</code>表示不开parallel build。等待一段时间后，可以看到这一次可以完全编译所有的文件了。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-11-18-42-53.png" alt="2021-12-11-18-42-53"><br>
编译完成后，需要切换到root用户进行安装，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd build #cd进入llvm-project/build文件夹</span><br><span class="line">sudo su root #切换到root用户权限</span><br><span class="line">ninja install #安装llvm</span><br></pre></td></tr></table></figure>
<p>安装完成后，可以看到clang已被安装到<code>/usr/local/bin</code>路径下，说明安装已经成功。<br>
<img src="/2021/12/04/ubuntu-install-llvm/2021-12-13-22-17-01.png" alt="2021-12-13-22-17-01"></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<ol>
<li><a href="https://blog.csdn.net/zerolord/article/details/116891720">Ubuntu20.04安装llvm</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/llvm-project.git/">LLVM Git 源码仓库镜像使用帮助</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102028114">LLVM概述——介绍与安装</a></li>
<li><a href="https://apt.llvm.org/">LLVM Debian/Ubuntu nightly packages</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/321882707">Ninja安装和基本使用</a></li>
<li><a href="https://blog.csdn.net/lj402159806/article/details/76408597">ubuntu安装CMake的几种方式</a></li>
<li><a href="https://llvm.org/docs/GettingStarted.html">Getting Started with the LLVM System</a></li>
<li><a href="https://github.com/llvm/llvm-project">Getting Started with the LLVM System(github)</a></li>
<li><a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/ch01.html">第1章 编译和安装LLVM</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>工具链</tag>
      </tags>
  </entry>
  <entry>
    <title>双口RAM及其VIVADO的IP核的使用</title>
    <url>/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="双口ram概述"><a class="markdownIt-Anchor" href="#双口ram概述"></a> 双口RAM概述</h1>
<p>双口RAM（dual port RAM）在异构系统中应用广泛，通过双口RAM，不同硬件架构的芯片可以实现数据的交互，从而实现通信。例如，一般情况下，ARM与DSP之间的通信，可以利用双口RAM实现，ARM通过EBI总线连接到双口RAM的A口，DSP通过EMIF总线（也可以是uPP总线，取决于速度需求）连接到双口RAM的B口，两者对同一块存储区域进行操作，即可实现两者的数据交互。</p>
<span id="more"></span>
<p>但是，因为双口RAM的A口和B口都可以对相同的内存地址进行操作，这就引出了一个问题——假如通信双方在两个端口对同一地址同时读写，就会引发冲突。要解决这个问题，办法有二。一是通信双方在时序上保证不会同时读写同一地址，将ARM和DSP可写地址范围进行分区，无论任何一方写完数据后都通过IO发送中断通知对方，对方进行数据读取（乒乓RAM操作），这样是比较可靠的；另外一个办法就是在fpga里设置写busy信号，实现两端写同步<a href="http://blog.csdn.net/DanielLee_ustb/article/details/46446359">1</a>。在FPGA中，构建双口RAM可以通过两种方法，一种是利用distributed RAM构建，另一种是利用Block RAM构建，关于两者的具体区别，可以参考这两篇文章<a href="http://blog.csdn.net/yzy19900402/article/details/45025901">2</a><a href="http://blog.csdn.net/jbb0523/article/details/6533760">3</a>。简而言之，Block RAM是是使用FPGA中的整块双口RAM资源，而distributed RAM则是用FPGA中的逻辑资源拼凑形成的。一般的原则是，较大的存储应用，建议用bram；零星的小ram，一般就用dram。</p>
<p>在Vivado中，RAM IP核在Memories &amp; Strorage Elements\RAM &amp; ROMs和RAM &amp; ROMs &amp; BRAM文件夹下，如图所示，下面简要介绍一下Vivado的双口RAM IP核。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-23-22.png#pic_center" alt="图1.1" title="图1.1"></p>
<h1 id="vivado-双口ram-ip核"><a class="markdownIt-Anchor" href="#vivado-双口ram-ip核"></a> Vivado 双口RAM IP核</h1>
<h2 id="block-memory-generator概述"><a class="markdownIt-Anchor" href="#block-memory-generator概述"></a> Block Memory Generator概述</h2>
<p>点击图1.1的Block Memory Generator项，利用BRAM来构建双口RAM。Block Memory Generator窗口如图2.1所示。图中，第1部分，在IP symbol选项卡，点击&quot;+&quot;号可以展开端口具体信号，如图2.2所示。第2部分，Component Name可以设置IP核的名字。第3部分，Basic选项卡，在Memory Type下拉列表中，可以设置内存的类型，如图2.3所示。Block Memory Gnerator一共可以产生5种不同类型的内存空间，其中block RAM有三种：单口RAM、简化双口RAM和真双口RAM<a href="https://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_2/pg058-blk-mem-gen.pdf">4</a>。单口RAM只有一个端口（A端口），可以对A端口进行读写。简化双口RAM有两个端口（A和B端口），但是A端口只能进行写入操作，不能进行读出操作，而B端口则只能进行读出操作，不能进行写入操作。真双口RAM有两个端口（A和B端口），A和B端口都能进行读写操作<a href="http://blog.csdn.net/c602273091/article/details/39694145">5</a>。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-24-16.png#pic_center" alt="图2.1" title="图2.1"><br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-24-48.png#pic_center" alt="图2.2" title="图2.2"><br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-25-15.png#pic_center" alt="图2.3" title="图2.3"></p>
<h2 id="真双口ram的设置"><a class="markdownIt-Anchor" href="#真双口ram的设置"></a> 真双口RAM的设置</h2>
<h3 id="basic设置"><a class="markdownIt-Anchor" href="#basic设置"></a> Basic设置</h3>
<p><img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-25-36.png#pic_center" alt="图2.4" title="图2.4"></p>
<h3 id="port设置"><a class="markdownIt-Anchor" href="#port设置"></a> Port设置</h3>
<p>点击Port A Options选项卡，对A端口进行设置， 设置Write Width为16（即RAM单元为16位），Write Width为1024（即内存深度为1024，该端口可读写的RAM单元有1024个），Operating Mode（操作模式）一共有三种：Write First，Read First，No Change。在Write First模式中，在一个时钟周期里，写入内存单元的数据被同步输出到输出数据总线上；在Read First模式中，在一个时钟周期里，写入到内存单元的数据是当前输入数据总线上的数据，而输出到输出数据总线上的数据则是上一个时钟周期存储在内存单元中的数据。细节可参考PG058的49到50页4。Enable Port Type设置为Always Enabled，一直使能端口A。其它设置使用默认设置。如图2.5所示。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-26-04.png#pic_center" alt="图2.5" title="图2.5"><br>
端口B设置为与A一致。在Other Options选项卡中，保留默认设置。Load Init File设置是否用Coe文件对内存区域初始化，这个在初始化ROM的时候会用到，这里不勾选，保持默认。最后，在Summary选项卡会显示消耗的资源。</p>
<h1 id="双口ram例程"><a class="markdownIt-Anchor" href="#双口ram例程"></a> 双口RAM例程</h1>
<p>​例程1，该例程是Altera官方例程<a href="https://www.altera.com.cn/support/support-resources/design-examples/design-software/verilog/ver-true-dual-port-ram-sclk.html">6</a>，采用寄存器构建双口RAM，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module <span class="title function_">true_dpram_sclk</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    input [<span class="number">7</span>:<span class="number">0</span>] data_a, data_b,</span></span><br><span class="line"><span class="params">    input [<span class="number">5</span>:<span class="number">0</span>] addr_a, addr_b,</span></span><br><span class="line"><span class="params">    input we_a, we_b, clk,</span></span><br><span class="line"><span class="params">    output reg [<span class="number">7</span>:<span class="number">0</span>] q_a, q_b</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">    <span class="comment">// Declare the RAM variable</span></span><br><span class="line">    reg [<span class="number">7</span>:<span class="number">0</span>] ram[<span class="number">63</span>:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Port A</span></span><br><span class="line">    always @ (posedge clk)</span><br><span class="line">    begin</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(we_a)</span> </span><br><span class="line">        begin</span><br><span class="line">            ram[addr_a] &lt;= data_a;</span><br><span class="line">            q_a &lt;= data_a;</span><br><span class="line">        end</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        begin</span><br><span class="line">            q_a &lt;= ram[addr_a];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Port B</span></span><br><span class="line">    always @ (posedge clk)</span><br><span class="line">    begin</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(we_b)</span></span><br><span class="line">        begin</span><br><span class="line">            ram[addr_b] &lt;= data_b;</span><br><span class="line">            q_b &lt;= data_b;</span><br><span class="line">        end</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        begin</span><br><span class="line">            q_b &lt;= ram[addr_b];</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p>例程2，该例程是Xilinx官方例程<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_4/ug901-vivado-synthesis.pdf">7</a>，采用寄存器构建真双口RAM，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dual-Port Block RAM with Two Write Ports</span></span><br><span class="line"><span class="comment">// File: rams_16.v</span></span><br><span class="line"></span><br><span class="line">module <span class="title function_">v_rams_16</span> <span class="params">(clka,clkb,ena,enb,wea,web,addra,addrb,dia,dib,doa,dob)</span>;</span><br><span class="line"></span><br><span class="line">input clka,clkb,ena,enb,wea,web;</span><br><span class="line">input [<span class="number">9</span>:<span class="number">0</span>] addra,addrb;</span><br><span class="line">input [<span class="number">15</span>:<span class="number">0</span>] dia,dib;</span><br><span class="line">output [<span class="number">15</span>:<span class="number">0</span>] doa,dob;</span><br><span class="line">reg[<span class="number">15</span>:<span class="number">0</span>] ram [<span class="number">1023</span>:<span class="number">0</span>];</span><br><span class="line">reg[<span class="number">15</span>:<span class="number">0</span>] doa,dob;</span><br><span class="line"></span><br><span class="line">always @(posedge clka) begin <span class="title function_">if</span> <span class="params">(ena)</span></span><br><span class="line">begin</span><br><span class="line"> <span class="title function_">if</span> <span class="params">(wea)</span></span><br><span class="line"> ram[addra] &lt;= dia;</span><br><span class="line"> doa &lt;= ram[addra];</span><br><span class="line"> end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always @(posedge clkb) begin <span class="title function_">if</span> <span class="params">(enb)</span></span><br><span class="line">begin</span><br><span class="line"> <span class="title function_">if</span> <span class="params">(web)</span></span><br><span class="line"> ram[addrb] &lt;= dib;</span><br><span class="line"> dob &lt;= ram[addrb];</span><br><span class="line"> end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p>​例程3，该例程是网友博客中的例程<a href="http://blog.csdn.net/yanglong890124/article/details/32742297">8</a>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module <span class="title function_">TOP</span><span class="params">(  </span></span><br><span class="line"><span class="params">input USER_CLK  </span></span><br><span class="line"><span class="params">    )</span>;  </span><br><span class="line">  </span><br><span class="line">`define DLY #<span class="number">1</span>  </span><br><span class="line">reg FPGA_Enable=<span class="number">0</span>;  </span><br><span class="line">reg[<span class="number">3</span>:<span class="number">0</span>] FPGA_Write_Enable=<span class="number">4&#x27;</span>h0;  </span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] FPGA_Address=<span class="number">0</span>;  </span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] FPGA_Write_Data=<span class="number">0</span>;  </span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data_reg=<span class="number">0</span>;  </span><br><span class="line">wire[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data;  </span><br><span class="line">  </span><br><span class="line">reg[<span class="number">10</span>:<span class="number">0</span>] count=<span class="number">0</span>;  </span><br><span class="line">always @ (posedge USER_CLK)  </span><br><span class="line">begin  </span><br><span class="line">    count &lt;= count + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;=<span class="number">100</span>)  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;</span>h0;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">((count &lt;= <span class="number">105</span>)&amp;&amp;(count &gt;<span class="number">100</span>))</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;</span>hf;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= FPGA_Write_Data + <span class="number">1</span>;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">((count &lt;= <span class="number">110</span>)&amp;&amp;(count &gt;<span class="number">105</span>))</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;</span>h0;  </span><br><span class="line">        FPGA_Address &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= <span class="number">0</span>;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">((count &lt;= <span class="number">117</span>)&amp;&amp;(count &gt;<span class="number">110</span>))</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">4&#x27;</span>h0;  </span><br><span class="line">        FPGA_Read_Data_reg &lt;= FPGA_Read_Data;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">(count == <span class="number">118</span>)</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        count &lt;= count;  </span><br><span class="line">          </span><br><span class="line">    end  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">BBBB <span class="title function_">your_instance_name</span> <span class="params">(  </span></span><br><span class="line"><span class="params">  .clka(USER_CLK), <span class="comment">// input clka  </span></span></span><br><span class="line"><span class="params">  .ena(FPGA_Enable), <span class="comment">// input ena  </span></span></span><br><span class="line"><span class="params">  .wea(FPGA_Write_Enable), <span class="comment">// input [3 : 0] wea  </span></span></span><br><span class="line"><span class="params">  .addra(FPGA_Address), <span class="comment">// input [31 : 0] addra  </span></span></span><br><span class="line"><span class="params">  .dina(FPGA_Write_Data), <span class="comment">// input [31 : 0] dina  </span></span></span><br><span class="line"><span class="params">  .douta(FPGA_Read_Data), <span class="comment">// output [31 : 0] douta  </span></span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">  .clkb(clkb), <span class="comment">// input clkb  </span></span></span><br><span class="line"><span class="params">  .enb(enb), <span class="comment">// input enb  </span></span></span><br><span class="line"><span class="params">  .web(web), <span class="comment">// input [3 : 0] web  </span></span></span><br><span class="line"><span class="params">  .addrb(addrb), <span class="comment">// input [31 : 0] addrb  </span></span></span><br><span class="line"><span class="params">  .dinb(dinb), <span class="comment">// input [31 : 0] dinb  </span></span></span><br><span class="line"><span class="params">  .doutb(doutb) <span class="comment">// output [31 : 0] doutb  </span></span></span><br><span class="line"><span class="params">)</span>;  </span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p>​该例程中，在count为101（&gt;100）后开始往地址4到20写入1-5，然后在count为111（&gt;110）的时候读出写入的数据。</p>
<h1 id="仿真"><a class="markdownIt-Anchor" href="#仿真"></a> 仿真</h1>
<p>下面利用Modelsim和Vivado进行联合仿真，关于vivado如何与modelsim进行联合仿真可以参考这篇文章：</p>
<p><a href="http://blog.chinaaet.com/crazybird/p/5100000539">vivado与modelsim的关联以及器件库编译</a></p>
<p>有一点要注意的是，我用的是Vivado2017.1版本，这个版本只支持Modelsim10.5及以上的版本，如果是低版本的Modelsim，在用Vivado2017.1编译Modelsim的仿真库时，会出错。Modelsim10.5版本可以在这里下载：</p>
<p><a href="http://bbs.eetop.cn/viewthread.php?tid=629292&amp;extra=&amp;page=1">modelsim 10.5 适用vivado 2017.1</a></p>
<p>用Modelsim仿真时，会在sim_1/behav文件夹下产生3个.do文件，分别是xx_compile.do，xx_simulate.do，xx _wave.do文件。在设计的verilog文件修改之后，如果在Modelsim中直接restart，仿真的其实还是没有修改前的文件，要使修改的.v文件在Modelsim中生效，可以在Modelsim的命令窗口输入do xx_compile.do文件，对仿真的库文件以及设计文件（.v文件）重新编译，然后在输入do xx_simulate.do文件，才能仿真修改后的文件。输入do xx_compile.do命令对设计文件重新编译的时候，Modelsim会强制退出，这时由最后一句force quit命令引起的，只要把它删掉就行了。如果要保存波形文件，可以save format，另存为xx_wave.do文件。</p>
<p>参考上面双口RAM的例程3进行功能仿真，RAM IP使用Write First模式，设计文件代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`timescale <span class="number">1</span>ns / <span class="number">1</span>ps</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Company: </span></span><br><span class="line"><span class="comment">// Engineer: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Create Date: 2017/12/09 22:36:48</span></span><br><span class="line"><span class="comment">// Design Name: </span></span><br><span class="line"><span class="comment">// Module Name: dual_port_ram_demo</span></span><br><span class="line"><span class="comment">// Project Name: </span></span><br><span class="line"><span class="comment">// Target Devices: </span></span><br><span class="line"><span class="comment">// Tool Versions: </span></span><br><span class="line"><span class="comment">// Description: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Dependencies: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Revision:</span></span><br><span class="line"><span class="comment">// Revision 0.01 - File Created</span></span><br><span class="line"><span class="comment">// Additional Comments:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">module <span class="title function_">dual_port_ram_demo</span><span class="params">(</span></span><br><span class="line"><span class="params">input USER_CLK</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">  </span><br><span class="line">`define DLY #<span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Port A declaration</span></span><br><span class="line">reg FPGA_Enable=<span class="number">0</span>;  </span><br><span class="line">reg FPGA_Write_Enable=<span class="number">0</span>;  </span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] FPGA_Address=<span class="number">0</span>;  </span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] FPGA_Write_Data=<span class="number">0</span>;  </span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data_reg=<span class="number">0</span>;  </span><br><span class="line">wire[<span class="number">31</span>:<span class="number">0</span>] FPGA_Read_Data;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//Port B declaration</span></span><br><span class="line">reg enb=<span class="number">0</span>;</span><br><span class="line">reg[<span class="number">3</span>:<span class="number">0</span>] web=<span class="number">4&#x27;</span>h0;</span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] addrb=<span class="number">0</span>;</span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] dinb=<span class="number">0</span>;</span><br><span class="line">reg[<span class="number">31</span>:<span class="number">0</span>] doutb_reg=<span class="number">0</span>;</span><br><span class="line">wire[<span class="number">31</span>:<span class="number">0</span>] doutb=<span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">reg[<span class="number">10</span>:<span class="number">0</span>] count=<span class="number">0</span>;  </span><br><span class="line">always @ (posedge USER_CLK)  </span><br><span class="line">begin  </span><br><span class="line">    count &lt;= count + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;=<span class="number">100</span>)  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">((count &lt;= <span class="number">105</span>)&amp;&amp;(count &gt;<span class="number">100</span>))</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= FPGA_Write_Data + <span class="number">1</span>;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">((count &lt;= <span class="number">110</span>)&amp;&amp;(count &gt;<span class="number">105</span>))</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Address &lt;= <span class="number">0</span>;  </span><br><span class="line">        FPGA_Write_Data &lt;= <span class="number">0</span>;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">((count &lt;= <span class="number">117</span>)&amp;&amp;(count &gt;<span class="number">110</span>))</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Write_Enable &lt;= <span class="number">1</span>;  </span><br><span class="line">        FPGA_Read_Data_reg &lt;= FPGA_Read_Data;  </span><br><span class="line">        FPGA_Address &lt;= FPGA_Address + <span class="number">4</span>;  </span><br><span class="line">    end  </span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">if</span><span class="params">(count == <span class="number">118</span>)</span>  </span><br><span class="line">    begin  </span><br><span class="line">        FPGA_Enable &lt;= <span class="number">0</span>;  </span><br><span class="line">        count &lt;= count;  </span><br><span class="line">          </span><br><span class="line">    end  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">dpRAM <span class="title function_">u1</span> <span class="params">(  </span></span><br><span class="line"><span class="params">  .clka(USER_CLK), <span class="comment">// input clka  </span></span></span><br><span class="line"><span class="params">  .ena(FPGA_Enable), <span class="comment">// input ena  </span></span></span><br><span class="line"><span class="params">  .wea(FPGA_Write_Enable), <span class="comment">// input [3 : 0] wea  </span></span></span><br><span class="line"><span class="params">  .addra(FPGA_Address), <span class="comment">// input [31 : 0] addra  </span></span></span><br><span class="line"><span class="params">  .dina(FPGA_Write_Data), <span class="comment">// input [31 : 0] dina  </span></span></span><br><span class="line"><span class="params">  .douta(FPGA_Read_Data), <span class="comment">// output [31 : 0] douta  </span></span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">  .clkb(USER_CLK), <span class="comment">// input clkb  </span></span></span><br><span class="line"><span class="params">  .enb(enb), <span class="comment">// input enb  </span></span></span><br><span class="line"><span class="params">  .web(web), <span class="comment">// input [3 : 0] web  </span></span></span><br><span class="line"><span class="params">  .addrb(addrb), <span class="comment">// input [31 : 0] addrb  </span></span></span><br><span class="line"><span class="params">  .dinb(dinb), <span class="comment">// input [31 : 0] dinb  </span></span></span><br><span class="line"><span class="params">  .doutb(doutb) <span class="comment">// output [31 : 0] doutb  </span></span></span><br><span class="line"><span class="params">)</span>;  </span><br><span class="line">endmodule  </span><br></pre></td></tr></table></figure>
<p>​testbench文件如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`timescale <span class="number">1</span>ns / <span class="number">1</span>ps</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Company: </span></span><br><span class="line"><span class="comment">// Engineer: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Create Date: 2017/12/09 22:47:26</span></span><br><span class="line"><span class="comment">// Design Name: </span></span><br><span class="line"><span class="comment">// Module Name: simu</span></span><br><span class="line"><span class="comment">// Project Name: </span></span><br><span class="line"><span class="comment">// Target Devices: </span></span><br><span class="line"><span class="comment">// Tool Versions: </span></span><br><span class="line"><span class="comment">// Description: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Dependencies: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Revision:</span></span><br><span class="line"><span class="comment">// Revision 0.01 - File Created</span></span><br><span class="line"><span class="comment">// Additional Comments:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">module <span class="title function_">simu</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"><span class="comment">//testbench 时钟信号</span></span><br><span class="line">reg clk = <span class="number">0</span>;</span><br><span class="line">always # <span class="number">10</span> clk &lt;= ~clk;</span><br><span class="line"><span class="comment">//调用dual_port_ram_demo模块</span></span><br><span class="line">dual_port_ram_demo <span class="title function_">demo1</span><span class="params">(clk)</span>;</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<p>仿真结果如下：<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-26-41.png#pic_center" alt="图4.1" title="图4.1"><br>
程序在1时刻准备好地址和要写入RAM的数据，在2时刻写入RAM中，在3时刻端口才会输出2时刻写入RAM的数据，注意与PG058的图稍有不同。<br>
<img src="/2022/06/17/%E5%8F%8C%E5%8F%A3RAM%E5%8F%8AVi%E5%85%B6VIVADO%E7%9A%84IP%E6%A0%B8%E7%9A%84%E4%BD%BF%E7%94%A8/2022-06-17-01-27-26.png#pic_center" alt="图4.2" title="图4.2"></p>
<h1 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h1>
<p>关于BRAM，推荐一个youtube视频，里面讲的非常清晰易懂。<br>
<a href="https://www.youtube.com/watch?v=fqUuvwl4QJA">What is a Block RAM in an FPGA?</a></p>
<h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1>
<p>[1] <a href="http://blog.csdn.net/DanielLee_ustb/article/details/46446359">基于FPGA的双口RAM设计方法</a><br>
[2] <a href="http://blog.csdn.net/yzy19900402/article/details/45025901">关于Xilinx芯片中Block RAM和Distributed RAM 的区别</a><br>
[3] <a href="http://blog.csdn.net/jbb0523/article/details/6533760">Block RAM 和Distributed RAM</a><br>
[4] <a href="https://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_2/pg058-blk-mem-gen.pdf">Block Memory Generator v8.2 LogiCORE IP Product Guide (PG058)</a><br>
[5] <a href="http://blog.csdn.net/c602273091/article/details/39694145">FPGA开发之RAM IP的使用</a><br>
[6] <a href="https://www.altera.com.cn/support/support-resources/design-examples/design-software/verilog/ver-true-dual-port-ram-sclk.html">Verilog HDL：具有单时钟的真双端口RAM</a><br>
[7] <a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2014_4/ug901-vivado-synthesis.pdf">Vivado Design Suite User Guide: Synthesis (UG901)</a><br>
[8] <a href="http://blog.csdn.net/yanglong890124/article/details/32742297">FPGA 内部双口块RAM 读写实现</a></p>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPAG</tag>
      </tags>
  </entry>
</search>
